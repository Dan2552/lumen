<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hold</title>
    <link rel="stylesheet" href="/lucide/font/lucide.css" />
    <style>
      :root {
        --accent-600: #1f5fbf;
        --accent-500: #2f86e9;
        --accent-250: #c7dafc;
        --accent-175: #d9e6ff;
        --accent-150: #dce9ff;
        --accent-050: #f3f6ff;
        --accent-overlay-soft: rgba(48, 74, 120, 0.4);
        --accent-border-soft: rgba(118, 167, 255, 0.6);
        color-scheme: dark;
      }

      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: transparent;
        font-family: "SF Pro Text", "SF Pro Display", "Segoe UI", sans-serif;
        user-select: none;
        -webkit-user-select: none;
      }

      .shell {
        box-sizing: border-box;
        width: 100%;
        height: 100%;
        border: 1px solid #404759;
        background: rgba(38, 44, 58, 0.9);
        overflow: hidden;
        user-select: none;
        -webkit-user-select: none;
      }

      .shell.has-items {
        border-color: var(--accent-500);
        background: var(--accent-600);
      }

      .drop-area {
        width: 100%;
        height: 100%;
        background: transparent;
        color: var(--accent-050);
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 0 12px;
        box-sizing: border-box;
        user-select: none;
        -webkit-user-select: none;
      }

      .drop-area.is-over {
        background: var(--accent-overlay-soft);
        box-shadow: inset 0 0 0 1px var(--accent-border-soft);
      }

      .title {
        font-size: 12px;
        font-weight: 600;
        color: var(--accent-050);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
        user-select: none;
        -webkit-user-select: none;
      }

      .hold-card {
        flex: 1;
        min-width: 0;
        height: 100%;
        border: none;
        background: transparent;
        color: var(--accent-050);
        box-sizing: border-box;
        cursor: default;
        user-select: none;
        -webkit-user-select: none;
        display: flex;
        align-items: center;
      }

      .hold-card[hidden] {
        display: none;
      }

      .row {
        display: flex;
        justify-content: flex-start;
        align-items: center;
        gap: 10px;
        width: 100%;
        user-select: none;
        -webkit-user-select: none;
      }

      .row-icon {
        width: 16px;
        color: var(--accent-175);
        text-align: center;
        flex-shrink: 0;
        font-size: 14px;
      }

      .row-icon[hidden] {
        display: none;
      }

      .row-name {
        flex: 1;
        min-width: 0;
        font-size: 12px;
        font-weight: 600;
        color: var(--accent-050);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        user-select: none;
        -webkit-user-select: none;
      }

      .count {
        font-size: 11px;
        color: var(--accent-150);
        flex-shrink: 0;
        user-select: none;
        -webkit-user-select: none;
      }

      .clear {
        border: none;
        background: transparent;
        color: var(--accent-150);
        font-size: 12px;
        line-height: 1;
        cursor: default;
        min-width: 18px;
        height: 18px;
        padding: 0 4px;
        margin-left: 2px;
        flex-shrink: 0;
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <div class="drop-area" id="drop-area">
        <div class="title" id="title-label">Drop here to hold</div>
        <div class="hold-card" id="hold-card" draggable="true" hidden>
          <div class="row">
            <i class="row-icon" id="row-icon" aria-hidden="true"></i>
            <div class="row-name" id="name-label">item</div>
            <div class="count" id="count-label">1</div>
            <button class="clear" id="clear-button" type="button">x</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        const dropArea = document.getElementById("drop-area");
        const holdCard = document.getElementById("hold-card");
        const titleLabel = document.getElementById("title-label");
        const countLabel = document.getElementById("count-label");
        const nameLabel = document.getElementById("name-label");
        const rowIcon = document.getElementById("row-icon");
        const clearButton = document.getElementById("clear-button");
        const invoke = window.__TAURI__?.core?.invoke;
        const getCurrentWindow = window.__TAURI__?.window?.getCurrentWindow;
        const startDrag = window.__TAURI__?.drag?.startDrag;
        let heldPaths = [];
        const dragIconCache = new Map();
        const clampChannel = (value) => Math.max(0, Math.min(255, Number(value) || 0));
        const hexToRgb = (value) => {
          const raw = String(value || "").trim().replace(/^#/, "");
          if (raw.length === 3 && /^[0-9a-fA-F]{3}$/.test(raw)) {
            return {
              r: parseInt(raw[0] + raw[0], 16),
              g: parseInt(raw[1] + raw[1], 16),
              b: parseInt(raw[2] + raw[2], 16),
            };
          }
          if (raw.length === 6 && /^[0-9a-fA-F]{6}$/.test(raw)) {
            return {
              r: parseInt(raw.slice(0, 2), 16),
              g: parseInt(raw.slice(2, 4), 16),
              b: parseInt(raw.slice(4, 6), 16),
            };
          }
          return null;
        };
        const rgbToHex = (rgb) => {
          const toHex = (channel) => clampChannel(channel).toString(16).padStart(2, "0").toUpperCase();
          return `#${toHex(rgb.r)}${toHex(rgb.g)}${toHex(rgb.b)}`;
        };
        const mixRgb = (a, b, amount) => ({
          r: Math.round(a.r + (b.r - a.r) * amount),
          g: Math.round(a.g + (b.g - a.g) * amount),
          b: Math.round(a.b + (b.b - a.b) * amount),
        });
        const rgbaColor = (rgb, alpha) =>
          `rgba(${clampChannel(rgb.r)}, ${clampChannel(rgb.g)}, ${clampChannel(rgb.b)}, ${alpha})`;
        const normalizeHexColor = (value) => {
          const parsed = hexToRgb(value);
          return parsed ? rgbToHex(parsed) : null;
        };
        const applyThemeHighlightColor = (value) => {
          const normalized = normalizeHexColor(value) || "#2F86E9";
          const base = hexToRgb(normalized) || {r: 47, g: 134, b: 233};
          const black = {r: 0, g: 0, b: 0};
          const white = {r: 255, g: 255, b: 255};
          const darken = (amount) => mixRgb(base, black, amount);
          const lighten = (amount) => mixRgb(base, white, amount);
          const overlayBase = darken(0.48);
          const borderBase = lighten(0.34);
          const rootStyle = document.documentElement.style;
          rootStyle.setProperty("--accent-600", rgbToHex(darken(0.28)));
          rootStyle.setProperty("--accent-500", rgbToHex(base));
          rootStyle.setProperty("--accent-250", rgbToHex(lighten(0.48)));
          rootStyle.setProperty("--accent-175", rgbToHex(lighten(0.62)));
          rootStyle.setProperty("--accent-150", rgbToHex(lighten(0.58)));
          rootStyle.setProperty("--accent-050", rgbToHex(lighten(0.86)));
          rootStyle.setProperty("--accent-overlay-soft", rgbaColor(overlayBase, 0.4));
          rootStyle.setProperty("--accent-border-soft", rgbaColor(borderBase, 0.6));
          return normalized;
        };
        const themeToken = (name, fallback) =>
          (window.getComputedStyle(document.documentElement).getPropertyValue(name) || "").trim() || fallback;
        let currentThemeHighlightColor = applyThemeHighlightColor("#2F86E9");
        if (typeof invoke === "function") {
          invoke("get_theme_highlight_color")
            .then((color) => {
              currentThemeHighlightColor = applyThemeHighlightColor(String(color || currentThemeHighlightColor));
            })
            .catch(() => {});
        }
        const tauriListen = window.__TAURI__?.event?.listen;
        if (typeof tauriListen === "function") {
          tauriListen("theme-highlight-color-changed", (event) => {
            const normalized = normalizeHexColor(String(event?.payload || ""));
            if (!normalized) return;
            currentThemeHighlightColor = applyThemeHighlightColor(normalized);
          }).catch(() => {});
        }
        const clampName = (name) => {
          const limit = 34;
          if (!name || name.length <= limit) return name || "item";
          return `${name.slice(0, limit - 1)}\u2026`;
        };
        const pngDataUrlToBytes = (dataUrl) => {
          const encoded = dataUrl.split(",")[1] || "";
          const raw = atob(encoded);
          const bytes = new Array(raw.length);
          for (let i = 0; i < raw.length; i += 1) {
            bytes[i] = raw.charCodeAt(i);
          }
          return bytes;
        };
        const makeRowDragIcon = (name) => {
          const key = `f:${name}`;
          if (dragIconCache.has(key)) {
            return dragIconCache.get(key);
          }
          const width = 260;
          const height = 32;
          const radius = 6;
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          if (!ctx) {
            return [];
          }
          ctx.clearRect(0, 0, width, height);
          ctx.fillStyle = themeToken("--accent-600", "#1F5FBF");
          ctx.strokeStyle = themeToken("--accent-500", "#2F86E9");
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(radius, 0);
          ctx.lineTo(width - radius, 0);
          ctx.quadraticCurveTo(width, 0, width, radius);
          ctx.lineTo(width, height - radius);
          ctx.quadraticCurveTo(width, height, width - radius, height);
          ctx.lineTo(radius, height);
          ctx.quadraticCurveTo(0, height, 0, height - radius);
          ctx.lineTo(0, radius);
          ctx.quadraticCurveTo(0, 0, radius, 0);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.strokeStyle = themeToken("--accent-250", "#C7DAFC");
          ctx.fillStyle = "transparent";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(11.5, 9.5);
          ctx.lineTo(20, 9.5);
          ctx.lineTo(24.5, 14);
          ctx.lineTo(24.5, 22.5);
          ctx.lineTo(11.5, 22.5);
          ctx.closePath();
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(20, 9.5);
          ctx.lineTo(20, 14);
          ctx.lineTo(24.5, 14);
          ctx.stroke();
          ctx.fillStyle = themeToken("--accent-050", "#F3F6FF");
          ctx.font = '600 13px "SF Pro Text", "Segoe UI", sans-serif';
          ctx.textBaseline = "middle";
          ctx.fillText(clampName(name), 30, Math.round(height / 2) + 0.5);
          const bytes = pngDataUrlToBytes(canvas.toDataURL("image/png"));
          dragIconCache.set(key, bytes);
          return bytes;
        };
        const iconClassForName = (name) => {
          const dotIndex = name.lastIndexOf(".");
          if (dotIndex < 0 || dotIndex === name.length - 1) return null;
          const ext = name.slice(dotIndex + 1).toLowerCase();
          if (["png", "jpg", "jpeg", "gif", "webp", "svg", "bmp", "ico", "avif", "heic", "tif", "tiff"].includes(ext)) {
            return "icon-file-image";
          }
          if (["mp4", "mov", "mkv", "avi", "webm", "m4v"].includes(ext)) {
            return "icon-file-video";
          }
          if (["mp3", "wav", "flac", "m4a", "aac", "ogg"].includes(ext)) {
            return "icon-file-audio";
          }
          if (["zip", "rar", "7z", "tar", "gz", "bz2", "xz"].includes(ext)) {
            return "icon-file-archive";
          }
          if (["rs", "js", "ts", "jsx", "tsx", "py", "go", "java", "c", "cpp", "h", "hpp", "cs", "php", "rb", "swift", "kt", "lua", "sh", "zsh", "bash", "html", "css", "scss", "xml"].includes(ext)) {
            return "icon-file-code";
          }
          if (["json"].includes(ext)) {
            return "icon-file-json";
          }
          if (["toml", "yaml", "yml", "md", "txt", "log", "pdf", "doc", "docx", "rtf", "odt"].includes(ext)) {
            return "icon-file-text";
          }
          if (["csv", "tsv", "xls", "xlsx"].includes(ext)) {
            return "icon-file-spreadsheet";
          }
          return null;
        };

        const render = () => {
          const count = heldPaths.length;
          const hasItems = count > 0;
          document.querySelector(".shell")?.classList.toggle("has-items", hasItems);
          holdCard.hidden = !hasItems;
          titleLabel.hidden = hasItems;
          if (!hasItems) return;

          const firstPath = heldPaths[0] || "";
          const name = firstPath.split("/").filter(Boolean).pop() || firstPath || "item";
          const iconClass = iconClassForName(name);
          rowIcon.className = "row-icon";
          if (iconClass) {
            rowIcon.hidden = false;
            rowIcon.classList.add(iconClass);
          } else {
            rowIcon.hidden = true;
          }
          nameLabel.textContent = name;
          countLabel.textContent = count > 1 ? `+${count - 1}` : "";
        };

        const refreshHeld = async () => {
          if (typeof invoke !== "function") return;
          heldPaths = await invoke("hold_get_items");
          render();
        };

        const bindDropEvents = () => {
          if (typeof getCurrentWindow !== "function" || typeof invoke !== "function") return;
          const currentWindow = getCurrentWindow();
          if (!currentWindow || typeof currentWindow.onDragDropEvent !== "function") return;
          currentWindow.onDragDropEvent(async (event) => {
            const payload = event?.payload || {};
            if (payload.type === "leave") {
              dropArea.classList.remove("is-over");
              return;
            }
            if (payload.type === "enter" || payload.type === "over") {
              if (Array.isArray(payload.paths) && payload.paths.length > 0) {
                dropArea.classList.add("is-over");
              }
              return;
            }
            if (payload.type !== "drop") return;
            dropArea.classList.remove("is-over");
            const paths = Array.isArray(payload.paths) ? payload.paths : [];
            if (paths.length === 0) return;
            heldPaths = await invoke("hold_add_items", {paths});
            render();
          });
        };

        const triggerHoldDrag = async () => {
          if (!heldPaths.length || typeof startDrag !== "function") return;
          try {
            const firstPath = heldPaths[0] || "";
            const name = firstPath.split("/").filter(Boolean).pop() || "item";
            await startDrag({
              item: heldPaths,
              icon: makeRowDragIcon(name),
            });
          } catch (_error) {
          }
        };

        holdCard.addEventListener("mousedown", async (event) => {
          if (event.button !== 0) return;
          if (event.target instanceof Element && event.target.closest("#clear-button")) return;
          event.preventDefault();
          await triggerHoldDrag();
        });

        holdCard.addEventListener("dragstart", async (event) => {
          event.preventDefault();
          await triggerHoldDrag();
        });

        clearButton.addEventListener("click", async () => {
          if (typeof invoke !== "function") return;
          await invoke("hold_clear_items");
          heldPaths = [];
          render();
        });

        bindDropEvents();
        refreshHeld();
      })();
    </script>
  </body>
</html>
