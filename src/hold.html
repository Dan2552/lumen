<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hold</title>
    <link rel="stylesheet" href="/lucide/font/lucide.css" />
    <style>
      :root {
        color-scheme: dark;
      }

      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: transparent;
        font-family: "SF Pro Text", "SF Pro Display", "Segoe UI", sans-serif;
      }

      .shell {
        box-sizing: border-box;
        width: 100%;
        height: 100%;
        border: 1px solid #404759;
        background: rgba(38, 44, 58, 0.9);
        overflow: hidden;
      }

      .shell.has-items {
        border-color: #2f86e9;
        background: #1f5fbf;
      }

      .drop-area {
        width: 100%;
        height: 100%;
        background: transparent;
        color: #f3f6ff;
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 0 12px;
        box-sizing: border-box;
      }

      .drop-area.is-over {
        background: rgba(48, 74, 120, 0.4);
        box-shadow: inset 0 0 0 1px rgba(118, 167, 255, 0.6);
      }

      .title {
        font-size: 12px;
        font-weight: 600;
        color: #f3f6ff;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
      }

      .hold-card {
        flex: 1;
        min-width: 0;
        height: 100%;
        border: none;
        background: transparent;
        color: #f3f6ff;
        box-sizing: border-box;
        cursor: default;
        user-select: none;
        display: flex;
        align-items: center;
      }

      .hold-card[hidden] {
        display: none;
      }

      .row {
        display: flex;
        justify-content: flex-start;
        align-items: center;
        gap: 10px;
        width: 100%;
      }

      .row-icon {
        width: 16px;
        color: #d9e6ff;
        text-align: center;
        flex-shrink: 0;
        font-size: 14px;
      }

      .row-icon[hidden] {
        display: none;
      }

      .row-name {
        flex: 1;
        min-width: 0;
        font-size: 12px;
        font-weight: 600;
        color: #edf3ff;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .count {
        font-size: 11px;
        color: #dce9ff;
        flex-shrink: 0;
      }

      .clear {
        border: none;
        background: transparent;
        color: #dce9ff;
        font-size: 12px;
        line-height: 1;
        cursor: default;
        min-width: 18px;
        height: 18px;
        padding: 0 4px;
        margin-left: 2px;
        flex-shrink: 0;
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <div class="drop-area" id="drop-area">
        <div class="title" id="title-label">Drop here to hold</div>
        <div class="hold-card" id="hold-card" draggable="true" hidden>
          <div class="row">
            <i class="row-icon" id="row-icon" aria-hidden="true"></i>
            <div class="row-name" id="name-label">item</div>
            <div class="count" id="count-label">1</div>
            <button class="clear" id="clear-button" type="button">x</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        const dropArea = document.getElementById("drop-area");
        const holdCard = document.getElementById("hold-card");
        const titleLabel = document.getElementById("title-label");
        const countLabel = document.getElementById("count-label");
        const nameLabel = document.getElementById("name-label");
        const rowIcon = document.getElementById("row-icon");
        const clearButton = document.getElementById("clear-button");
        const invoke = window.__TAURI__?.core?.invoke;
        const getCurrentWindow = window.__TAURI__?.window?.getCurrentWindow;
        const startDrag = window.__TAURI__?.drag?.startDrag;
        let heldPaths = [];
        const dragIconCache = new Map();
        const clampName = (name) => {
          const limit = 34;
          if (!name || name.length <= limit) return name || "item";
          return `${name.slice(0, limit - 1)}\u2026`;
        };
        const pngDataUrlToBytes = (dataUrl) => {
          const encoded = dataUrl.split(",")[1] || "";
          const raw = atob(encoded);
          const bytes = new Array(raw.length);
          for (let i = 0; i < raw.length; i += 1) {
            bytes[i] = raw.charCodeAt(i);
          }
          return bytes;
        };
        const makeRowDragIcon = (name) => {
          const key = `f:${name}`;
          if (dragIconCache.has(key)) {
            return dragIconCache.get(key);
          }
          const width = 260;
          const height = 32;
          const radius = 6;
          const canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          if (!ctx) {
            return [];
          }
          ctx.clearRect(0, 0, width, height);
          ctx.fillStyle = "#1f5fbf";
          ctx.strokeStyle = "#2f86e9";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(radius, 0);
          ctx.lineTo(width - radius, 0);
          ctx.quadraticCurveTo(width, 0, width, radius);
          ctx.lineTo(width, height - radius);
          ctx.quadraticCurveTo(width, height, width - radius, height);
          ctx.lineTo(radius, height);
          ctx.quadraticCurveTo(0, height, 0, height - radius);
          ctx.lineTo(0, radius);
          ctx.quadraticCurveTo(0, 0, radius, 0);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.strokeStyle = "#c7dafc";
          ctx.fillStyle = "transparent";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(11.5, 9.5);
          ctx.lineTo(20, 9.5);
          ctx.lineTo(24.5, 14);
          ctx.lineTo(24.5, 22.5);
          ctx.lineTo(11.5, 22.5);
          ctx.closePath();
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(20, 9.5);
          ctx.lineTo(20, 14);
          ctx.lineTo(24.5, 14);
          ctx.stroke();
          ctx.fillStyle = "#f3f6ff";
          ctx.font = '600 13px "SF Pro Text", "Segoe UI", sans-serif';
          ctx.textBaseline = "middle";
          ctx.fillText(clampName(name), 30, Math.round(height / 2) + 0.5);
          const bytes = pngDataUrlToBytes(canvas.toDataURL("image/png"));
          dragIconCache.set(key, bytes);
          return bytes;
        };
        const iconClassForName = (name) => {
          const dotIndex = name.lastIndexOf(".");
          if (dotIndex < 0 || dotIndex === name.length - 1) return null;
          const ext = name.slice(dotIndex + 1).toLowerCase();
          if (["png", "jpg", "jpeg", "gif", "webp", "svg", "bmp", "ico", "avif", "heic", "tif", "tiff"].includes(ext)) {
            return "icon-file-image";
          }
          if (["mp4", "mov", "mkv", "avi", "webm", "m4v"].includes(ext)) {
            return "icon-file-video";
          }
          if (["mp3", "wav", "flac", "m4a", "aac", "ogg"].includes(ext)) {
            return "icon-file-audio";
          }
          if (["zip", "rar", "7z", "tar", "gz", "bz2", "xz"].includes(ext)) {
            return "icon-file-archive";
          }
          if (["rs", "js", "ts", "jsx", "tsx", "py", "go", "java", "c", "cpp", "h", "hpp", "cs", "php", "rb", "swift", "kt", "lua", "sh", "zsh", "bash", "html", "css", "scss", "xml"].includes(ext)) {
            return "icon-file-code";
          }
          if (["json"].includes(ext)) {
            return "icon-file-json";
          }
          if (["toml", "yaml", "yml", "md", "txt", "log", "pdf", "doc", "docx", "rtf", "odt"].includes(ext)) {
            return "icon-file-text";
          }
          if (["csv", "tsv", "xls", "xlsx"].includes(ext)) {
            return "icon-file-spreadsheet";
          }
          return null;
        };

        const render = () => {
          const count = heldPaths.length;
          const hasItems = count > 0;
          document.querySelector(".shell")?.classList.toggle("has-items", hasItems);
          holdCard.hidden = !hasItems;
          titleLabel.hidden = hasItems;
          if (!hasItems) return;

          const firstPath = heldPaths[0] || "";
          const name = firstPath.split("/").filter(Boolean).pop() || firstPath || "item";
          const iconClass = iconClassForName(name);
          rowIcon.className = "row-icon";
          if (iconClass) {
            rowIcon.hidden = false;
            rowIcon.classList.add(iconClass);
          } else {
            rowIcon.hidden = true;
          }
          nameLabel.textContent = name;
          countLabel.textContent = count > 1 ? `+${count - 1}` : "";
        };

        const refreshHeld = async () => {
          if (typeof invoke !== "function") return;
          heldPaths = await invoke("hold_get_items");
          render();
        };

        const bindDropEvents = () => {
          if (typeof getCurrentWindow !== "function" || typeof invoke !== "function") return;
          const currentWindow = getCurrentWindow();
          if (!currentWindow || typeof currentWindow.onDragDropEvent !== "function") return;
          currentWindow.onDragDropEvent(async (event) => {
            const payload = event?.payload || {};
            if (payload.type === "leave") {
              dropArea.classList.remove("is-over");
              return;
            }
            if (payload.type === "enter" || payload.type === "over") {
              if (Array.isArray(payload.paths) && payload.paths.length > 0) {
                dropArea.classList.add("is-over");
              }
              return;
            }
            if (payload.type !== "drop") return;
            dropArea.classList.remove("is-over");
            const paths = Array.isArray(payload.paths) ? payload.paths : [];
            if (paths.length === 0) return;
            heldPaths = await invoke("hold_add_items", {paths});
            render();
          });
        };

        holdCard.addEventListener("dragstart", async (event) => {
          if (!heldPaths.length || typeof startDrag !== "function") return;
          event.preventDefault();
          try {
            const firstPath = heldPaths[0] || "";
            const name = firstPath.split("/").filter(Boolean).pop() || "item";
            await startDrag({
              item: heldPaths,
              icon: makeRowDragIcon(name),
            });
          } catch (_error) {
          }
        });

        clearButton.addEventListener("click", async () => {
          if (typeof invoke !== "function") return;
          await invoke("hold_clear_items");
          heldPaths = [];
          render();
        });

        bindDropEvents();
        refreshHeld();
      })();
    </script>
  </body>
</html>
