<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hold</title>
    <link rel="stylesheet" href="/lucide/font/lucide.css" />
    <style>
      :root {
        color-scheme: dark;
      }

      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: transparent;
        font-family: "SF Pro Text", "SF Pro Display", "Segoe UI", sans-serif;
      }

      .shell {
        box-sizing: border-box;
        width: 100%;
        height: 100%;
        border: 1px solid #404759;
        background: rgba(38, 44, 58, 0.9);
        overflow: hidden;
      }

      .shell.has-items {
        border-color: #2f86e9;
        background: #1f5fbf;
      }

      .drop-area {
        width: 100%;
        height: 100%;
        background: transparent;
        color: #f3f6ff;
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 0 12px;
        box-sizing: border-box;
      }

      .drop-area.is-over {
        background: rgba(255, 255, 255, 0.08);
      }

      .title {
        font-size: 12px;
        font-weight: 600;
        color: #f3f6ff;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 1;
      }

      .hold-card {
        flex: 1;
        min-width: 0;
        height: 100%;
        border: none;
        background: transparent;
        color: #f3f6ff;
        box-sizing: border-box;
        cursor: default;
        user-select: none;
        display: flex;
        align-items: center;
      }

      .hold-card[hidden] {
        display: none;
      }

      .row {
        display: flex;
        justify-content: flex-start;
        align-items: center;
        gap: 10px;
        width: 100%;
      }

      .row-icon {
        width: 16px;
        color: #d9e6ff;
        text-align: center;
        flex-shrink: 0;
        font-size: 14px;
      }

      .row-icon[hidden] {
        display: none;
      }

      .row-name {
        flex: 1;
        min-width: 0;
        font-size: 12px;
        font-weight: 600;
        color: #edf3ff;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .count {
        font-size: 11px;
        color: #dce9ff;
        flex-shrink: 0;
      }

      .clear {
        border: none;
        background: transparent;
        color: #dce9ff;
        font-size: 12px;
        line-height: 1;
        cursor: default;
        min-width: 18px;
        height: 18px;
        padding: 0 4px;
        margin-left: 2px;
        flex-shrink: 0;
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <div class="drop-area" id="drop-area">
        <div class="title" id="title-label">Drop here to hold</div>
        <div class="hold-card" id="hold-card" draggable="true" hidden>
          <div class="row">
            <i class="row-icon" id="row-icon" aria-hidden="true"></i>
            <div class="row-name" id="name-label">item</div>
            <div class="count" id="count-label">1</div>
            <button class="clear" id="clear-button" type="button">x</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        const dropArea = document.getElementById("drop-area");
        const holdCard = document.getElementById("hold-card");
        const titleLabel = document.getElementById("title-label");
        const countLabel = document.getElementById("count-label");
        const nameLabel = document.getElementById("name-label");
        const rowIcon = document.getElementById("row-icon");
        const clearButton = document.getElementById("clear-button");
        const invoke = window.__TAURI__?.core?.invoke;
        const getCurrentWindow = window.__TAURI__?.window?.getCurrentWindow;
        const startDrag = window.__TAURI__?.drag?.startDrag;
        const DRAG_ICON_BYTES = [137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,1,0,0,0,1,8,6,0,0,0,31,21,196,137,0,0,0,11,73,68,65,84,120,218,99,252,255,31,0,3,3,2,0,239,201,202,170,0,0,0,0,73,69,78,68,174,66,96,130];
        let heldPaths = [];
        const iconClassForName = (name) => {
          const dotIndex = name.lastIndexOf(".");
          if (dotIndex < 0 || dotIndex === name.length - 1) return null;
          const ext = name.slice(dotIndex + 1).toLowerCase();
          if (["png", "jpg", "jpeg", "gif", "webp", "svg", "bmp", "ico", "avif", "heic", "tif", "tiff"].includes(ext)) {
            return "icon-file-image";
          }
          if (["mp4", "mov", "mkv", "avi", "webm", "m4v"].includes(ext)) {
            return "icon-file-video";
          }
          if (["mp3", "wav", "flac", "m4a", "aac", "ogg"].includes(ext)) {
            return "icon-file-audio";
          }
          if (["zip", "rar", "7z", "tar", "gz", "bz2", "xz"].includes(ext)) {
            return "icon-file-archive";
          }
          if (["rs", "js", "ts", "jsx", "tsx", "py", "go", "java", "c", "cpp", "h", "hpp", "cs", "php", "rb", "swift", "kt", "lua", "sh", "zsh", "bash", "html", "css", "scss", "xml"].includes(ext)) {
            return "icon-file-code";
          }
          if (["json"].includes(ext)) {
            return "icon-file-json";
          }
          if (["toml", "yaml", "yml", "md", "txt", "log", "pdf", "doc", "docx", "rtf", "odt"].includes(ext)) {
            return "icon-file-text";
          }
          if (["csv", "tsv", "xls", "xlsx"].includes(ext)) {
            return "icon-file-spreadsheet";
          }
          return null;
        };

        const render = () => {
          const count = heldPaths.length;
          const hasItems = count > 0;
          document.querySelector(".shell")?.classList.toggle("has-items", hasItems);
          holdCard.hidden = !hasItems;
          titleLabel.hidden = hasItems;
          if (!hasItems) return;

          const firstPath = heldPaths[0] || "";
          const name = firstPath.split("/").filter(Boolean).pop() || firstPath || "item";
          const iconClass = iconClassForName(name);
          rowIcon.className = "row-icon";
          if (iconClass) {
            rowIcon.hidden = false;
            rowIcon.classList.add(iconClass);
          } else {
            rowIcon.hidden = true;
          }
          nameLabel.textContent = name;
          countLabel.textContent = count > 1 ? `+${count - 1}` : "";
        };

        const refreshHeld = async () => {
          if (typeof invoke !== "function") return;
          heldPaths = await invoke("hold_get_items");
          render();
        };

        const bindDropEvents = () => {
          if (typeof getCurrentWindow !== "function" || typeof invoke !== "function") return;
          const currentWindow = getCurrentWindow();
          if (!currentWindow || typeof currentWindow.onDragDropEvent !== "function") return;
          currentWindow.onDragDropEvent(async (event) => {
            const payload = event?.payload || {};
            if (payload.type === "leave") {
              dropArea.classList.remove("is-over");
              return;
            }
            if (payload.type === "enter" || payload.type === "over") {
              if (Array.isArray(payload.paths) && payload.paths.length > 0) {
                dropArea.classList.add("is-over");
              }
              return;
            }
            if (payload.type !== "drop") return;
            dropArea.classList.remove("is-over");
            const paths = Array.isArray(payload.paths) ? payload.paths : [];
            if (paths.length === 0) return;
            heldPaths = await invoke("hold_add_items", {paths});
            render();
          });
        };

        holdCard.addEventListener("dragstart", async (event) => {
          if (!heldPaths.length || typeof startDrag !== "function") return;
          event.preventDefault();
          try {
            await startDrag({
              item: heldPaths,
              icon: DRAG_ICON_BYTES,
            });
          } catch (_error) {
          }
        });

        clearButton.addEventListener("click", async () => {
          if (typeof invoke !== "function") return;
          await invoke("hold_clear_items");
          heldPaths = [];
          render();
        });

        bindDropEvents();
        refreshHeld();
      })();
    </script>
  </body>
</html>
