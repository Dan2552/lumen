<div
  id="main-root"
  class="files-root"
  data-active-tab-id="{{ active_tab_id }}"
  data-home-path="{{ home_path }}"
  data-root-path="{{ root_path }}"
  data-show-hidden="{% if show_hidden %}true{% else %}false{% endif %}"
  data-theme-base-color="{{ theme_base_color }}"
  data-theme-highlight-color="{{ theme_highlight_color }}"
  data-theme-lightness-offset="{{ theme_lightness_offset }}"
>
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  <style>
    #main-root.files-root {
      --accent-700: #1b4fa3;
      --accent-600: #1f5fbf;
      --accent-550: #2060c4;
      --accent-525: #2f6fce;
      --accent-500: #2f86e9;
      --accent-450: #4f8cdf;
      --accent-400: #74a9ff;
      --accent-300: #96c7ff;
      --accent-250: #c7dafc;
      --accent-200: #cfe0ff;
      --accent-175: #d9e6ff;
      --accent-150: #d7e6ff;
      --accent-100: #eaf2ff;
      --accent-075: #e4ecff;
      --accent-050: #f3f6ff;
      --accent-focus: #7fb3ff;
      --accent-overlay-soft: rgba(48, 74, 120, 0.4);
      --accent-overlay: rgba(48, 74, 120, 0.45);
      --accent-border-soft: rgba(118, 167, 255, 0.6);
      --accent-border: rgba(118, 167, 255, 0.72);
      --accent-border-strong: rgba(114, 167, 255, 0.95);
      --accent-border-selected: rgba(147, 192, 255, 0.85);
      --surface-980: #1a1f29;
      --surface-960: #262c3a;
      --surface-940: #2b313f;
      --surface-920: #323949;
      --surface-900: #3a4254;
      --surface-880: #596277;
      --surface-border: #404759;
      --surface-border-strong: #4b5364;
      --surface-overlay: rgba(10, 13, 20, 0.45);
      --text-muted: #c2c9d6;
      --text-strong: #f4f7ff;
      --selection-idle-bg: #525a6c;
      --selection-idle-border: #677189;
      --selection-idle-text: #e9eef9;
      --tab-border: #454d5d;
      --tab-active-border: #5b6477;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      margin: 0;
      background: var(--surface-940);
      color: var(--text-muted);
      font-family: "SF Pro Text", "SF Pro Display", "Segoe UI", sans-serif;
      font-size: 13px;
      line-height: 1.4;
      letter-spacing: 0.01em;
    }

    .tabs-bar {
      --traffic-lights-slot: 70px;
      display: flex;
      align-items: center;
      gap: 8px;
      min-height: 36px;
      padding: 4px 8px;
      background: var(--surface-980);
      border-bottom: 1px solid var(--surface-border);
      flex-shrink: 0;
    }

    .tabs-list {
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 0;
      flex: 1 1 auto;
      overflow: hidden;
    }

    .tabs-left-gutter {
      flex: 0 0 var(--traffic-lights-slot);
      min-width: var(--traffic-lights-slot);
      height: 28px;
      border-radius: 7px;
    }

    .tabs-drag-gutter {
      flex: 0 0 40px;
      min-width: 40px;
      height: 28px;
      border-radius: 7px;
    }

    .tab-button {
      height: 28px;
      min-width: 96px;
      max-width: 180px;
      padding: 0 10px;
      border: 1px solid var(--tab-border);
      border-radius: 7px;
      background: var(--surface-900);
      color: var(--text-muted);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: default;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      font-size: 12px;
      flex-shrink: 0;
      appearance: none;
      -webkit-appearance: none;
      -webkit-tap-highlight-color: transparent;
      outline: none;
    }

    .tab-shell {
      display: flex;
      align-items: center;
      border: 1px solid var(--tab-border);
      border-radius: 7px;
      background: var(--surface-900);
      overflow: hidden;
      flex: 1 1 0;
      min-width: 0;
      max-width: 220px;
    }

    .tab-shell.sortable-chosen {
      opacity: 1;
    }

    .tab-shell.sortable-ghost {
      box-shadow: inset 0 0 0 2px var(--accent-400);
      opacity: 0.6;
    }

    .tab-shell.sortable-drag {
      opacity: 0.72;
    }

    .tab-shell.is-active {
      background: var(--selection-idle-bg);
      border-color: var(--tab-active-border);
    }

    .tab-shell .tab-button {
      border: none;
      background: transparent;
      min-width: 0;
      max-width: none;
      width: 100%;
      flex: 1 1 auto;
      border-radius: 0;
    }

    .tab-shell .tab-button:active,
    .tab-shell .tab-button:focus,
    .tab-shell .tab-button:focus-visible {
      background: transparent;
      box-shadow: none;
      outline: none;
    }

    .tab-shell.is-active .tab-button {
      color: var(--text-strong);
    }

    .tab-close {
      width: 0;
      min-width: 0;
      height: 28px;
      border: none;
      border-left: 1px solid transparent;
      background: transparent;
      color: #aeb6c7;
      font-size: 12px;
      cursor: default;
      padding: 0;
      opacity: 0;
      pointer-events: none;
      transition:
        width 120ms ease,
        min-width 120ms ease,
        opacity 120ms ease,
        border-left-color 120ms ease;
    }

    .tab-shell:hover .tab-close,
    .tab-shell:focus-within .tab-close {
      width: 24px;
      min-width: 24px;
      opacity: 1;
      pointer-events: auto;
      border-left-color: rgba(140, 150, 170, 0.35);
    }

    .tab-shell.is-active .tab-close {
      color: #dce5f7;
      border-left-color: rgba(170, 184, 209, 0.45);
    }

    .tab-plus {
      width: 28px;
      min-width: 28px;
      flex: 0 0 28px;
      justify-content: center;
      font-size: 15px;
      padding: 0;
    }

    .finder-layout {
      display: flex;
      height: calc(100% - 36px);
      background: linear-gradient(180deg, var(--surface-920) 0%, var(--surface-940) 100%);
      border-right: 1px solid var(--surface-border);
      overflow-x: auto;
      overflow-y: hidden;
    }

    .finder-column {
      width: 280px;
      min-width: 240px;
      border-right: 1px solid var(--surface-border);
      background: var(--surface-920);
      display: flex;
      flex-direction: column;
    }

    .finder-column.is-drop-target {
      background: var(--accent-overlay-soft);
      box-shadow: inset 0 0 0 1px var(--accent-border-soft);
    }

    .preview-pane {
      width: 720px;
      min-width: 560px;
      border-left: 1px solid var(--surface-border);
      background: var(--surface-960);
      display: flex;
      flex-direction: column;
      cursor: default;
    }

    .preview-header {
      padding: 10px 12px;
      border-bottom: 1px solid var(--surface-border);
      background: var(--surface-960);
    }

    .preview-title {
      color: var(--text-strong);
      font-size: 13px;
      font-weight: 600;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .preview-subtitle {
      color: var(--text-muted);
      font-size: 11px;
      margin-top: 2px;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .preview-body {
      flex: 1;
      overflow: auto;
      padding: 12px;
      background: var(--surface-960);
    }

    .preview-image {
      width: 100%;
      height: auto;
      object-fit: contain;
      border-radius: 8px;
      border: 1px solid var(--surface-border-strong);
      background: var(--surface-980);
    }

    .preview-gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .preview-gallery-item {
      border: 1px solid var(--surface-border-strong);
      border-radius: 8px;
      overflow: hidden;
      background: var(--surface-980);
      min-height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .preview-gallery-item img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    .preview-text {
      margin: 0;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      color: var(--text-muted);
      font-size: 12px;
      line-height: 1.5;
      background: var(--surface-980);
      border: 1px solid var(--surface-border-strong);
      border-radius: 8px;
      padding: 10px;
      font-family: "SF Mono", "Menlo", "Consolas", monospace;
    }

    .preview-markdown {
      color: var(--text-muted);
      font-size: 13px;
      line-height: 1.6;
      background: var(--surface-980);
      border: 1px solid var(--surface-border-strong);
      border-radius: 8px;
      padding: 12px 14px;
      user-select: text !important;
      -webkit-user-select: text !important;
      cursor: text;
    }

    .preview-markdown * {
      user-select: text !important;
      -webkit-user-select: text !important;
    }

    .preview-markdown img {
      max-width: 100%;
      -webkit-user-drag: none;
      user-drag: none;
    }

    .preview-markdown > :first-child {
      margin-top: 0;
    }

    .preview-markdown > :last-child {
      margin-bottom: 0;
    }

    .preview-markdown h1,
    .preview-markdown h2,
    .preview-markdown h3,
    .preview-markdown h4,
    .preview-markdown h5,
    .preview-markdown h6 {
      color: var(--text-strong);
      margin: 14px 0 8px;
      line-height: 1.3;
    }

    .preview-markdown p,
    .preview-markdown ul,
    .preview-markdown ol,
    .preview-markdown blockquote,
    .preview-markdown pre,
    .preview-markdown table {
      margin: 10px 0;
    }

    .preview-markdown a {
      color: var(--accent-300);
    }

    .preview-markdown code {
      font-family: "SF Mono", "Menlo", "Consolas", monospace;
      font-size: 12px;
      background: rgba(82, 100, 132, 0.35);
      border-radius: 4px;
      padding: 1px 5px;
    }

    .preview-markdown pre {
      overflow: auto;
      border: 1px solid var(--surface-border-strong);
      border-radius: 7px;
      background: var(--surface-940);
      padding: 10px;
    }

    .preview-markdown pre code {
      background: transparent;
      padding: 0;
    }

    .preview-markdown blockquote {
      border-left: 3px solid var(--accent-450);
      margin-left: 0;
      padding: 0 0 0 10px;
      color: var(--accent-200);
    }

    .preview-markdown table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .preview-markdown th,
    .preview-markdown td {
      border: 1px solid var(--surface-border-strong);
      padding: 6px 8px;
      text-align: left;
      vertical-align: top;
    }

    .preview-zip-explorer {
      display: flex;
      gap: 10px;
      flex: 1;
      min-height: 0;
      min-width: 0;
      width: 100%;
      padding: 12px;
      box-sizing: border-box;
    }

    .preview-zip-columns {
      min-width: 0;
      display: flex;
      overflow: visible;
      border: 1px solid var(--surface-border-strong);
      background: linear-gradient(180deg, var(--surface-940) 0%, var(--surface-980) 100%);
    }

    .preview-zip-columns .finder-column {
      width: 280px;
      min-width: 240px;
      background: var(--surface-960);
    }

    .preview-zip-columns .column-body {
      padding: 0;
    }

    .preview-zip-row {
      justify-content: flex-start;
    }

    .preview-zip-row-name {
      flex: 1;
    }

    .preview-zip-row-size {
      color: var(--text-muted);
      font-size: 10px;
      margin-left: auto;
    }

    .preview-zip-detail {
      flex: 0 0 clamp(260px, 34%, 460px);
      min-width: 220px;
      max-width: 52%;
      border: 1px solid var(--surface-border-strong);
      border-radius: 10px;
      background: linear-gradient(180deg, var(--surface-940) 0%, var(--surface-980) 100%);
      overflow: auto;
      padding: 10px;
    }

    .preview-pane.is-zip-preview {
      width: auto;
    }

    .preview-pane.is-zip-preview .preview-body {
      padding: 0;
      overflow: hidden;
      display: flex;
      min-height: 0;
    }

    .preview-zip-empty {
      color: var(--text-muted);
      font-size: 12px;
    }

    .preview-zip-loading {
      color: var(--text-muted);
      font-size: 12px;
    }

    .preview-pdf {
      width: 100%;
      min-height: 520px;
      height: calc(100vh - 180px);
      border: 1px solid var(--surface-border-strong);
      border-radius: 8px;
      background: var(--surface-980);
    }

    .preview-loading {
      color: var(--text-muted);
      font-size: 12px;
      margin-bottom: 8px;
    }

    .preview-model {
      width: 100%;
      min-height: 520px;
      height: calc(100vh - 180px);
      border: 1px solid var(--surface-border-strong);
      border-radius: 8px;
      background: radial-gradient(circle at 30% 20%, var(--surface-900) 0%, var(--surface-980) 100%);
    }

    .preview-video {
      width: 100%;
      min-height: 520px;
      height: calc(100vh - 180px);
      border: 1px solid var(--surface-border-strong);
      border-radius: 8px;
      background: var(--surface-980);
    }

    .preview-note {
      margin-top: 10px;
      color: var(--text-muted);
      font-size: 11px;
    }

    .column-header {
      padding: 8px 12px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      border-bottom: 1px solid var(--surface-border);
      background: var(--surface-960);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .column-title {
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .column-sort-button {
      height: 20px;
      border-radius: 6px;
      border: 1px solid var(--surface-border-strong);
      background: var(--surface-900);
      color: var(--text-muted);
      font-size: 10px;
      letter-spacing: 0.03em;
      text-transform: none;
      padding: 0 7px;
      cursor: default;
      flex-shrink: 0;
    }

    .column-root-button {
      height: 20px;
      border-radius: 6px;
      border: 1px solid var(--surface-border-strong);
      background: var(--surface-900);
      color: var(--text-muted);
      font-size: 10px;
      letter-spacing: 0.03em;
      text-transform: none;
      padding: 0 7px;
      cursor: default;
      flex-shrink: 0;
    }

    .column-root-button.is-active {
      border-color: var(--accent-border-strong);
      background: var(--accent-600);
      color: var(--accent-100);
    }

    .column-body {
      flex: 1;
      overflow-y: auto;
      padding: 6px 0;
      overflow-anchor: none;
    }

    .finder-row {
      width: 100%;
      appearance: none;
      background: transparent;
      border: 1px solid transparent;
      text-align: left;
      cursor: default;
      display: flex;
      align-items: center;
      gap: 10px;
      min-height: 30px;
      padding: 0 12px;
      white-space: nowrap;
    }

    .finder-row:focus-visible {
      outline: 1px solid var(--accent-focus);
      outline-offset: -1px;
    }

    .finder-row.is-selected {
      background: var(--selection-idle-bg);
      border-color: var(--selection-idle-border);
      border-left-width: 2px;
      color: var(--selection-idle-text);
    }

    .finder-row.is-drop-target {
      background: var(--accent-overlay);
      border-color: var(--accent-border);
      border-left-width: 2px;
      color: var(--accent-100);
    }

    .finder-column.is-active .finder-row.is-selected {
      background: var(--accent-600);
      border-color: var(--accent-500);
      color: var(--accent-050);
    }

    .row-icon {
      width: 16px;
      font-size: 15px;
      color: #aab3c4;
      text-align: center;
      flex-shrink: 0;
    }

    .finder-row.is-selected .row-icon {
      color: #d3d9e5;
    }

    .finder-column.is-active .finder-row.is-selected .row-icon {
      color: var(--accent-175);
    }

    .row-name {
      flex: 1;
      min-width: 0;
      color: #d4dbe8;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .row-name.is-file {
      color: #b8c0ce;
    }

    .row-disclosure {
      margin-left: auto;
      width: 14px;
      font-size: 13px;
      color: #8993a6;
      text-align: center;
      flex-shrink: 0;
    }

    .finder-row.is-selected .row-disclosure {
      color: #c9d0dd;
    }

    .finder-column.is-active .finder-row.is-selected .row-disclosure {
      color: #dce9ff;
    }

    .drop-hint {
      position: fixed;
      z-index: 1000;
      min-width: 220px;
      border: 1px solid #4a556f;
      border-radius: 8px;
      padding: 8px 10px;
      background: rgba(24, 30, 41, 0.98);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      color: #d9e2f4;
      font-size: 12px;
      pointer-events: none;
    }

    .drop-hint-title {
      color: var(--accent-075);
      font-weight: 600;
    }

    .drop-hint-subtitle {
      margin-top: 2px;
      color: #9fb0cf;
      font-size: 11px;
    }

    .drop-hint[hidden] {
      display: none;
    }

    .files-modal[hidden] {
      display: none;
    }

    .files-modal {
      position: fixed;
      inset: 0;
      z-index: 1200;
      background: rgba(8, 11, 18, 0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .files-modal-card {
      width: min(440px, 92vw);
      background: var(--surface-920);
      border: 1px solid var(--surface-border-strong);
      border-radius: 10px;
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.45);
      color: var(--text-strong);
      padding: 14px;
    }

    .files-modal-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--accent-050);
    }

    .files-modal-message {
      margin-top: 8px;
      font-size: 12px;
      color: var(--text-muted);
      white-space: pre-wrap;
      word-break: break-word;
    }

    .files-modal-input {
      margin-top: 10px;
      width: 100%;
      height: 30px;
      border-radius: 7px;
      border: 1px solid var(--surface-border-strong);
      background: var(--surface-980);
      color: var(--text-strong);
      font: inherit;
      font-size: 12px;
      padding: 0 10px;
      box-sizing: border-box;
    }

    .files-modal-actions {
      margin-top: 12px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .files-modal-button {
      min-width: 84px;
      height: 28px;
      border-radius: 7px;
      border: 1px solid var(--surface-border-strong);
      background: var(--surface-900);
      color: var(--text-muted);
      font: inherit;
      font-size: 12px;
      cursor: default;
    }

    .files-modal-button.is-danger {
      border-color: #85454b;
      background: #6f3037;
      color: #ffe4e7;
    }

    .files-modal-button.is-primary {
      border-color: var(--accent-500);
      background: var(--accent-600);
      color: var(--accent-050);
    }

    .theme-settings-card {
      width: min(440px, 92vw);
    }

    .theme-settings-row {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .theme-settings-row-label {
      width: 84px;
      color: var(--text-muted);
      font-size: 11px;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      flex-shrink: 0;
    }

    .theme-settings-color {
      width: 46px;
      height: 32px;
      border-radius: 7px;
      border: 1px solid var(--surface-border-strong);
      background: var(--surface-980);
      padding: 2px;
      box-sizing: border-box;
      cursor: default;
      flex-shrink: 0;
    }

    .theme-settings-hex {
      margin-top: 0;
      font-family: "SF Mono", "Menlo", "Consolas", monospace;
      letter-spacing: 0.01em;
      text-transform: uppercase;
    }

    .theme-settings-preview {
      margin-top: 10px;
      height: 34px;
      border-radius: 8px;
      border: 1px solid var(--accent-border);
      background: linear-gradient(180deg, var(--accent-525) 0%, var(--accent-550) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent-050);
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    .theme-settings-depth {
      margin-top: 10px;
      display: grid;
      grid-template-columns: 80px 1fr auto;
      align-items: center;
      gap: 10px;
    }

    .theme-settings-depth-label {
      color: var(--text-muted);
      font-size: 11px;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }

    .theme-settings-depth-range {
      width: 100%;
      accent-color: var(--accent-500);
    }

    .theme-settings-depth-value {
      min-width: 36px;
      text-align: right;
      color: var(--text-strong);
      font-family: "SF Mono", "Menlo", "Consolas", monospace;
      font-size: 11px;
    }

    .goto-modal {
      position: fixed;
      inset: 0;
      background: rgba(9, 12, 18, 0.52);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 92px;
      z-index: 1500;
    }

    .goto-modal[hidden] {
      display: none !important;
    }

    .goto-modal-card {
      width: min(760px, calc(100vw - 40px));
      border-radius: 11px;
      border: 1px solid #4b5670;
      background: linear-gradient(180deg, #353d4e 0%, #2b3242 100%);
      box-shadow: 0 18px 48px rgba(0, 0, 0, 0.42);
      padding: 12px;
    }

    .goto-modal-title {
      color: #e9eefb;
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .goto-modal-input {
      width: 100%;
      height: 34px;
      border-radius: 7px;
      border: 1px solid #4f5a74;
      background: #1d2432;
      color: #e6edfd;
      font: inherit;
      font-size: 13px;
      padding: 0 10px;
      box-sizing: border-box;
      outline: none;
    }

    .goto-modal-suggestions {
      margin-top: 6px;
      border: 1px solid #3f4960;
      border-radius: 7px;
      background: rgba(21, 26, 36, 0.92);
      max-height: 190px;
      overflow-y: auto;
      padding: 4px;
    }

    .goto-modal-suggestions[hidden] {
      display: none !important;
    }

    .goto-suggestion-item {
      width: 100%;
      min-height: 30px;
      border: 1px solid transparent;
      border-radius: 6px;
      background: transparent;
      color: #d8e0ee;
      font: inherit;
      font-size: 12px;
      text-align: left;
      padding: 0 8px;
      cursor: default;
    }

    .goto-suggestion-item.is-active {
      border-color: var(--accent-500);
      background: var(--accent-600);
      color: var(--accent-050);
    }

    .goto-modal-error {
      min-height: 18px;
      margin-top: 6px;
      color: #ffb7bf;
      font-size: 12px;
    }

    .goto-modal-actions {
      margin-top: 8px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .goto-modal-button {
      min-width: 88px;
      height: 28px;
      border-radius: 7px;
      border: 1px solid #53607b;
      background: #3c465c;
      color: var(--accent-075);
      font: inherit;
      font-size: 12px;
      cursor: default;
    }

    .command-modal {
      position: fixed;
      inset: 0;
      z-index: 1510;
      background: var(--surface-overlay);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 64px;
    }

    .command-modal[hidden] {
      display: none !important;
    }

    .command-modal-panel {
      width: min(780px, calc(100vw - 36px));
      max-height: min(70vh, 620px);
      border: 1px solid var(--surface-border-strong);
      border-radius: 10px;
      overflow: hidden;
      background: linear-gradient(180deg, var(--surface-920) 0%, var(--surface-960) 100%);
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
      display: flex;
      flex-direction: column;
    }

    .command-modal-input {
      height: 42px;
      border: none;
      border-bottom: 1px solid var(--surface-border);
      outline: none;
      padding: 0 12px;
      background: var(--surface-980);
      color: var(--text-strong);
      font: inherit;
      font-size: 14px;
    }

    .command-modal-list {
      overflow-y: auto;
      min-height: 44px;
      max-height: min(58vh, 520px);
      padding: 4px;
      background: var(--surface-940);
    }

    .command-modal-empty {
      padding: 10px 12px;
      color: var(--text-muted);
      font-size: 12px;
    }

    .command-item {
      width: 100%;
      min-height: 34px;
      border: 1px solid transparent;
      border-radius: 8px;
      background: transparent;
      color: var(--text-strong);
      text-align: left;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 0 10px;
      cursor: default;
    }

    .command-item.is-active {
      border-color: var(--accent-500);
      background: var(--accent-600);
      color: var(--accent-050);
    }

    .command-item-label {
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .command-item-hint {
      color: var(--text-muted);
      font-size: 11px;
      flex-shrink: 0;
    }

    .command-item.is-active .command-item-hint {
      color: var(--accent-150);
    }

    .files-search {
      position: fixed;
      inset: 0;
      z-index: 1400;
      background: var(--surface-overlay);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding-top: 56px;
    }

    .files-search[hidden] {
      display: none !important;
    }

    .files-search-panel {
      width: min(1220px, calc(100vw - 36px));
      max-height: calc(100vh - 110px);
      border: 1px solid var(--surface-border-strong);
      border-radius: 11px;
      overflow: hidden;
      background: linear-gradient(180deg, var(--surface-920) 0%, var(--surface-960) 100%);
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
      display: flex;
      flex-direction: column;
    }

    .files-search-body {
      display: flex;
      flex: 1;
      min-height: 0;
      background: var(--surface-940);
    }

    .files-search-input-row {
      height: 42px;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 0 10px;
      background: var(--surface-980);
      border-bottom: 1px solid var(--surface-border);
    }

    .files-search-input {
      height: 42px;
      border: none;
      outline: none;
      padding: 0 2px;
      background: transparent;
      color: var(--text-strong);
      font: inherit;
      font-size: 14px;
      flex: 1;
      min-width: 0;
    }

    .files-search-inline-status {
      flex-shrink: 0;
      color: var(--text-muted);
      font-size: 11px;
      min-width: 120px;
      text-align: right;
    }

    .files-search-results {
      overflow: auto;
      min-height: 72px;
      max-height: calc(100vh - 190px);
      padding: 6px;
      width: 52%;
      min-width: 340px;
      border-right: 1px solid var(--surface-border);
      background: var(--surface-940);
    }

    .files-search-status,
    .files-search-empty {
      color: var(--text-muted);
      font-size: 12px;
      padding: 8px 10px;
    }

    .files-search-list {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .files-search-meta {
      display: none;
    }

    .files-search-preview {
      flex: 1;
      min-width: 320px;
      overflow: auto;
      background: var(--surface-960);
    }

    .search-preview-pane {
      width: 100%;
      min-width: 0;
      border-left: none;
      height: 100%;
    }

    .files-search-preview-empty {
      color: var(--text-muted);
      font-size: 12px;
      padding: 12px;
    }

    .files-search-item {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      min-height: 30px;
      border: 1px solid transparent;
      border-radius: 7px;
      background: transparent;
      color: var(--text-strong);
      text-align: left;
      padding: 4px 8px;
      font: inherit;
      cursor: default;
    }

    .files-search-item.is-active {
      background: linear-gradient(180deg, var(--accent-525) 0%, var(--accent-550) 100%);
      border-color: var(--accent-border-selected);
      color: var(--accent-100);
    }

    .files-search-item-name {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .files-search-item-path {
      margin-left: auto;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: var(--text-muted);
      font-size: 11px;
      max-width: 56%;
    }

    .files-search-item.is-active .files-search-item-path {
      color: var(--accent-200);
    }
  </style>

  <div class="tabs-bar">
    <div class="tabs-left-gutter" data-tauri-drag-region></div>
    <div class="tabs-list">
      {% for tab in tabs %}
      <div class="tab-shell {% if tab.is_active %}is-active{% endif %}" data-tab-id="{{ tab.id }}">
      <button
        class="tab-button"
        type="button"
        hx-get="command/activate_tab"
        hx-target="#main-root"
        hx-swap="outerHTML"
        hx-vals='{"tabId": {{ tab.id | json_encode }} }'
      >{{ tab.title }}</button>
      <button
        class="tab-close"
        type="button"
        hx-get="command/close_tab"
        hx-target="#main-root"
        hx-swap="outerHTML"
        hx-vals='{"tabId": {{ tab.id | json_encode }} }'
      >x</button>
      </div>
      {% endfor %}
      <button
        class="tab-button tab-plus"
        type="button"
        hx-get="command/new_tab"
        hx-target="#main-root"
        hx-swap="outerHTML"
        hx-vals='{"path": {{ active_path | json_encode }} }'
      >+</button>
    </div>
    <div class="tabs-drag-gutter" data-tauri-drag-region></div>
  </div>

  <div class="finder-layout">
    {% for column in columns %}
      {% set column_index = loop.index0 %}
      {% include "files/_column.html" %}
    {% endfor %}

    {% if preview %}
    <aside
      class="preview-pane"
      draggable="{% if preview.kind == "glb" or preview.kind == "markdown" %}false{% else %}true{% endif %}"
      data-preview-path="{{ preview.path }}"
      data-preview-name="{{ preview.title }}"
      data-preview-icon="{{ preview.icon }}"
      data-preview-is-dir="false"
      data-preview-draggable="{% if preview.kind == "glb" or preview.kind == "markdown" %}false{% else %}true{% endif %}"
    >
      <div class="preview-header">
        <div class="preview-title">{{ preview.title }}</div>
        <div class="preview-subtitle">{{ preview.subtitle }}</div>
      </div>
      <div class="preview-body">
        {% if preview.kind == "image" and preview.image_data_url %}
          <img class="preview-image" src="{{ preview.image_data_url }}" alt="{{ preview.title }}">
        {% elif (preview.kind == "affinity" or preview.kind == "blend") and preview.affinity_image_data_urls %}
          {% if preview.affinity_image_data_urls | length == 1 and preview.image_data_url %}
            <img class="preview-image" src="{{ preview.image_data_url }}" alt="{{ preview.title }}">
          {% else %}
            <div class="preview-gallery">
              {% for image_data_url in preview.affinity_image_data_urls %}
                <div class="preview-gallery-item">
                  <img src="{{ image_data_url }}" alt="{{ preview.title }} thumbnail {{ loop.index }}">
                </div>
              {% endfor %}
            </div>
          {% endif %}
        {% elif preview.kind == "pdf" and preview.pdf_path %}
          <div class="preview-loading" id="preview-pdf-status">Loading PDF preview...</div>
          <iframe class="preview-pdf" data-pdf-path="{{ preview.pdf_path }}" title="{{ preview.title }}" hidden></iframe>
        {% elif preview.kind == "glb" and preview.glb_path %}
          <div class="preview-loading" id="preview-glb-status">Loading 3D preview...</div>
          <model-viewer
            class="preview-model"
            data-glb-path="{{ preview.glb_path }}"
            camera-controls
            touch-action="pan-y"
            interaction-prompt="none"
            shadow-intensity="1"
            exposure="1"
            hidden
          ></model-viewer>
        {% elif preview.kind == "video" and preview.video_path %}
          <div class="preview-loading" id="preview-video-status">Loading video preview...</div>
          <video class="preview-video" data-video-path="{{ preview.video_path }}" controls preload="metadata" hidden></video>
        {% elif preview.kind == "zip" and preview.zip_entries %}
          <div class="preview-zip-explorer" data-zip-path="{{ preview.path }}">
            <script type="application/json" class="zip-entries-json">{{ preview.zip_entries | json_encode | safe }}</script>
            <div class="preview-zip-columns"></div>
            <div class="preview-zip-detail">
              <div class="preview-zip-empty">Select a file to preview.</div>
            </div>
          </div>
        {% elif preview.kind == "markdown" and preview.text_head %}
          <div class="preview-markdown">{{ preview.text_head | safe }}</div>
        {% elif preview.kind == "text" and preview.text_head %}
          <pre class="preview-text">{{ preview.text_head }}</pre>
        {% endif %}
        {% if preview.note %}
          <div class="preview-note">{{ preview.note }}</div>
        {% endif %}
      </div>
    </aside>
    {% endif %}
  </div>
  <div id="drop-hint" class="drop-hint" hidden>
    <div class="drop-hint-title" id="drop-hint-title"></div>
    <div class="drop-hint-subtitle" id="drop-hint-subtitle"></div>
  </div>
  <div id="files-modal" class="files-modal" hidden>
    <div class="files-modal-card" role="dialog" aria-modal="true" aria-labelledby="files-modal-title">
      <div class="files-modal-title" id="files-modal-title"></div>
      <div class="files-modal-message" id="files-modal-message"></div>
      <input
        id="files-modal-input"
        class="files-modal-input"
        type="text"
        spellcheck="false"
        autocorrect="off"
        autocapitalize="off"
        autocomplete="off"
        hidden
      />
      <div class="files-modal-actions">
        <button id="files-modal-cancel" class="files-modal-button" type="button">Cancel</button>
        <button id="files-modal-confirm" class="files-modal-button" type="button">OK</button>
      </div>
    </div>
  </div>
  <div id="files-search" class="files-search" hidden>
    <div class="files-search-panel">
      <div class="files-search-input-row">
        <input
          id="files-search-input"
          class="files-search-input"
          type="text"
          placeholder="Search files..."
          spellcheck="false"
          autocorrect="off"
          autocapitalize="off"
          autocomplete="off"
        />
        <div id="files-search-inline-status" class="files-search-inline-status"></div>
      </div>
      <div class="files-search-body">
        <div id="files-search-results" class="files-search-results"></div>
        <div id="files-search-preview" class="files-search-preview">
          <div class="files-search-preview-empty">No preview</div>
        </div>
      </div>
    </div>
  </div>
  <div id="goto-modal" class="goto-modal" hidden>
    <div class="goto-modal-card" role="dialog" aria-modal="true" aria-labelledby="goto-modal-title">
      <div class="goto-modal-title" id="goto-modal-title">Go to location</div>
      <input
        id="goto-modal-input"
        class="goto-modal-input"
        type="text"
        placeholder="/absolute/path"
        spellcheck="false"
        autocorrect="off"
        autocapitalize="off"
        autocomplete="off"
      />
      <div id="goto-modal-suggestions" class="goto-modal-suggestions" hidden></div>
      <div id="goto-modal-error" class="goto-modal-error"></div>
      <div class="goto-modal-actions">
        <button id="goto-modal-cancel" class="goto-modal-button" type="button">Cancel</button>
        <button id="goto-modal-go" class="goto-modal-button" type="button">Go</button>
      </div>
    </div>
  </div>
  <div id="command-modal" class="command-modal" hidden>
    <div class="command-modal-panel" role="dialog" aria-modal="true" aria-labelledby="command-modal-input">
      <input
        id="command-modal-input"
        class="command-modal-input"
        type="text"
        placeholder="Type a command..."
        spellcheck="false"
        autocorrect="off"
        autocapitalize="off"
        autocomplete="off"
      />
      <div id="command-modal-list" class="command-modal-list">
        <div class="command-modal-empty">No commands.</div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const root = document.getElementById("main-root");
      if (!root) return;
      let previewPdfObjectUrl = null;
      let previewGlbObjectUrl = null;
      let previewVideoObjectUrl = null;
      const base64ToBytes = (base64) => {
        const raw = atob(base64);
        const bytes = new Uint8Array(raw.length);
        for (let i = 0; i < raw.length; i += 1) {
          bytes[i] = raw.charCodeAt(i);
        }
        return bytes;
      };
      const pdfIframe = root.querySelector(".preview-pdf[data-pdf-path]");
      if (pdfIframe) {
        const rawPath = pdfIframe.getAttribute("data-pdf-path") || "";
        const status = root.querySelector("#preview-pdf-status");
        const invoke = window.__TAURI__?.core?.invoke;
        if (rawPath && typeof invoke === "function") {
          invoke("load_pdf_preview_data", {path: rawPath})
            .then((base64) => {
              if (previewPdfObjectUrl) {
                URL.revokeObjectURL(previewPdfObjectUrl);
                previewPdfObjectUrl = null;
              }
              const bytes = base64ToBytes(base64);
              const blob = new Blob([bytes], {type: "application/pdf"});
              previewPdfObjectUrl = URL.createObjectURL(blob);
              pdfIframe.src = previewPdfObjectUrl;
              pdfIframe.hidden = false;
              if (status) status.textContent = "";
            })
            .catch((error) => {
              if (status) status.textContent = String(error || "Failed to load PDF preview.");
              pdfIframe.hidden = true;
            });
        } else if (status) {
          status.textContent = "Failed to load PDF preview.";
        }
      }
      const glbViewer = root.querySelector(".preview-model[data-glb-path]");
      if (glbViewer) {
        const rawPath = glbViewer.getAttribute("data-glb-path") || "";
        const status = root.querySelector("#preview-glb-status");
        const invoke = window.__TAURI__?.core?.invoke;
        const revealViewer = () => {
          glbViewer.hidden = false;
          if (status) status.textContent = "";
        };
        if (rawPath && typeof invoke === "function") {
          invoke("load_glb_preview_data", {path: rawPath})
            .then((payload) => {
              if (previewGlbObjectUrl) {
                URL.revokeObjectURL(previewGlbObjectUrl);
                previewGlbObjectUrl = null;
              }
              const base64 = payload?.base64 || "";
              const mimeType = payload?.mime_type || "model/gltf-binary";
              if (!base64) {
                throw new Error("Empty model preview payload.");
              }
              const bytes = base64ToBytes(base64);
              const blob = new Blob([bytes], {type: mimeType});
              previewGlbObjectUrl = URL.createObjectURL(blob);
              glbViewer.src = previewGlbObjectUrl;
              if (customElements.get("model-viewer")) {
                revealViewer();
              } else {
                customElements.whenDefined("model-viewer").then(revealViewer).catch(() => {
                  if (status) status.textContent = "3D viewer failed to initialize.";
                });
              }
            })
            .catch((error) => {
              if (status) status.textContent = String(error || "Failed to load 3D preview.");
              glbViewer.hidden = true;
            });
        } else if (status) {
          status.textContent = "Failed to load 3D preview.";
        }
      }
      const videoPlayer = root.querySelector(".preview-video[data-video-path]");
      if (videoPlayer) {
        const rawPath = videoPlayer.getAttribute("data-video-path") || "";
        const status = root.querySelector("#preview-video-status");
        const invoke = window.__TAURI__?.core?.invoke;
        if (rawPath && typeof invoke === "function") {
          invoke("load_video_preview_data", {path: rawPath})
            .then((payload) => {
              if (previewVideoObjectUrl) {
                URL.revokeObjectURL(previewVideoObjectUrl);
                previewVideoObjectUrl = null;
              }
              const base64 = payload?.base64 || "";
              const mimeType = payload?.mime_type || "video/mp4";
              if (!base64) {
                throw new Error("Empty video preview payload.");
              }
              const bytes = base64ToBytes(base64);
              const blob = new Blob([bytes], {type: mimeType});
              previewVideoObjectUrl = URL.createObjectURL(blob);
              videoPlayer.src = previewVideoObjectUrl;
              videoPlayer.hidden = false;
              if (status) status.textContent = "";
            })
            .catch((error) => {
              if (status) status.textContent = String(error || "Failed to load video preview.");
              videoPlayer.hidden = true;
            });
        } else if (status) {
          status.textContent = "Failed to load video preview.";
        }
      }
      let zipExplorerState = null;
      const zipParseEntries = (jsonElement) => {
        if (!jsonElement) return [];
        try {
          const parsed = JSON.parse(jsonElement.textContent || "[]");
          return Array.isArray(parsed) ? parsed : [];
        } catch (_error) {
          return [];
        }
      };
      const zipNormalizePath = (value) => String(value || "").replace(/^\/+/, "").replace(/\/+$/, "");
      const zipTreeFromEntries = (entries) => {
        const rootNode = {name: "", path: "", isDir: true, size: 0, icon: "folder", children: new Map()};
        for (const entry of entries) {
          const rawPath = zipNormalizePath(entry?.name || "");
          if (!rawPath) continue;
          const parts = rawPath.split("/").filter((segment) => segment.length > 0);
          if (parts.length === 0) continue;
          let currentNode = rootNode;
          let currentPath = "";
          for (let i = 0; i < parts.length; i += 1) {
            const segment = parts[i];
            currentPath = currentPath ? `${currentPath}/${segment}` : segment;
            const isLeaf = i === parts.length - 1;
            const leafIsDir = !!entry?.is_dir;
            const shouldBeDir = !isLeaf || leafIsDir;
            const existing = currentNode.children.get(segment);
            if (!existing) {
              const nextNode = {
                name: segment,
                path: currentPath,
                isDir: shouldBeDir,
                size: Number(entry?.size || 0),
                icon: shouldBeDir ? "folder" : String(entry?.icon || "file"),
                children: new Map(),
              };
              currentNode.children.set(segment, nextNode);
              currentNode = nextNode;
            } else {
              if (shouldBeDir) {
                existing.isDir = true;
                existing.icon = "folder";
              } else if (!existing.isDir) {
                existing.size = Number(entry?.size || 0);
                existing.icon = String(entry?.icon || existing.icon || "file");
              }
              currentNode = existing;
            }
          }
        }
        return rootNode;
      };
      const zipBuildLookup = (rootNode) => {
        const map = new Map();
        const stack = [rootNode];
        while (stack.length) {
          const node = stack.pop();
          map.set(node.path, node);
          for (const child of node.children.values()) {
            stack.push(child);
          }
        }
        return map;
      };
      const zipChildNodes = (zipState, dirPath) => {
        const node = zipState.nodeByPath.get(dirPath || "");
        if (!node || !node.children) return [];
        const children = Array.from(node.children.values());
        children.sort((a, b) => {
          if (a.isDir !== b.isDir) return a.isDir ? -1 : 1;
          return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
        });
        return children;
      };
      const zipNode = (zipState, path) => zipState.nodeByPath.get(path || "") || null;
      const zipRowSelector = (depth, path) =>
        `.preview-zip-row[data-zip-depth="${depth}"][data-zip-path="${CSS.escape(path)}"]`;
      const zipSetDetailEmpty = (zipState, text) => {
        if (!zipState?.detail) return;
        zipState.detail.innerHTML = "";
        const empty = document.createElement("div");
        empty.className = "preview-zip-empty";
        empty.textContent = text;
        zipState.detail.appendChild(empty);
      };
      const zipRenderEntryPreviewDetail = (zipState, payload) => {
        if (!zipState?.detail) return;
        const detail = zipState.detail;
        detail.innerHTML = "";
        const title = document.createElement("div");
        title.className = "preview-title";
        title.textContent = String(payload?.title || "ZIP entry");
        const subtitle = document.createElement("div");
        subtitle.className = "preview-subtitle";
        subtitle.textContent = String(payload?.subtitle || "");
        detail.appendChild(title);
        detail.appendChild(subtitle);

        const kind = String(payload?.kind || "");
        if (kind === "image" && payload?.image_data_url) {
          const img = document.createElement("img");
          img.className = "preview-image";
          img.alt = String(payload?.title || "ZIP image");
          img.src = String(payload.image_data_url);
          img.style.marginTop = "10px";
          detail.appendChild(img);
        } else if (kind === "text" && payload?.text_head) {
          const pre = document.createElement("pre");
          pre.className = "preview-text";
          pre.style.marginTop = "10px";
          pre.textContent = String(payload.text_head || "");
          detail.appendChild(pre);
        } else {
          const fallback = document.createElement("div");
          fallback.className = "preview-zip-empty";
          fallback.style.marginTop = "10px";
          fallback.textContent = "No inline preview.";
          detail.appendChild(fallback);
        }

        if (payload?.note) {
          const note = document.createElement("div");
          note.className = "preview-note";
          note.textContent = String(payload.note);
          detail.appendChild(note);
        }
        if (zipState?.ensureDetailVisible) {
          zipState.ensureDetailVisible();
        }
      };
      const zipLoadEntryPreview = (zipState, entryPath) => {
        if (!zipState?.detail) return;
        const invoke = window.__TAURI__?.core?.invoke;
        if (typeof invoke !== "function") {
          zipSetDetailEmpty(zipState, "ZIP entry preview is unavailable.");
          return;
        }
        zipState.detail.innerHTML = '<div class="preview-zip-loading">Loading entry preview...</div>';
        invoke("load_zip_entry_preview_data", {path: zipState.zipPath, entryName: entryPath})
          .then((payload) => zipRenderEntryPreviewDetail(zipState, payload))
          .catch((error) => zipSetDetailEmpty(zipState, String(error || "Failed to load ZIP entry preview.")));
      };
      const zipRenderColumns = (zipState) => {
        if (!zipState?.columnsContainer) return;
        const container = zipState.columnsContainer;
        container.innerHTML = "";
        let depth = 0;
        let currentDirPath = "";
        while (true) {
          const dirNode = zipNode(zipState, currentDirPath);
          if (!dirNode || !dirNode.isDir) break;
          const section = document.createElement("section");
          section.className = "finder-column preview-zip-column";
          if (depth === zipState.activeDepth) {
            section.classList.add("is-active");
          }
          section.dataset.zipDepth = String(depth);
          const header = document.createElement("header");
          header.className = "column-header";
          const headerTitle = document.createElement("span");
          headerTitle.className = "column-title";
          headerTitle.textContent = depth === 0 ? "ZIP" : String(dirNode.name || "Folder").toUpperCase();
          header.appendChild(headerTitle);
          const body = document.createElement("div");
          body.className = "column-body";

          const children = zipChildNodes(zipState, currentDirPath);
          const selectedPath = zipState.selectedByDepth[depth] || "";
          for (const child of children) {
            const row = document.createElement("button");
            row.type = "button";
            row.className = "finder-row preview-zip-row";
            if (child.path === selectedPath) {
              row.classList.add("is-selected");
            }
            row.dataset.zipDepth = String(depth);
            row.dataset.zipPath = child.path;
            row.dataset.zipDir = child.isDir ? "true" : "false";

            const icon = document.createElement("i");
            icon.className = `row-icon icon-${String(child.icon || "file")}`;
            icon.setAttribute("aria-hidden", "true");
            row.appendChild(icon);

            const name = document.createElement("span");
            name.className = `row-name preview-zip-row-name${child.isDir ? "" : " is-file"}`;
            name.textContent = child.name;
            row.appendChild(name);

            const size = document.createElement("span");
            size.className = "preview-zip-row-size";
            size.textContent = child.isDir ? "" : `${child.size} B`;
            row.appendChild(size);

            const disclosure = document.createElement("span");
            disclosure.className = "row-disclosure icon-chevron-right";
            disclosure.setAttribute("aria-hidden", "true");
            if (!child.isDir) {
              disclosure.style.visibility = "hidden";
            }
            row.appendChild(disclosure);

            body.appendChild(row);
          }
          section.appendChild(header);
          section.appendChild(body);
          container.appendChild(section);

          if (!selectedPath) break;
          const selectedNode = zipNode(zipState, selectedPath);
          if (!selectedNode || !selectedNode.isDir) break;
          currentDirPath = selectedNode.path;
          depth += 1;
        }
        if (zipState.previewPane) {
          const visibleColumns = container.querySelectorAll(".preview-zip-column").length;
          const columnsWidth = Math.max(1, visibleColumns) * 280;
          const detailWidth = 380;
          const desired = Math.max(900, columnsWidth + detailWidth + 24);
          zipState.previewPane.style.width = `${desired}px`;
          zipState.previewPane.style.minWidth = `${desired}px`;
        }
      };
      const zipSelect = (zipState, depth, path, focus = true) => {
        const node = zipNode(zipState, path);
        if (!node) return;
        zipState.selectedByDepth = zipState.selectedByDepth.slice(0, depth);
        zipState.selectedByDepth[depth] = node.path;
        zipState.activeDepth = depth;
        zipRenderColumns(zipState);
        if (node.isDir) {
          zipSetDetailEmpty(zipState, "Select a file to preview.");
        } else {
          zipLoadEntryPreview(zipState, node.path);
        }
        if (focus) {
          const row = zipState.columnsContainer.querySelector(zipRowSelector(depth, node.path));
          if (row) {
            row.focus({preventScroll: true});
            row.scrollIntoView({block: "nearest", inline: "nearest"});
          }
        }
      };
      const zipActivateFromMainSelection = (zipState) => {
        const first = zipChildNodes(zipState, "")[0] || null;
        if (!first) return false;
        zipSelect(zipState, 0, first.path, true);
        return true;
      };
      const zipHandleArrowKey = (zipState, event, currentMainRow) => {
        if (!zipState) return false;
        const hasZipSelection = Array.isArray(zipState.selectedByDepth) && zipState.selectedByDepth.length > 0;
        const focusedZipRow = document.activeElement?.closest?.(".preview-zip-row[data-zip-path]") || null;
        const clearZipSelection = () => {
          zipState.selectedByDepth = [];
          zipState.activeDepth = 0;
          zipRenderColumns(zipState);
          zipSetDetailEmpty(zipState, "Select a file to preview.");
          if (currentMainRow) {
            currentMainRow.focus({preventScroll: true});
          }
        };
        if (!focusedZipRow) {
          if (
            event.key === "ArrowRight" &&
            currentMainRow &&
            (currentMainRow.dataset.isDir || "") !== "true" &&
            (currentMainRow.dataset.path || "") === zipState.zipPath
          ) {
            return zipActivateFromMainSelection(zipState);
          }
          // While a ZIP entry is selected internally, do not allow normal file-column arrow handling.
          if (hasZipSelection) {
            if (event.key === "ArrowLeft") {
              clearZipSelection();
            }
            return true;
          }
          return false;
        }
        if (!hasZipSelection) {
          // If nothing inside ZIP is selected, defer to normal file-browser key handling.
          return false;
        }

        const depth = Number(focusedZipRow.dataset.zipDepth || Math.max(0, zipState.selectedByDepth.length - 1));
        const currentPath =
          focusedZipRow.dataset.zipPath ||
          zipState.selectedByDepth[Math.max(0, Math.min(depth, zipState.selectedByDepth.length - 1))] ||
          "";
        const siblings = Array.from(
          zipState.columnsContainer.querySelectorAll(`.preview-zip-row[data-zip-depth="${depth}"]`),
        );
        const index = siblings.findIndex((row) => (row.dataset.zipPath || "") === currentPath);
        if (event.key === "ArrowUp" && index > 0) {
          zipSelect(zipState, depth, siblings[index - 1].dataset.zipPath || "", true);
          return true;
        }
        if (event.key === "ArrowDown" && index >= 0 && index < siblings.length - 1) {
          zipSelect(zipState, depth, siblings[index + 1].dataset.zipPath || "", true);
          return true;
        }
        if (event.key === "ArrowLeft") {
          if (depth > 0) {
            const parentPath = zipState.selectedByDepth[depth - 1] || "";
            if (parentPath) {
              zipSelect(zipState, depth - 1, parentPath, true);
              return true;
            }
          }
          clearZipSelection();
          return true;
        }
        if (event.key === "ArrowRight") {
          const node = zipNode(zipState, currentPath);
          if (!node || !node.isDir) return true;
          const children = zipChildNodes(zipState, currentPath);
          if (children.length === 0) return true;
          zipSelect(zipState, depth + 1, children[0].path, true);
          return true;
        }
        // While ZIP selection is active, arrow keys are fully owned by ZIP nav.
        return true;
      };
      const initZipExplorer = (hostRoot) => {
        const explorer = hostRoot.querySelector(".preview-zip-explorer[data-zip-path]");
        if (!explorer) return null;
        const previewPane = explorer.closest(".preview-pane");
        if (previewPane) {
          previewPane.classList.add("is-zip-preview");
        }
        const zipPath = explorer.getAttribute("data-zip-path") || "";
        const columnsContainer = explorer.querySelector(".preview-zip-columns");
        const detail = explorer.querySelector(".preview-zip-detail");
        const jsonElement = explorer.querySelector(".zip-entries-json");
        if (!zipPath || !columnsContainer || !detail || !jsonElement) return null;
        const entries = zipParseEntries(jsonElement);
        const tree = zipTreeFromEntries(entries);
        const state = {
          root: explorer,
          zipPath,
          columnsContainer,
          detail,
          previewPane,
          ensureDetailVisible: null,
          tree,
          nodeByPath: zipBuildLookup(tree),
          selectedByDepth: [],
          activeDepth: 0,
        };
        zipRenderColumns(state);
        const first = zipChildNodes(state, "")[0] || null;
        if (!first) {
          zipSetDetailEmpty(state, "ZIP archive is empty.");
        } else {
          zipSetDetailEmpty(state, "Select a file to preview.");
        }
        columnsContainer.addEventListener("click", (event) => {
          const row = event.target.closest(".preview-zip-row[data-zip-path]");
          if (!row) return;
          const depth = Number(row.dataset.zipDepth || 0);
          const path = row.dataset.zipPath || "";
          zipSelect(state, depth, path, true);
        });
        return state;
      };
      const activeTabId = root.dataset.activeTabId || "default";
      const homePath = root.dataset.homePath || "";
      const rootPath = root.dataset.rootPath || "";
      const showHidden = (root.dataset.showHidden || "").toLowerCase() === "true";
      const defaultThemeBaseColor = "#444F66";
      const defaultThemeHighlightColor = "#2F86E9";
      const defaultThemeLightnessOffset = 0;
      const themeStorageKey = "lumen.theme.baseColor";
      const themeHighlightStorageKey = "lumen.theme.highlightColor";
      const themeLightnessStorageKey = "lumen.theme.lightnessOffset";
      const readStoredThemeBaseColor = () => {
        try {
          return normalizeHexColor(window.localStorage?.getItem(themeStorageKey) || "");
        } catch (_error) {
          return null;
        }
      };
      const writeStoredThemeBaseColor = (value) => {
        const normalized = normalizeHexColor(value);
        if (!normalized) return;
        try {
          window.localStorage?.setItem(themeStorageKey, normalized);
        } catch (_error) {
          // Ignore storage failures (private mode, quota, etc.).
        }
      };
      const readStoredThemeHighlightColor = () => {
        try {
          return normalizeHexColor(window.localStorage?.getItem(themeHighlightStorageKey) || "");
        } catch (_error) {
          return null;
        }
      };
      const writeStoredThemeHighlightColor = (value) => {
        const normalized = normalizeHexColor(value);
        if (!normalized) return;
        try {
          window.localStorage?.setItem(themeHighlightStorageKey, normalized);
        } catch (_error) {
          // Ignore storage failures (private mode, quota, etc.).
        }
      };
      const normalizeThemeLightnessOffset = (value) => {
        const parsed = Number(value);
        if (!Number.isFinite(parsed)) return null;
        return Math.max(-40, Math.min(40, Math.round(parsed)));
      };
      const readStoredThemeLightnessOffset = () => {
        try {
          return normalizeThemeLightnessOffset(window.localStorage?.getItem(themeLightnessStorageKey) || "");
        } catch (_error) {
          return null;
        }
      };
      const writeStoredThemeLightnessOffset = (value) => {
        const normalized = normalizeThemeLightnessOffset(value);
        if (normalized === null) return;
        try {
          window.localStorage?.setItem(themeLightnessStorageKey, String(normalized));
        } catch (_error) {
          // Ignore storage failures (private mode, quota, etc.).
        }
      };
      const clampChannel = (value) => Math.max(0, Math.min(255, Number(value) || 0));
      const hexToRgb = (value) => {
        const raw = String(value || "").trim().replace(/^#/, "");
        if (raw.length === 3 && /^[0-9a-fA-F]{3}$/.test(raw)) {
          return {
            r: parseInt(raw[0] + raw[0], 16),
            g: parseInt(raw[1] + raw[1], 16),
            b: parseInt(raw[2] + raw[2], 16),
          };
        }
        if (raw.length === 6 && /^[0-9a-fA-F]{6}$/.test(raw)) {
          return {
            r: parseInt(raw.slice(0, 2), 16),
            g: parseInt(raw.slice(2, 4), 16),
            b: parseInt(raw.slice(4, 6), 16),
          };
        }
        return null;
      };
      const rgbToHex = (rgb) => {
        const toHex = (channel) => clampChannel(channel).toString(16).padStart(2, "0").toUpperCase();
        return `#${toHex(rgb.r)}${toHex(rgb.g)}${toHex(rgb.b)}`;
      };
      const mixRgb = (a, b, amount) => ({
        r: Math.round(a.r + (b.r - a.r) * amount),
        g: Math.round(a.g + (b.g - a.g) * amount),
        b: Math.round(a.b + (b.b - a.b) * amount),
      });
      const rgbaColor = (rgb, alpha) =>
        `rgba(${clampChannel(rgb.r)}, ${clampChannel(rgb.g)}, ${clampChannel(rgb.b)}, ${alpha})`;
      const normalizeHexColor = (value) => {
        const parsed = hexToRgb(value);
        return parsed ? rgbToHex(parsed) : null;
      };
      const applyThemeAppearance = (
        baseColor,
        highlightColor = defaultThemeHighlightColor,
        _lightnessOffset = defaultThemeLightnessOffset,
      ) => {
        const normalizedBaseColor = normalizeHexColor(baseColor) || defaultThemeBaseColor;
        const normalizedHighlightColor = normalizeHexColor(highlightColor) || defaultThemeHighlightColor;
        const normalizedLightnessOffset = defaultThemeLightnessOffset;
        const base = hexToRgb(normalizedBaseColor) || {r: 47, g: 134, b: 233};
        const highlight = hexToRgb(normalizedHighlightColor) || {r: 47, g: 134, b: 233};
        const black = {r: 0, g: 0, b: 0};
        const white = {r: 255, g: 255, b: 255};
        const darkenBase = (amount) => mixRgb(base, black, amount);
        const lightenBase = (amount) => mixRgb(base, white, amount);
        const darkenHighlight = (amount) => mixRgb(highlight, black, amount);
        const lightenHighlight = (amount) => mixRgb(highlight, white, amount);
        const adjustSurfaceRgb = (rgb) => rgb;
        const toHex = (rgb) => rgbToHex(rgb);
        const toRgba = (rgb, alpha) => rgbaColor(rgb, alpha);
        const surfaceHex = (rgb) => rgbToHex(adjustSurfaceRgb(rgb));
        const surfaceRgba = (rgb, alpha) => rgbaColor(adjustSurfaceRgb(rgb), alpha);
        const themeVars = {};
        const setThemeVar = (name, cssValue) => {
          root.style.setProperty(name, cssValue);
          themeVars[name] = cssValue;
        };
        const ensureThemeStyleOverride = () => {
          const styleId = "files-theme-style-override";
          const existing = document.getElementById(styleId);
          if (existing) return existing;
          const created = document.createElement("style");
          created.id = styleId;
          document.head.appendChild(created);
          return created;
        };
        const applyThemeStyleOverride = () => {
          const styleEl = ensureThemeStyleOverride();
          const declarations = Object.entries(themeVars)
            .map(([name, cssValue]) => `${name}: ${cssValue};`)
            .join("");
          styleEl.textContent = `#main-root.files-root{${declarations}}`;
        };
        const overlayBase = darkenHighlight(0.48);
        const borderBase = lightenHighlight(0.34);
        const selectedBorderBase = lightenHighlight(0.45);
        setThemeVar("--accent-700", toHex(darkenHighlight(0.40)));
        setThemeVar("--accent-600", toHex(darkenHighlight(0.28)));
        setThemeVar("--accent-550", toHex(darkenHighlight(0.24)));
        setThemeVar("--accent-525", toHex(darkenHighlight(0.16)));
        setThemeVar("--accent-500", toHex(highlight));
        setThemeVar("--accent-450", toHex(lightenHighlight(0.12)));
        setThemeVar("--accent-400", toHex(lightenHighlight(0.24)));
        setThemeVar("--accent-300", toHex(lightenHighlight(0.35)));
        setThemeVar("--accent-250", toHex(lightenHighlight(0.48)));
        setThemeVar("--accent-200", toHex(lightenHighlight(0.56)));
        setThemeVar("--accent-175", toHex(lightenHighlight(0.62)));
        setThemeVar("--accent-150", toHex(lightenHighlight(0.58)));
        setThemeVar("--accent-100", toHex(lightenHighlight(0.70)));
        setThemeVar("--accent-075", toHex(lightenHighlight(0.78)));
        setThemeVar("--accent-050", toHex(lightenHighlight(0.86)));
        setThemeVar("--accent-focus", toHex(lightenHighlight(0.30)));
        setThemeVar("--accent-overlay-soft", toRgba(overlayBase, 0.4));
        setThemeVar("--accent-overlay", toRgba(overlayBase, 0.45));
        setThemeVar("--accent-border-soft", toRgba(borderBase, 0.6));
        setThemeVar("--accent-border", toRgba(borderBase, 0.72));
        setThemeVar("--accent-border-strong", toRgba(borderBase, 0.95));
        setThemeVar("--accent-border-selected", toRgba(selectedBorderBase, 0.85));
        const channelLuminance = (value) => {
          const normalized = clampChannel(value) / 255;
          if (normalized <= 0.03928) return normalized / 12.92;
          return ((normalized + 0.055) / 1.055) ** 2.4;
        };
        const baseLuminance =
          0.2126 * channelLuminance(base.r) +
          0.7152 * channelLuminance(base.g) +
          0.0722 * channelLuminance(base.b);
        const isLightBase = baseLuminance >= 0.58;
        let surface980;
        let surface960;
        let surface940;
        let surface920;
        let surface900;
        let surface880;
        let surfaceBorder;
        let surfaceBorderStrong;
        let surfaceOverlayBase;
        let textMuted;
        let textStrong;
        let idleSelectionBg;
        let idleSelectionBorder;
        let idleSelectionText;
        let tabBorder;
        let tabActiveBorder;
        if (isLightBase) {
          // Light background themes: keep surfaces near the picked color, with darker chrome.
          surface980 = darkenBase(0.18);
          surface960 = darkenBase(0.14);
          surface940 = darkenBase(0.10);
          surface920 = darkenBase(0.06);
          surface900 = darkenBase(0.02);
          surface880 = lightenBase(0.08);
          surfaceBorder = darkenBase(0.24);
          surfaceBorderStrong = darkenBase(0.32);
          surfaceOverlayBase = darkenBase(0.42);
          textMuted = darkenBase(0.72);
          textStrong = darkenBase(0.84);
          idleSelectionBg = darkenBase(0.24);
          idleSelectionBorder = darkenBase(0.30);
          idleSelectionText = lightenBase(0.92);
          tabBorder = darkenBase(0.12);
          tabActiveBorder = darkenBase(0.28);
        } else {
          // Dark background themes: deepen surfaces while preserving the picked hue.
          surface980 = darkenBase(0.56);
          surface960 = darkenBase(0.48);
          surface940 = darkenBase(0.40);
          surface920 = darkenBase(0.34);
          surface900 = darkenBase(0.28);
          surface880 = darkenBase(0.20);
          surfaceBorder = darkenBase(0.24);
          surfaceBorderStrong = lightenBase(0.10);
          surfaceOverlayBase = darkenBase(0.78);
          textMuted = lightenBase(0.70);
          textStrong = lightenBase(0.88);
          idleSelectionBg = lightenBase(0.15);
          idleSelectionBorder = lightenBase(0.32);
          idleSelectionText = lightenBase(0.88);
          tabBorder = darkenBase(0.34);
          tabActiveBorder = lightenBase(0.22);
        }
        const surfaceOverlay = surfaceRgba(surfaceOverlayBase, 0.45);
        setThemeVar("--surface-980", surfaceHex(surface980));
        setThemeVar("--surface-960", surfaceHex(surface960));
        setThemeVar("--surface-940", surfaceHex(surface940));
        setThemeVar("--surface-920", surfaceHex(surface920));
        setThemeVar("--surface-900", surfaceHex(surface900));
        setThemeVar("--surface-880", surfaceHex(surface880));
        setThemeVar("--surface-border", surfaceHex(surfaceBorder));
        setThemeVar("--surface-border-strong", surfaceHex(surfaceBorderStrong));
        setThemeVar("--surface-overlay", surfaceOverlay);
        setThemeVar("--text-muted", toHex(textMuted));
        setThemeVar("--text-strong", toHex(textStrong));
        setThemeVar("--selection-idle-bg", toHex(idleSelectionBg));
        setThemeVar("--selection-idle-border", toHex(idleSelectionBorder));
        setThemeVar("--selection-idle-text", toHex(idleSelectionText));
        setThemeVar("--tab-border", surfaceHex(tabBorder));
        setThemeVar("--tab-active-border", surfaceHex(tabActiveBorder));
        applyThemeStyleOverride();
        root.dataset.themeBaseColor = normalizedBaseColor;
        root.dataset.themeHighlightColor = normalizedHighlightColor;
        root.dataset.themeLightnessOffset = String(normalizedLightnessOffset);
        window.__filesThemeBaseColor = normalizedBaseColor;
        window.__filesThemeHighlightColor = normalizedHighlightColor;
        window.__filesThemeLightnessOffset = normalizedLightnessOffset;
        writeStoredThemeBaseColor(normalizedBaseColor);
        writeStoredThemeHighlightColor(normalizedHighlightColor);
        writeStoredThemeLightnessOffset(normalizedLightnessOffset);
        return {
          baseColor: normalizedBaseColor,
          highlightColor: normalizedHighlightColor,
          lightnessOffset: normalizedLightnessOffset,
        };
      };
      const themeToken = (name, fallback) =>
        (window.getComputedStyle(root).getPropertyValue(name) || "").trim() || fallback;
      const datasetThemeBaseColor = normalizeHexColor(root.dataset.themeBaseColor || "");
      const datasetThemeHighlightColor = normalizeHexColor(root.dataset.themeHighlightColor || "");
      const windowCachedThemeBaseColor = normalizeHexColor(window.__filesThemeBaseColor || "");
      const windowCachedThemeHighlightColor = normalizeHexColor(window.__filesThemeHighlightColor || "");
      const datasetThemeLightnessOffset = normalizeThemeLightnessOffset(root.dataset.themeLightnessOffset || "");
      const windowCachedThemeLightnessOffset = normalizeThemeLightnessOffset(window.__filesThemeLightnessOffset);
      const storedThemeBaseColor = readStoredThemeBaseColor();
      const storedThemeHighlightColor = readStoredThemeHighlightColor();
      const storedThemeLightnessOffset = readStoredThemeLightnessOffset();
      const initialThemeBaseColor =
        windowCachedThemeBaseColor || storedThemeBaseColor || datasetThemeBaseColor || defaultThemeBaseColor;
      const initialThemeHighlightColor =
        windowCachedThemeHighlightColor ||
        storedThemeHighlightColor ||
        datasetThemeHighlightColor ||
        defaultThemeHighlightColor;
      let currentThemeLightnessOffset =
        windowCachedThemeLightnessOffset ??
        storedThemeLightnessOffset ??
        datasetThemeLightnessOffset ??
        defaultThemeLightnessOffset;
      let currentThemeBaseColor = initialThemeBaseColor;
      let currentThemeHighlightColor = initialThemeHighlightColor;
      {
        const appliedTheme = applyThemeAppearance(
          initialThemeBaseColor,
          initialThemeHighlightColor,
          currentThemeLightnessOffset,
        );
        currentThemeBaseColor = appliedTheme.baseColor;
        currentThemeHighlightColor = appliedTheme.highlightColor;
        currentThemeLightnessOffset = appliedTheme.lightnessOffset;
      }
      let themeBaseChangedUnlisten = null;
      let themeHighlightChangedUnlisten = null;
      let themeLightnessChangedUnlisten = null;
      const settingsInvoke = window.__TAURI__?.core?.invoke;
      const tauriListen = window.__TAURI__?.event?.listen;
      if (typeof tauriListen === "function") {
        Promise.resolve(
          tauriListen("theme-base-color-changed", (event) => {
            const nextColor = String(event?.payload || "");
            const normalized = normalizeHexColor(nextColor);
            if (!normalized) return;
            const appliedTheme = applyThemeAppearance(
              normalized,
              currentThemeHighlightColor,
              currentThemeLightnessOffset,
            );
            currentThemeBaseColor = appliedTheme.baseColor;
            currentThemeHighlightColor = appliedTheme.highlightColor;
            currentThemeLightnessOffset = appliedTheme.lightnessOffset;
            syncThemeSettingsInputs(
              currentThemeBaseColor,
              currentThemeHighlightColor,
              currentThemeLightnessOffset,
            );
          }),
        )
          .then((unlisten) => {
            themeBaseChangedUnlisten = typeof unlisten === "function" ? unlisten : null;
          })
          .catch(() => {});
        Promise.resolve(
          tauriListen("theme-highlight-color-changed", (event) => {
            const nextColor = String(event?.payload || "");
            const normalized = normalizeHexColor(nextColor);
            if (!normalized) return;
            const appliedTheme = applyThemeAppearance(
              currentThemeBaseColor,
              normalized,
              currentThemeLightnessOffset,
            );
            currentThemeBaseColor = appliedTheme.baseColor;
            currentThemeHighlightColor = appliedTheme.highlightColor;
            currentThemeLightnessOffset = appliedTheme.lightnessOffset;
            syncThemeSettingsInputs(
              currentThemeBaseColor,
              currentThemeHighlightColor,
              currentThemeLightnessOffset,
            );
          }),
        )
          .then((unlisten) => {
            themeHighlightChangedUnlisten = typeof unlisten === "function" ? unlisten : null;
          })
          .catch(() => {});
        Promise.resolve(
          tauriListen("theme-lightness-offset-changed", (event) => {
            const normalizedOffset = normalizeThemeLightnessOffset(event?.payload);
            if (normalizedOffset === null) return;
            const appliedTheme = applyThemeAppearance(
              currentThemeBaseColor,
              currentThemeHighlightColor,
              normalizedOffset,
            );
            currentThemeBaseColor = appliedTheme.baseColor;
            currentThemeHighlightColor = appliedTheme.highlightColor;
            currentThemeLightnessOffset = appliedTheme.lightnessOffset;
            syncThemeSettingsInputs(
              currentThemeBaseColor,
              currentThemeHighlightColor,
              currentThemeLightnessOffset,
            );
          }),
        )
          .then((unlisten) => {
            themeLightnessChangedUnlisten = typeof unlisten === "function" ? unlisten : null;
          })
          .catch(() => {});
      }
      const getCurrentWindowHandle = window.__TAURI__?.window?.getCurrentWindow;
      const isMacOS = /\bMac\b/i.test(navigator.platform || "") || /\bMac OS X\b/i.test(navigator.userAgent || "");
      if (isMacOS && window.htmx?.config) {
        window.htmx.config.ignoreTitle = true;
      }
      window.__filesWindowTitleByTab = window.__filesWindowTitleByTab || {};
      let lastAppliedWindowTitle = window.__filesWindowTitleByTab[activeTabId] || "";
      const setLastAppliedWindowTitle = (title) => {
        lastAppliedWindowTitle = title;
        window.__filesWindowTitleByTab[activeTabId] = title;
      };
      const displayWindowPath = (rawPath) => {
        const value = String(rawPath || "").trim() || "/";
        if (!homePath || homePath === "/") return value;
        if (value === homePath) return "~/";
        const prefix = `${homePath}/`;
        if (value.startsWith(prefix)) {
          return `~/${value.slice(prefix.length)}`;
        }
        return value;
      };
      const applyWindowTitle = (value, reason = "unknown") => {
        const title = displayWindowPath(value || rootPath || "/");
        logNav("applyWindowTitle", {
          reason,
          rawValue: String(value || ""),
          nextTitle: title,
          previousTitle: lastAppliedWindowTitle,
          skipped: !title || title === lastAppliedWindowTitle,
        });
        if (!title || title === lastAppliedWindowTitle) return;
        setLastAppliedWindowTitle(title);
        if (isMacOS) {
          const titleInvoke = window.__TAURI__?.core?.invoke;
          if (typeof titleInvoke === "function") {
            Promise.resolve(titleInvoke("set_window_title", {title})).catch((error) => {
              logNav("set_window_title failed", {title, error: String(error)});
            });
          }
          return;
        }
        document.title = title;
        if (typeof getCurrentWindowHandle === "function") {
          const currentWindow = getCurrentWindowHandle();
          if (currentWindow && typeof currentWindow.setTitle === "function") {
            Promise.resolve(currentWindow.setTitle(title)).catch(() => {
              document.title = title;
            });
            return;
          }
        }
      };
      const DEBUG_NAV = true;
      const DEBUG_SCROLL = true;
      const logNav = (...args) => {
        if (!DEBUG_NAV) return;
        console.debug("[files-nav]", ...args);
      };
      const logScroll = (...args) => {
        if (!DEBUG_SCROLL) return;
        console.debug("[files-scroll]", ...args);
      };
      window.__filesFocusPathByTab = window.__filesFocusPathByTab || {};
      const getFocusPath = () => window.__filesFocusPathByTab[activeTabId] || null;
      const setFocusPath = (path) => {
        logNav("setFocusPath", {activeTabId, path});
        window.__filesFocusPathByTab[activeTabId] = path;
      };

      const rows = Array.from(root.querySelectorAll(".finder-layout > .finder-column .finder-row"));
      if (rows.length === 0) {
        applyWindowTitle(rootPath, "init-no-rows");
        return;
      }
      let dragInProgress = false;
      const columns = Array.from(root.querySelectorAll(".finder-layout > .finder-column"));
      const currentDirectoryTitle = () => {
        const activeColumn = columns.find((column) => column.classList.contains("is-active")) || columns.at(-1);
        return activeColumn?.dataset?.path || rootPath || "/";
      };
      const isMainRow = (row) => !!row && rows.includes(row);
      const isMainColumn = (column) => !!column && columns.includes(column);
      const mainRowFromEvent = (event) => {
        const row = event.target.closest(".finder-row");
        return isMainRow(row) ? row : null;
      };
      const mainColumnBodies = () =>
        columns
          .map((column) => column.querySelector(".column-body"))
          .filter((body) => !!body);
      const layout = root.querySelector(".finder-layout");
      zipExplorerState = initZipExplorer(root);
      if (zipExplorerState && layout) {
        zipExplorerState.ensureDetailVisible = () => {
          const detail = zipExplorerState?.detail;
          if (!detail) return;
          const layoutRect = layout.getBoundingClientRect();
          const detailRect = detail.getBoundingClientRect();
          const margin = 8;
          if (detailRect.right > layoutRect.right - margin) {
            layout.scrollLeft += detailRect.right - (layoutRect.right - margin);
          } else if (detailRect.left < layoutRect.left + margin) {
            layout.scrollLeft -= (layoutRect.left + margin) - detailRect.left;
          }
        };
      }
      const previewPane = layout?.querySelector(".preview-pane") || null;
      const dropHint = root.querySelector("#drop-hint");
      const dropHintTitle = root.querySelector("#drop-hint-title");
      const dropHintSubtitle = root.querySelector("#drop-hint-subtitle");
      const modalRoot = root.querySelector("#files-modal");
      const modalTitle = root.querySelector("#files-modal-title");
      const modalMessage = root.querySelector("#files-modal-message");
      const modalInput = root.querySelector("#files-modal-input");
      const modalCancel = root.querySelector("#files-modal-cancel");
      const modalConfirm = root.querySelector("#files-modal-confirm");
      const searchRoot = root.querySelector("#files-search");
      const searchInput = root.querySelector("#files-search-input");
      const searchResults = root.querySelector("#files-search-results");
      const searchPreview = root.querySelector("#files-search-preview");
      const searchInlineStatus = root.querySelector("#files-search-inline-status");
      const gotoModal = root.querySelector("#goto-modal");
      const gotoInput = root.querySelector("#goto-modal-input");
      const gotoSuggestions = root.querySelector("#goto-modal-suggestions");
      const gotoError = root.querySelector("#goto-modal-error");
      const gotoCancel = root.querySelector("#goto-modal-cancel");
      const gotoGo = root.querySelector("#goto-modal-go");
      const commandModal = root.querySelector("#command-modal");
      const commandInput = root.querySelector("#command-modal-input");
      const commandList = root.querySelector("#command-modal-list");
      const themeSettingsModal = root.querySelector("#theme-settings-modal");
      const themeSettingsColor = root.querySelector("#theme-settings-color");
      const themeSettingsHex = root.querySelector("#theme-settings-hex");
      const themeSettingsHighlightColor = root.querySelector("#theme-settings-highlight-color");
      const themeSettingsHighlightHex = root.querySelector("#theme-settings-highlight-hex");
      const themeSettingsDepthRange = root.querySelector("#theme-settings-depth-range");
      const themeSettingsDepthValue = root.querySelector("#theme-settings-depth-value");
      const themeSettingsPreview = root.querySelector("#theme-settings-preview");
      const themeSettingsReset = root.querySelector("#theme-settings-reset");
      const themeSettingsCancel = root.querySelector("#theme-settings-cancel");
      const themeSettingsSave = root.querySelector("#theme-settings-save");
      let dropTargetColumn = null;
      let dropTargetRow = null;
      let externalDragPaths = [];
      let externalDragPoint = null;
      let domDragPoint = null;
      let tauriPayloadYOffset = null;
      let dragDropUnlisten = null;
      let optionPressed = false;
      let modalResolve = null;
      let searchPollTimer = null;
      let searchDebounceTimer = null;
      let searchSelectedIndex = 0;
      let searchSelectedPath = null;
      let searchUserPicked = false;
      let searchPreviewPath = null;
      let directorySyncTimer = null;
      let directorySyncInFlight = false;
      let commandItems = [];
      let commandSelectionIndex = 0;
      let commandModalIgnoreBackdropUntil = 0;
      let commandModalIgnoreInteractionsUntil = 0;
      let themeSettingsOriginalColor = currentThemeBaseColor;
      let themeSettingsOriginalHighlightColor = currentThemeHighlightColor;
      let themeSettingsOriginalLightnessOffset = currentThemeLightnessOffset;
      let gotoSuggestDebounceTimer = null;
      let gotoSuggestGeneration = 0;
      let gotoSuggestionIndex = -1;
      const commandCapabilitiesByPath = new Map();
      const searchPreviewObjectUrls = [];
      let lastSearchResultsHtml = "";
      window.__filesScrollStateByTab = window.__filesScrollStateByTab || {};
      window.__filesDirectorySignatureByTab = window.__filesDirectorySignatureByTab || {};
      window.__filesDirectoryPathKeyByTab = window.__filesDirectoryPathKeyByTab || {};
      const getScrollState = () => window.__filesScrollStateByTab[activeTabId] || null;
      const getDirectorySignature = () => window.__filesDirectorySignatureByTab[activeTabId] || null;
      const getDirectoryPathKey = () => window.__filesDirectoryPathKeyByTab[activeTabId] || null;
      const setDirectorySignature = (signature) => {
        window.__filesDirectorySignatureByTab[activeTabId] = signature;
      };
      const setDirectoryPathKey = (pathKey) => {
        window.__filesDirectoryPathKeyByTab[activeTabId] = pathKey;
      };
      const saveScrollState = () => {
        const state = {
          layoutLeft: layout?.scrollLeft || 0,
          columnTops: {},
        };
        for (const body of mainColumnBodies()) {
          const column = body.closest(".finder-column");
          const columnIndex = Number(column?.dataset?.column || 0);
          state.columnTops[columnIndex] = body.scrollTop;
        }
        window.__filesScrollStateByTab[activeTabId] = state;
        logScroll("saveScrollState", state);
      };
      const restoreScrollState = () => {
        const state = getScrollState();
        if (!state) return;
        if (layout && Number.isFinite(state.layoutLeft)) {
          layout.scrollLeft = state.layoutLeft;
        }
        for (const body of mainColumnBodies()) {
          const column = body.closest(".finder-column");
          const columnIndex = Number(column?.dataset?.column || 0);
          const top = state.columnTops?.[columnIndex];
          if (Number.isFinite(top)) {
            body.scrollTop = top;
          }
        }
        logScroll("restoreScrollState", state);
      };
      logNav("init", {
        activeTabId,
        rows: rows.length,
        columns: columns.length,
        rememberedFocus: getFocusPath(),
        pendingRightFromPath: window.__filesPendingRightFromPath || null,
      });

      window.__filesSelectionAnchorByTab = window.__filesSelectionAnchorByTab || {};
      window.__filesPendingContextSelectionByTab = window.__filesPendingContextSelectionByTab || {};
      const rowsByColumn = new Map();

      for (const row of rows) {
        const column = Number(row.dataset.column || 0);
        if (!rowsByColumn.has(column)) rowsByColumn.set(column, []);
        rowsByColumn.get(column).push(row);
      }

      const selectedRows = () => rows.filter((row) => row.classList.contains("is-selected"));
      const selectedRowsInColumn = (columnIndex) =>
        selectedRows().filter((row) => Number(row.dataset.column || 0) === Number(columnIndex || 0));
      const selectedPaths = () => selectedRows().map((row) => row.dataset.path || "").filter((value) => !!value);
      const selectedPathsInColumn = (columnIndex) =>
        selectedRowsInColumn(columnIndex)
          .map((row) => row.dataset.path || "")
          .filter((value) => !!value);
      const rowByPath = (path) => rows.find((row) => row.dataset.path === path) || null;
      const setSelectionAnchorPath = (path) => {
        if (!path) {
          delete window.__filesSelectionAnchorByTab[activeTabId];
          return;
        }
        window.__filesSelectionAnchorByTab[activeTabId] = path;
      };
      const getSelectionAnchorPath = () => window.__filesSelectionAnchorByTab[activeTabId] || null;
      const setPendingContextSelectionPaths = (paths) => {
        const normalized = Array.from(
          new Set((Array.isArray(paths) ? paths : []).map((value) => String(value || "")).filter((value) => !!value)),
        );
        if (normalized.length === 0) {
          delete window.__filesPendingContextSelectionByTab[activeTabId];
          return;
        }
        window.__filesPendingContextSelectionByTab[activeTabId] = normalized;
      };
      const consumePendingContextSelectionPaths = () => {
        const paths = Array.isArray(window.__filesPendingContextSelectionByTab[activeTabId])
          ? window.__filesPendingContextSelectionByTab[activeTabId]
          : [];
        delete window.__filesPendingContextSelectionByTab[activeTabId];
        return paths;
      };
      const rightmostSelected = () =>
        [...selectedRows()].sort((a, b) => Number(a.dataset.column) - Number(b.dataset.column)).at(-1);
      const selectedInColumn = (columnIndex) =>
        selectedRows().find((row) => Number(row.dataset.column) === columnIndex) || null;
      const focusedRow = () =>
        (root.contains(document.activeElement) &&
        document.activeElement.classList.contains("finder-row") &&
        isMainRow(document.activeElement)
          ? document.activeElement
          : null) ||
        rows.find((row) => row.dataset.path === getFocusPath()) ||
        rightmostSelected() ||
        null;
      const rightmostSelectedDirectory = () =>
        [...selectedRows()]
          .filter((row) => (row.dataset.isDir || "") === "true")
          .sort((a, b) => Number(a.dataset.column) - Number(b.dataset.column))
          .at(-1) || null;
      const selectedDirectoryPath = () => {
        const focused = focusedRow();
        if ((focused?.dataset?.isDir || "") === "true") {
          return focused.dataset.path || "";
        }
        return rightmostSelectedDirectory()?.dataset?.path || "";
      };
      const toRelativePath = (path) => {
        const value = String(path || "");
        if (!value) return "";
        if (!rootPath || rootPath === "/") {
          return value.startsWith("/") ? value.slice(1) || "/" : value;
        }
        if (value === rootPath) return ".";
        const prefix = `${rootPath}/`;
        if (value.startsWith(prefix)) return value.slice(prefix.length);
        return value;
      };

      const setActiveColumn = (columnIndex) => {
        for (const column of columns) {
          column.classList.toggle("is-active", Number(column.dataset.column) === columnIndex);
        }
        applyWindowTitle(currentDirectoryTitle(), "setActiveColumn");
      };
      const ensureColumnAndNextVisible = (columnIndex) => {
        if (!layout) return;
        const currentColumn = columns.find((column) => Number(column.dataset.column || 0) === columnIndex);
        if (!currentColumn) return;
        const nextColumn = columns.find((column) => Number(column.dataset.column || 0) === columnIndex + 1);
        const preferredTargetColumn = nextColumn || previewPane || currentColumn;
        const currentLeft = currentColumn.offsetLeft;
        const margin = 8;
        const preferredTargetRight = preferredTargetColumn.offsetLeft + preferredTargetColumn.offsetWidth;
        const requiredWidthToShowBoth = preferredTargetRight - currentLeft + margin * 2;
        const canShowCurrentAndTarget = layout.clientWidth >= requiredWidthToShowBoth;
        const targetColumn = canShowCurrentAndTarget ? preferredTargetColumn : currentColumn;
        const targetRight = targetColumn.offsetLeft + targetColumn.offsetWidth;
        const viewportLeft = layout.scrollLeft;
        let desiredLeft = viewportLeft;

        if (currentLeft < viewportLeft + margin) {
          desiredLeft = currentLeft - margin;
        }
        if (targetRight > desiredLeft + layout.clientWidth - margin) {
          desiredLeft = targetRight - layout.clientWidth + margin;
        }

        const maxLeft = Math.max(0, layout.scrollWidth - layout.clientWidth);
        desiredLeft = Math.max(0, Math.min(maxLeft, desiredLeft));
        if (desiredLeft !== layout.scrollLeft) {
          layout.scrollLeft = desiredLeft;
        }
      };
      const ensureRowVisible = (row) => {
        if (!row) return;
        const body = row.closest(".column-body");
        if (!body) return;
        const viewTop = body.scrollTop;
        const viewBottom = viewTop + body.clientHeight;
        const rowTop = row.offsetTop;
        const rowBottom = rowTop + row.offsetHeight;
        const bodyRect = body.getBoundingClientRect();
        const rowRect = row.getBoundingClientRect();
        const topInset = 2;
        const bottomInset = 2;
        const isVisibleByRect =
          rowRect.top >= bodyRect.top + topInset && rowRect.bottom <= bodyRect.bottom - bottomInset;

        // If the row is already fully visible, never touch scroll.
        if (isVisibleByRect) {
          logScroll("ensureRowVisible noop-visible", {
            path: row.dataset.path,
            rowTop,
            rowBottom,
            viewTop,
            viewBottom,
            rowRectTop: rowRect.top,
            rowRectBottom: rowRect.bottom,
            bodyRectTop: bodyRect.top,
            bodyRectBottom: bodyRect.bottom,
          });
          return;
        }

        if (rowRect.top < bodyRect.top + topInset) {
          const delta = rowRect.top - (bodyRect.top + topInset);
          const next = Math.max(0, body.scrollTop + delta);
          logScroll("ensureRowVisible up", {
            path: row.dataset.path,
            from: body.scrollTop,
            to: next,
          });
          body.scrollTop = next;
        } else if (rowRect.bottom > bodyRect.bottom - bottomInset) {
          const delta = rowRect.bottom - (bodyRect.bottom - bottomInset);
          const next = Math.max(0, body.scrollTop + delta);
          logScroll("ensureRowVisible down", {
            path: row.dataset.path,
            from: body.scrollTop,
            to: next,
          });
          body.scrollTop = next;
        }
      };
      const setSelectionByPaths = (paths, options = {}) => {
        const selectedSet = new Set(
          (Array.isArray(paths) ? paths : []).map((value) => String(value || "")).filter((value) => !!value),
        );
        const scopeColumn = Number(options.scopeColumn);
        if (Number.isFinite(scopeColumn)) {
          const columnRows = rowsByColumn.get(scopeColumn) || [];
          for (const row of columnRows) {
            row.classList.toggle("is-selected", selectedSet.has(row.dataset.path || ""));
          }
        } else {
          for (const row of rows) {
            row.classList.toggle("is-selected", selectedSet.has(row.dataset.path || ""));
          }
        }
        if (options.anchorPath !== undefined) {
          setSelectionAnchorPath(options.anchorPath);
        }
      };
      const setSingleSelection = (row) => {
        if (!row) return;
        const path = row.dataset.path || "";
        if (!path) return;
        const columnIndex = Number(row.dataset.column || 0);
        setSelectionByPaths([path], {anchorPath: path, scopeColumn: columnIndex});
      };
      const toggleRowSelectedLocally = (row) => {
        if (!row) return;
        const path = row.dataset.path || "";
        if (!path) return;
        const columnIndex = Number(row.dataset.column || 0);
        const current = new Set(selectedPathsInColumn(columnIndex));
        if (current.has(path)) {
          current.delete(path);
        } else {
          current.add(path);
        }
        const next = Array.from(current);
        if (next.length === 0) {
          setSingleSelection(row);
          return;
        }
        setSelectionByPaths(next, {anchorPath: path, scopeColumn: columnIndex});
      };
      const selectRangeToRow = (targetRow, additive = false) => {
        if (!targetRow) return;
        const targetPath = targetRow.dataset.path || "";
        if (!targetPath) return;
        const targetColumn = Number(targetRow.dataset.column || 0);
        const anchorRow =
          rowByPath(getSelectionAnchorPath()) ||
          focusedRow() ||
          selectedInColumn(targetColumn) ||
          targetRow;
        const anchorColumn = Number(anchorRow?.dataset?.column || targetColumn);
        if (anchorColumn !== targetColumn) {
          setSingleSelection(targetRow);
          return;
        }
        const columnRows = rowsByColumn.get(targetColumn) || [];
        const start = columnRows.findIndex((row) => row.dataset.path === (anchorRow?.dataset?.path || ""));
        const end = columnRows.findIndex((row) => row.dataset.path === targetPath);
        if (start < 0 || end < 0) {
          setSingleSelection(targetRow);
          return;
        }
        const low = Math.min(start, end);
        const high = Math.max(start, end);
        const rangePaths = columnRows.slice(low, high + 1).map((row) => row.dataset.path || "").filter((value) => !!value);
        const nextPaths = additive
          ? Array.from(new Set([...selectedPathsInColumn(targetColumn), ...rangePaths]))
          : rangePaths;
        setSelectionByPaths(nextPaths, {
          anchorPath: anchorRow?.dataset?.path || targetPath,
          scopeColumn: targetColumn,
        });
      };
      const restoreSelectionFromMemory = () => {
        if (rowByPath(getSelectionAnchorPath())) return;
        const initial =
          rightmostSelected() ||
          rows.find((row) => row.dataset.path === getFocusPath()) ||
          rows.find((row) => row.classList.contains("is-selected")) ||
          null;
        setSelectionAnchorPath(initial?.dataset?.path || null);
      };
      const selectedPathsForContext = (path) => {
        const normalizedPath = String(path || "");
        if (!normalizedPath) return [];
        const row = rowByPath(normalizedPath);
        if (!row) return [normalizedPath];
        const selected = selectedPathsInColumn(Number(row.dataset.column || 0));
        if (selected.includes(normalizedPath)) {
          return selected;
        }
        return [normalizedPath];
      };
      const clearDropTarget = () => {
        if (dropTargetRow) {
          dropTargetRow.classList.remove("is-drop-target");
          dropTargetRow = null;
        }
        if (!dropTargetColumn) return;
        dropTargetColumn.classList.remove("is-drop-target");
        dropTargetColumn = null;
      };
      const getCurrentDropTargetDir = () => {
        if (dropTargetRow?.dataset?.path) return dropTargetRow.dataset.path;
        return dropTargetColumn?.dataset?.path || "";
      };
      const getDropOperation = () => (optionPressed ? "copy" : "move");
      const hideDropHint = () => {
        externalDragPoint = null;
        if (dropHint) {
          dropHint.hidden = true;
        }
      };
      const getClientPointFromDrop = (position) => {
        return {
          x: Number(position?.x || 0),
          y: Number(position?.y || 0),
        };
      };
      const getBestDragPoint = (position) => {
        if (domDragPoint) {
          return {
            x: Number(domDragPoint.x || 0),
            y: Number(domDragPoint.y || 0),
          };
        }
        if (tauriPayloadYOffset == null) {
          const estimatedRowHeight = Number(rows?.[0]?.getBoundingClientRect?.().height || 30);
          tauriPayloadYOffset = Math.max(0, Math.round(estimatedRowHeight));
        }
        const point = getClientPointFromDrop(position);
        return {
          x: point.x,
          y: point.y - tauriPayloadYOffset,
        };
      };
      const normalizePathForCompare = (value) => {
        if (!value) return "";
        if (value === "/") return "/";
        return value.replace(/\/+$/, "") || "/";
      };
      const parentDirectoryForPath = (value) => {
        const normalized = normalizePathForCompare(value);
        if (!normalized || normalized === "/") return "/";
        const lastSlash = normalized.lastIndexOf("/");
        if (lastSlash <= 0) return "/";
        return normalized.slice(0, lastSlash);
      };
      const hasMeaningfulDropTarget = (targetDir) => {
        const normalizedTarget = normalizePathForCompare(targetDir);
        if (!normalizedTarget || externalDragPaths.length === 0) return false;
        return externalDragPaths.some(
          (sourcePath) => parentDirectoryForPath(sourcePath) !== normalizedTarget,
        );
      };
      const findColumnAtPoint = (clientX, clientY) => {
        for (const column of columns) {
          const rect = column.getBoundingClientRect();
          if (
            clientX >= rect.left &&
            clientX <= rect.right &&
            clientY >= rect.top &&
            clientY <= rect.bottom
          ) {
            return column;
          }
        }
        return null;
      };
      const findDirectoryRowTargetAtPoint = (column, clientX, clientY) => {
        if (!column) return null;
        const hit = document.elementFromPoint(clientX, clientY);
        const row = hit?.closest?.(".finder-row") || null;
        if (!row || row.dataset.isDir !== "true") return null;
        if (row.closest(".finder-column") !== column) return null;
        const rect = row.getBoundingClientRect();
        if (clientX < rect.left + rect.width * 0.2) return null;
        return row;
      };
      const applyDropTarget = (column, rowTarget) => {
        if (!column || !column.dataset.path) {
          clearDropTarget();
          return null;
        }
        const targetDir = rowTarget?.dataset?.path || column.dataset.path;
        if (!hasMeaningfulDropTarget(targetDir)) {
          clearDropTarget();
          return null;
        }
        if (dropTargetColumn !== column || dropTargetRow !== rowTarget) {
          clearDropTarget();
          dropTargetColumn = column;
          dropTargetRow = rowTarget;
          if (dropTargetRow) {
            dropTargetRow.classList.add("is-drop-target");
          } else {
            dropTargetColumn.classList.add("is-drop-target");
          }
        }
        return {column, targetDir};
      };
      const setDropTargetByDragEvent = (event) => {
        const hit = event?.target;
        const row = hit?.closest?.(".finder-row") || null;
        const column =
          row?.closest?.(".finder-column") ||
          hit?.closest?.(".finder-column") ||
          findColumnAtPoint(Number(event?.clientX || 0), Number(event?.clientY || 0));
        if (!column) {
          clearDropTarget();
          return null;
        }
        let rowTarget = null;
        if (row && row.dataset.isDir === "true" && row.closest(".finder-column") === column) {
          const rect = row.getBoundingClientRect();
          if (Number(event?.clientX || 0) >= rect.left + rect.width * 0.2) {
            rowTarget = row;
          }
        }
        return applyDropTarget(column, rowTarget);
      };
      const setDropTargetByPoint = (clientX, clientY) => {
        const column = findColumnAtPoint(clientX, clientY);
        if (!column) return null;
        const rowTarget = findDirectoryRowTargetAtPoint(column, clientX, clientY);
        return applyDropTarget(column, rowTarget);
      };
      const updateDropHint = (clientX, clientY, targetDir) => {
        if (!dropHint || !dropHintTitle || !dropHintSubtitle) return;
        dropHint.hidden = false;
        const margin = 10;
        const hintWidth = dropHint.offsetWidth || 260;
        const hintHeight = dropHint.offsetHeight || 56;
        const maxX = window.innerWidth - hintWidth - margin;
        const maxY = window.innerHeight - hintHeight - margin;
        const left = Math.max(margin, Math.min(maxX, clientX + 8));
        const top = Math.max(margin, Math.min(maxY, clientY + 8));
        dropHint.style.left = `${left}px`;
        dropHint.style.top = `${top}px`;

        const operation = getDropOperation();
        const count = externalDragPaths.length;
        const destination = targetDir.split("/").filter(Boolean).at(-1) || targetDir;
        const verb = operation === "move" ? "Move" : "Copy";
        const noun = count === 1 ? "item" : "items";
        dropHintTitle.textContent = `Drop here to ${verb.toLowerCase()} ${count} ${noun} to ${destination}`;
        dropHintSubtitle.textContent =
          operation === "move" ? "Hold Option to copy instead" : "Release Option to move instead";
      };
      const refreshAfterDrop = (targetDir) => {
        if (window.htmx?.ajax) {
          window.htmx.ajax("GET", "command/navigate", {
            target: "#main-root",
            swap: "outerHTML",
            values: {path: targetDir},
          });
        }
      };
      const commitExternalDrop = async (targetDir, operation) => {
        if (!targetDir || externalDragPaths.length === 0) return;
        if (!hasMeaningfulDropTarget(targetDir)) {
          hideDropHint();
          clearDropTarget();
          return;
        }
        const invoke = window.__TAURI__?.core?.invoke;
        if (typeof invoke !== "function") return;
        hideDropHint();
        clearDropTarget();
        try {
          await invoke("drop_files_into_directory", {
            targetDir,
            sourcePaths: externalDragPaths,
            operation,
          });
          logNav("drop_files_into_directory success", {
            targetDir,
            operation,
            count: externalDragPaths.length,
          });
          refreshAfterDrop(targetDir);
        } catch (error) {
          logNav("drop_files_into_directory failed", {
            targetDir,
            operation,
            error: String(error),
          });
        }
      };
      const dragIconCache = new Map();
      const pathToFileUri = (path) => {
        if (!path) return "";
        if (path.startsWith("file://")) return path;
        const normalized = path.replace(/\\/g, "/");
        const encoded = normalized
          .split("/")
          .map((segment, index) => (index === 0 ? segment : encodeURIComponent(segment)))
          .join("/");
        if (encoded.startsWith("/")) return `file://${encoded}`;
        return `file:///${encoded}`;
      };
      const normalizeFsPath = (value) => String(value || "").replace(/\\/g, "/");
      const isWindowsAbsPath = (value) => /^[A-Za-z]:\//.test(value);
      const isAbsoluteFsPath = (value) => value.startsWith("/") || isWindowsAbsPath(value);
      const splitPathAndSuffix = (value) => {
        const match = String(value || "").match(/^([^?#]*)([?#].*)?$/);
        if (!match) return {pathPart: String(value || ""), suffix: ""};
        return {pathPart: match[1] || "", suffix: match[2] || ""};
      };
      const dirnameFsPath = (path) => {
        const normalized = normalizeFsPath(path);
        const index = normalized.lastIndexOf("/");
        if (index < 0) return "";
        if (index === 0) return "/";
        return normalized.slice(0, index);
      };
      const resolveFsPath = (baseDir, maybeRelativePath) => {
        const relative = normalizeFsPath(maybeRelativePath || "");
        if (!relative) return "";
        if (isAbsoluteFsPath(relative)) return relative;
        const base = normalizeFsPath(baseDir || "");
        const basePrefix = base.endsWith("/") ? base.slice(0, -1) : base;
        const joined = `${basePrefix}/${relative}`;
        const isAbsolute = joined.startsWith("/");
        const parts = joined.split("/");
        const resolved = [];
        for (const part of parts) {
          if (!part || part === ".") continue;
          if (part === "..") {
            const last = resolved[resolved.length - 1] || "";
            if (last && last !== ".." && !/^[A-Za-z]:$/.test(last)) {
              resolved.pop();
            } else if (!isAbsolute) {
              resolved.push("..");
            }
            continue;
          }
          resolved.push(part);
        }
        if (isAbsolute) {
          return `/${resolved.join("/")}`;
        }
        if (resolved.length > 0 && /^[A-Za-z]:$/.test(resolved[0])) {
          return `${resolved[0]}/${resolved.slice(1).join("/")}`;
        }
        return resolved.join("/");
      };
      const rewriteMarkdownPreviewImages = (scopeRoot) => {
        const assetUriToPath = (uri) => {
          if (!uri) return "";
          const value = String(uri || "");
          if (value.startsWith("asset://localhost/")) {
            const encoded = value.slice("asset://localhost/".length).split(/[?#]/)[0] || "";
            try {
              return decodeURIComponent(encoded);
            } catch (_error) {
              return encoded;
            }
          }
          try {
            const parsed = new URL(value);
            if (parsed.protocol === "asset:" && parsed.hostname === "localhost") {
              return decodeURIComponent((parsed.pathname || "").split(/[?#]/)[0] || "");
            }
          } catch (_error) {
            // Ignore parse errors.
          }
          return "";
        };
        if (!scopeRoot) return;
        const panes = [];
        if (scopeRoot.matches?.(".preview-pane[data-preview-path]")) {
          panes.push(scopeRoot);
        }
        panes.push(...scopeRoot.querySelectorAll(".preview-pane[data-preview-path]"));
        for (const pane of panes) {
          const markdownImages = pane.querySelectorAll(".preview-markdown img[src]");
          if (!markdownImages.length) continue;
          const markdownPath = String(pane.dataset.previewPath || "");
          if (!markdownPath) continue;
          const baseDir = dirnameFsPath(markdownPath);
          const invoke = window.__TAURI__?.core?.invoke;
          if (typeof invoke !== "function") continue;
          for (const image of markdownImages) {
            if (image.dataset.mdImgResolved === "true") continue;
            const rawSrc = String(image.getAttribute("src") || "").trim();
            if (!rawSrc) continue;
            if (rawSrc.startsWith("#")) continue;
            if (rawSrc.startsWith("//")) continue;
            if (/^(data:|blob:|https?:|mailto:|tel:)/i.test(rawSrc)) continue;
            if (
              /^[A-Za-z][A-Za-z0-9+.-]*:/.test(rawSrc) &&
              !rawSrc.startsWith("file://") &&
              !rawSrc.startsWith("asset://localhost/")
            ) {
              continue;
            }

            let absolutePath = "";
            if (rawSrc.startsWith("file://")) {
              absolutePath = fileUriToPath(rawSrc);
            } else if (rawSrc.startsWith("asset://localhost/")) {
              absolutePath = assetUriToPath(rawSrc);
            } else {
              const {pathPart} = splitPathAndSuffix(rawSrc);
              if (!pathPart) continue;
              absolutePath = resolveFsPath(baseDir, pathPart);
            }
            if (!absolutePath) continue;
            if (image.dataset.mdImgResolving === "true") continue;
            image.dataset.mdImgResolving = "true";
            invoke("load_local_image_data_url", {path: absolutePath})
              .then((dataUrl) => {
                const nextSrc = String(dataUrl || "");
                if (nextSrc) {
                  image.src = nextSrc;
                  image.dataset.mdImgResolved = "true";
                }
              })
              .catch(() => {
                // Leave original src unchanged if local resolution fails.
              })
              .finally(() => {
                delete image.dataset.mdImgResolving;
              });
          }
        }
      };
      const rewriteMarkdownPreviewLinks = (scopeRoot) => {
        if (!scopeRoot) return;
        const links = scopeRoot.querySelectorAll(".preview-markdown a[href]");
        for (const link of links) {
          link.setAttribute("target", "_blank");
          link.setAttribute("rel", "noopener noreferrer");
        }
      };
      const fileUriToPath = (uri) => {
        try {
          const parsed = new URL(uri);
          if (parsed.protocol !== "file:") return "";
          const pathname = decodeURIComponent(parsed.pathname || "");
          if (/^\/[A-Za-z]:\//.test(pathname)) {
            return pathname.slice(1);
          }
          return pathname || "";
        } catch (_error) {
          return "";
        }
      };
      const openMarkdownLinkExternally = async (anchor) => {
        if (!anchor) return;
        const opener = window.__TAURI__?.opener;
        const openUrl = opener?.openUrl;
        const openPath = opener?.openPath;
        const rawHref = String(anchor.getAttribute("href") || "").trim();
        if (!rawHref || rawHref.startsWith("#")) return;

        if (rawHref.startsWith("//")) {
          if (typeof openUrl === "function") {
            await openUrl(`https:${rawHref}`);
          }
          return;
        }

        if (/^(https?:|mailto:|tel:)/i.test(rawHref)) {
          if (typeof openUrl === "function") {
            await openUrl(rawHref);
          }
          return;
        }

        if (/^[A-Za-z][A-Za-z0-9+.-]*:/.test(rawHref)) {
          if (typeof openUrl === "function") {
            await openUrl(rawHref);
          }
          return;
        }

        const pane = anchor.closest(".preview-pane[data-preview-path]");
        const markdownPath = String(pane?.dataset?.previewPath || "");
        const baseDir = dirnameFsPath(markdownPath);
        const {pathPart} = splitPathAndSuffix(rawHref);
        if (!pathPart) return;

        if (rawHref.startsWith("file://")) {
          const localPath = fileUriToPath(rawHref);
          if (localPath && typeof openPath === "function") {
            await openPath(localPath);
          }
          return;
        }

        const absolutePath = resolveFsPath(baseDir, pathPart);
        if (absolutePath && typeof openPath === "function") {
          await openPath(absolutePath);
        }
      };
      const guessMimeType = (name, isDir) => {
        if (isDir) return "inode/directory";
        const ext = (name.split(".").pop() || "").toLowerCase();
        if (["png"].includes(ext)) return "image/png";
        if (["jpg", "jpeg"].includes(ext)) return "image/jpeg";
        if (["gif"].includes(ext)) return "image/gif";
        if (["webp"].includes(ext)) return "image/webp";
        if (["svg"].includes(ext)) return "image/svg+xml";
        if (["txt", "md", "json", "toml", "rs", "js", "ts", "html", "css"].includes(ext)) return "text/plain";
        if (["pdf"].includes(ext)) return "application/pdf";
        return "application/octet-stream";
      };
      rewriteMarkdownPreviewImages(root);
      rewriteMarkdownPreviewLinks(root);
      const clampName = (name) => {
        const limit = 34;
        if (!name || name.length <= limit) return name || "item";
        return `${name.slice(0, limit - 1)}\u2026`;
      };
      const pngDataUrlToBytes = (dataUrl) => {
        const encoded = dataUrl.split(",")[1] || "";
        const raw = atob(encoded);
        const bytes = new Array(raw.length);
        for (let i = 0; i < raw.length; i += 1) {
          bytes[i] = raw.charCodeAt(i);
        }
        return bytes;
      };
      const makeRowDragIcon = (name, isDir) => {
        const key = `${isDir ? "d" : "f"}:${name}`;
        if (dragIconCache.has(key)) {
          return dragIconCache.get(key);
        }
        const width = 260;
        const height = 32;
        const radius = 6;
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return null;
        }
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = themeToken("--accent-600", "#1F5FBF");
        ctx.strokeStyle = themeToken("--accent-500", "#2F86E9");
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(radius, 0);
        ctx.lineTo(width - radius, 0);
        ctx.quadraticCurveTo(width, 0, width, radius);
        ctx.lineTo(width, height - radius);
        ctx.quadraticCurveTo(width, height, width - radius, height);
        ctx.lineTo(radius, height);
        ctx.quadraticCurveTo(0, height, 0, height - radius);
        ctx.lineTo(0, radius);
        ctx.quadraticCurveTo(0, 0, radius, 0);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Draw a small folder/file glyph so the drag image matches row semantics.
        ctx.strokeStyle = isDir
          ? themeToken("--accent-300", "#9CC8FF")
          : themeToken("--accent-250", "#C7DAFC");
        ctx.fillStyle = "transparent";
        ctx.lineWidth = 1.5;
        if (isDir) {
          ctx.beginPath();
          ctx.moveTo(11, 11);
          ctx.lineTo(16, 11);
          ctx.lineTo(18, 9);
          ctx.lineTo(24, 9);
          ctx.quadraticCurveTo(25.5, 9, 25.5, 10.5);
          ctx.lineTo(25.5, 20);
          ctx.quadraticCurveTo(25.5, 21.5, 24, 21.5);
          ctx.lineTo(11, 21.5);
          ctx.quadraticCurveTo(9.5, 21.5, 9.5, 20);
          ctx.lineTo(9.5, 12.5);
          ctx.quadraticCurveTo(9.5, 11, 11, 11);
          ctx.closePath();
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.moveTo(11.5, 9.5);
          ctx.lineTo(20, 9.5);
          ctx.lineTo(24.5, 14);
          ctx.lineTo(24.5, 22.5);
          ctx.lineTo(11.5, 22.5);
          ctx.closePath();
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(20, 9.5);
          ctx.lineTo(20, 14);
          ctx.lineTo(24.5, 14);
          ctx.stroke();
        }

        ctx.fillStyle = themeToken("--accent-050", "#F3F6FF");
        ctx.font = '600 13px "SF Pro Text", "Segoe UI", sans-serif';
        ctx.textBaseline = "middle";
        ctx.fillText(clampName(name), 30, Math.round(height / 2) + 0.5);

        const bytes = pngDataUrlToBytes(canvas.toDataURL("image/png"));
        dragIconCache.set(key, bytes);
        return bytes;
      };
      const startPluginDrag = (paths, name, isDir, event) => {
        const startDrag = window.__TAURI__?.drag?.startDrag;
        if (typeof startDrag !== "function") return false;
        const normalizedPaths = Array.from(
          new Set((Array.isArray(paths) ? paths : [paths]).map((value) => String(value || "")).filter((value) => !!value)),
        );
        if (normalizedPaths.length === 0) return false;
        event.preventDefault();
        optionPressed = !!event.altKey;
        const icon = makeRowDragIcon(name || "item", isDir) || [];
        startDrag({
          item: normalizedPaths,
          icon,
        })
          .then(() => {
            logNav("plugin dragstart", {count: normalizedPaths.length});
          })
          .catch((error) => {
            logNav("plugin dragstart failed", {count: normalizedPaths.length, error: String(error)});
          })
          .finally(() => {
            dragInProgress = false;
          });
        return true;
      };

      restoreSelectionFromMemory();

      let initialFromRight = null;
      let shouldCommitInitialFromRight = false;
      if (window.__filesPendingRightFromPath) {
        const anchor = rows.find(
          (row) =>
            row.dataset.path === window.__filesPendingRightFromPath && row.classList.contains("is-selected"),
        );
        logNav("pendingRight anchor", {
          pending: window.__filesPendingRightFromPath,
          found: !!anchor,
          anchorColumn: anchor ? Number(anchor.dataset.column || 0) : null,
        });
        if (anchor) {
          const nextColumn = Number(anchor.dataset.column || 0) + 1;
          initialFromRight = selectedInColumn(nextColumn) || (rowsByColumn.get(nextColumn) || [])[0] || null;
          if (initialFromRight && !initialFromRight.classList.contains("is-selected")) {
            shouldCommitInitialFromRight = true;
          }
          logNav("pendingRight resolved", {
            nextColumn,
            initialFromRightPath: initialFromRight?.dataset?.path || null,
            shouldCommitInitialFromRight,
          });
        }
        window.__filesPendingRightFromPath = null;
      }

      const focusedInitialRow =
        root.contains(document.activeElement) && document.activeElement.classList.contains("finder-row")
          ? document.activeElement
          : null;
      const rememberedRow = rows.find((row) => row.dataset.path === getFocusPath());
      const initialRow = initialFromRight || focusedInitialRow || rightmostSelected() || rememberedRow || null;
      restoreScrollState();

      if (initialRow) {
        logNav("initialRow", {
          path: initialRow.dataset.path,
          column: Number(initialRow.dataset.column || 0),
          shouldCommitInitialFromRight,
        });
        setFocusPath(initialRow.dataset.path);
        initialRow.focus({preventScroll: true});
        const initialColumnIndex = Number(initialRow.dataset.column || 0);
        setActiveColumn(initialColumnIndex);
        ensureRowVisible(initialRow);
        ensureColumnAndNextVisible(initialColumnIndex);
        if (shouldCommitInitialFromRight) {
          setSingleSelection(initialRow);
          setTimeout(() => {
            if (document.body.contains(initialRow)) {
              const path = initialRow.dataset.path;
              logNav("auto-commit navigate", {path, column: initialRow.dataset.column});
              if (window.htmx?.ajax) {
                window.htmx.ajax("GET", "command/navigate", {
                  target: "#main-root",
                  swap: "outerHTML",
                  values: {path},
                });
              } else {
                initialRow.click();
              }
            }
          }, 0);
        }
      } else {
        applyWindowTitle(currentDirectoryTitle(), "init-no-initial-row");
      }

      const showContextMenu = (payload) => {
        const invoke = window.__TAURI__?.core?.invoke;
        if (typeof invoke !== "function") return;
        invoke("show_file_context_menu", {
          path: payload.path,
          isDir: !!payload.isDir,
          selectionCount: Number(payload.selectionCount || 1),
          selectedPaths: Array.isArray(payload.selectedPaths) ? payload.selectedPaths : null,
          x: payload.x,
          y: payload.y,
        }).catch(() => {});
      };
      const htmxCommandSwap = (command, values) =>
        window.htmx?.ajax?.("GET", `command/${command}`, {
          target: "#main-root",
          swap: "outerHTML",
          values,
        });
      let zipPreviewCloseInFlight = false;
      const maybeCloseZipPreviewIfInactive = () => {
        if (zipPreviewCloseInFlight) return;
        if (!previewPane?.classList.contains("is-zip-preview")) return;
        const previewPath = String(previewPane?.dataset?.previewPath || "");
        if (!previewPath) return;
        const stillSelected = selectedRows().some((row) => (row.dataset.path || "") === previewPath);
        const focusedPath = String(getFocusPath() || "");
        if (stillSelected && focusedPath === previewPath) return;
        zipPreviewCloseInFlight = true;
        const preferredPath = focusedPath && focusedPath !== previewPath ? focusedPath : "";
        const selectedWithoutPreview =
          selectedRows()
            .map((row) => row.dataset.path || "")
            .find((path) => !!path && path !== previewPath) || "";
        const fallbackPath = preferredPath || selectedWithoutPreview;
        if (fallbackPath) {
          htmxCommandSwap("navigate", {path: fallbackPath});
        } else {
          htmxCommandSwap("index", {});
        }
      };
      const invoke = window.__TAURI__?.core?.invoke;
      const invokeCommandSwap = async (command, values) => {
        if (typeof invoke !== "function") {
          throw new Error("Tauri invoke is unavailable.");
        }
        const html = await invoke(command, values || {});
        if (typeof html !== "string") {
          throw new Error("Invalid command response.");
        }
        if (window.htmx?.swap) {
          window.htmx.swap(root, html, {swapStyle: "outerHTML"});
        } else {
          root.outerHTML = html;
        }
      };
      const openNewWindow = async () => {
        if (typeof invoke !== "function") return;
        try {
          await invoke("new_window");
        } catch (error) {
          logNav("new_window failed", {error: String(error)});
        }
      };
      const openAppearanceWindow = async () => {
        if (typeof invoke !== "function") return;
        try {
          await invoke("open_appearance_window_command");
        } catch (error) {
          logNav("open_appearance_window_command failed", {error: String(error)});
        }
      };
      const closeTabOrWindow = async () => {
        if (typeof invoke !== "function") {
          if (activeTabId && activeTabId !== "default") {
            htmxCommandSwap("close_tab", {tabId: activeTabId});
          }
          return;
        }
        try {
          const html = await invoke("close_tab_or_window");
          if (typeof html === "string" && html.length > 0) {
            if (window.htmx?.swap) {
              window.htmx.swap(root, html, {swapStyle: "outerHTML"});
            } else {
              root.outerHTML = html;
            }
          }
        } catch (error) {
          logNav("close_tab_or_window failed", {error: String(error)});
          if (activeTabId && activeTabId !== "default") {
            htmxCommandSwap("close_tab", {tabId: activeTabId});
          }
        }
      };
      const isSearchOpen = () => !!searchRoot && !searchRoot.hidden;
      const isGotoOpen = () => !!gotoModal && !gotoModal.hidden;
      const isCommandOpen = () => !!commandModal && !commandModal.hidden;
      const isThemeSettingsOpen = () => !!themeSettingsModal && !themeSettingsModal.hidden;
      const runContextTerminalCommand = async (directoryPath, commandId) => {
        if (typeof invoke !== "function") return;
        const path = String(directoryPath || "");
        const id = String(commandId || "").trim();
        if (!path || !id) return;
        try {
          await invoke("run_context_terminal_command", {path, commandId: id});
        } catch (error) {
          logNav("run_context_terminal_command failed", {path, commandId: id, error: String(error)});
          await openFilesModal({
            title: "Run command",
            message: String(error || "Failed to run command."),
            confirmLabel: "Close",
            kind: "confirm",
          });
        }
      };
      const runContextAction = async (action, pathOrPaths) => {
        if (!action) return;
        const targetPaths = Array.from(
          new Set(
            (Array.isArray(pathOrPaths) ? pathOrPaths : [pathOrPaths])
              .map((value) => String(value || ""))
              .filter((value) => !!value),
          ),
        );
        if (targetPaths.length === 0) return;
        const firstPath = targetPaths[0];
        const name = firstPath.split("/").filter(Boolean).at(-1) || firstPath;
        const count = targetPaths.length;
        const normalized = String(action).toLowerCase();
        logNav("context action", {action, targetPaths});
        if (normalized.includes("open_default")) {
          if (typeof invoke === "function") {
            for (const path of targetPaths) {
              invoke("open_in_default", {path}).catch((error) => {
                logNav("open_in_default failed", {path, error: String(error)});
              });
            }
          }
          return;
        }
        if (normalized.includes("open_zed")) {
          if (typeof invoke === "function") {
            for (const path of targetPaths) {
              invoke("open_in_zed", {path}).catch((error) => {
                logNav("open_in_zed failed", {path, error: String(error)});
              });
            }
          }
          return;
        }
        if (normalized.includes("open_warp")) {
          if (typeof invoke === "function") {
            for (const path of targetPaths) {
              invoke("open_in_warp", {path}).catch((error) => {
                logNav("open_in_warp failed", {path, error: String(error)});
              });
            }
          }
          return;
        }
        if (normalized.includes("open_finder")) {
          if (typeof invoke === "function") {
            for (const path of targetPaths) {
              invoke("open_in_finder", {path}).catch((error) => {
                logNav("open_in_finder failed", {path, error: String(error)});
              });
            }
          }
          return;
        }
        if (normalized.includes("open_github_desktop")) {
          if (typeof invoke === "function") {
            for (const path of targetPaths) {
              invoke("open_in_github_desktop", {path}).catch((error) => {
                logNav("open_in_github_desktop failed", {path, error: String(error)});
              });
            }
          }
          return;
        }
        if (normalized.includes("set_tab_root")) {
          htmxCommandSwap("set_tab_root", {path: firstPath});
          return;
        }
        if (normalized.includes("copy_absolute_path")) {
          const writeText = navigator.clipboard?.writeText?.bind(navigator.clipboard);
          if (typeof writeText === "function") {
            writeText(targetPaths.join("\n")).catch((error) =>
              logNav("copy absolute failed", {targetPaths, error: String(error)}),
            );
          }
          return;
        }
        if (normalized.includes("copy_relative_path")) {
          const writeText = navigator.clipboard?.writeText?.bind(navigator.clipboard);
          const value = targetPaths.map((path) => toRelativePath(path)).join("\n");
          if (typeof writeText === "function") {
            writeText(value).catch((error) => logNav("copy relative failed", {targetPaths, error: String(error)}));
          }
          return;
        }
        if (normalized.includes("rename")) {
          let message = "Enter a new name:";
          let value = name;
          while (true) {
            const result = await openFilesModal({
              title: "Rename",
              message,
              confirmLabel: "Rename",
              kind: "prompt",
              initialValue: value,
              selectStemOnly: true,
            });
            if (!result.confirmed) return;
            const trimmed = String(result.value || "").trim();
            value = trimmed || value;
            if (!trimmed || trimmed === name) return;
            try {
              await invokeCommandSwap("rename_path", {path: firstPath, newName: trimmed});
              return;
            } catch (error) {
              message = `Enter a new name:\n${String(error || "Rename failed.")}`;
            }
          }
          return;
        }
        if (normalized.includes("new_dir")) {
          let message = "Directory name:";
          let value = "New Folder";
          while (true) {
            const result = await openFilesModal({
              title: "Create Directory",
              message,
              confirmLabel: "Create",
              kind: "prompt",
              initialValue: value,
            });
            if (!result.confirmed) return;
            const trimmed = String(result.value || "").trim();
            if (!trimmed) {
              message = "Directory name:\nName cannot be empty.";
              continue;
            }
            value = trimmed;
            try {
              await invokeCommandSwap("create_directory", {parentPath: firstPath, name: trimmed});
              return;
            } catch (error) {
              message = `Directory name:\n${String(error || "Create directory failed.")}`;
            }
          }
          return;
        }
        if (normalized.includes("new_file")) {
          let message = "File name:";
          let value = "untitled";
          while (true) {
            const result = await openFilesModal({
              title: "Create File",
              message,
              confirmLabel: "Create",
              kind: "prompt",
              initialValue: value,
            });
            if (!result.confirmed) return;
            const trimmed = String(result.value || "").trim();
            if (!trimmed) {
              message = "File name:\nName cannot be empty.";
              continue;
            }
            value = trimmed;
            try {
              await invokeCommandSwap("create_file", {parentPath: firstPath, name: trimmed});
              return;
            } catch (error) {
              message = `File name:\n${String(error || "Create file failed.")}`;
            }
          }
          return;
        }
        if (normalized.includes("trash")) {
          const message =
            count === 1
              ? `Move "${name}" to Trash?`
              : `Move ${count} selected items to Trash?`;
          const result = await openFilesModal({
            title: "Move to Trash",
            message,
            confirmLabel: "Trash",
            kind: "confirm",
          });
          if (!result.confirmed) return;
          if (count === 1) {
            htmxCommandSwap("trash_path", {path: firstPath});
            return;
          }
          htmxCommandSwap("trash_paths", {pathsJson: JSON.stringify(targetPaths)});
          return;
        }
        if (normalized.includes("delete")) {
          const message =
            count === 1
              ? `Delete "${name}" permanently?\nThis cannot be undone.`
              : `Delete ${count} selected items permanently?\nThis cannot be undone.`;
          const result = await openFilesModal({
            title: "Delete Permanently",
            message,
            confirmLabel: "Delete",
            kind: "danger",
          });
          if (!result.confirmed) return;
          if (count === 1) {
            htmxCommandSwap("delete_path", {path: firstPath});
            return;
          }
          htmxCommandSwap("delete_paths", {pathsJson: JSON.stringify(targetPaths)});
        }
      };
      window.__filesHandleNativeContextAction = async (payload) => {
        const action = String(payload?.action || "");
        if (!action) return;
        const payloadPaths = Array.isArray(payload?.paths)
          ? payload.paths.map((value) => String(value || "")).filter((value) => !!value)
          : [];
        const path = String(payload?.path || "");
        const targetPaths = payloadPaths.length > 0 ? payloadPaths : path ? [path] : [];
        if (targetPaths.length === 0) return;
        await runContextAction(action, targetPaths);
      };
      if (Array.isArray(window.__filesPendingNativeContextActions) && window.__filesPendingNativeContextActions.length > 0) {
        const queue = window.__filesPendingNativeContextActions.splice(0, window.__filesPendingNativeContextActions.length);
        for (const payload of queue) {
          window.__filesHandleNativeContextAction(payload);
        }
      }
      const setSearchStatus = (message) => {
        if (searchInlineStatus) {
          searchInlineStatus.textContent = String(message || "");
        }
      };
      const visibleDirectoryPaths = () =>
        columns
          .map((column) => column.dataset.path || "")
          .filter((path) => path.length > 0);
      const canAutoRefreshDirectories = () => {
        if (dragInProgress) return false;
        if (modalRoot && !modalRoot.hidden) return false;
        if (isSearchOpen() || isGotoOpen() || isCommandOpen() || isThemeSettingsOpen()) return false;
        return true;
      };
      const pollDirectoryChanges = () => {
        if (directorySyncInFlight) return;
        if (typeof invoke !== "function") return;
        if (!canAutoRefreshDirectories()) return;
        const paths = visibleDirectoryPaths();
        if (paths.length === 0) return;
        const pathKey = paths.join("\n");

        directorySyncInFlight = true;
        invoke("visible_directories_signature", {pathsJson: JSON.stringify(paths)})
          .then((signature) => {
            const next = String(signature || "");
            const previous = getDirectorySignature();
            const previousPathKey = getDirectoryPathKey();
            if (previousPathKey !== pathKey) {
              setDirectoryPathKey(pathKey);
              setDirectorySignature(next);
              return;
            }
            if (!previous) {
              setDirectorySignature(next);
              return;
            }
            if (previous !== next) {
              setDirectorySignature(next);
              htmxCommandSwap("index", {});
            }
          })
          .catch((error) => {
            logNav("visible_directories_signature failed", {error: String(error)});
          })
          .finally(() => {
            directorySyncInFlight = false;
          });
      };
      const startDirectoryPolling = () => {
        if (directorySyncTimer) clearInterval(directorySyncTimer);
        pollDirectoryChanges();
        directorySyncTimer = setInterval(pollDirectoryChanges, 1100);
      };
      const stopDirectoryPolling = () => {
        if (directorySyncTimer) {
          clearInterval(directorySyncTimer);
          directorySyncTimer = null;
        }
      };
      const clearSearchPreviewUrls = () => {
        while (searchPreviewObjectUrls.length > 0) {
          const url = searchPreviewObjectUrls.pop();
          if (url) URL.revokeObjectURL(url);
        }
      };
      const initSearchPreviewMedia = () => {
        rewriteMarkdownPreviewImages(searchPreview);
        rewriteMarkdownPreviewLinks(searchPreview);
        if (!searchPreview || typeof invoke !== "function") return;
        const pdfIframe = searchPreview.querySelector(".preview-pdf[data-pdf-path]");
        if (pdfIframe) {
          const rawPath = pdfIframe.getAttribute("data-pdf-path") || "";
          const status = searchPreview.querySelector("#search-preview-pdf-status");
          if (rawPath) {
            invoke("load_pdf_preview_data", {path: rawPath})
              .then((base64) => {
                const bytes = base64ToBytes(base64);
                const blob = new Blob([bytes], {type: "application/pdf"});
                const url = URL.createObjectURL(blob);
                searchPreviewObjectUrls.push(url);
                pdfIframe.src = url;
                pdfIframe.hidden = false;
                if (status) status.textContent = "";
              })
              .catch((error) => {
                if (status) status.textContent = String(error || "Failed to load PDF preview.");
              });
          }
        }
        const glbViewer = searchPreview.querySelector(".preview-model[data-glb-path]");
        if (glbViewer) {
          const rawPath = glbViewer.getAttribute("data-glb-path") || "";
          const status = searchPreview.querySelector("#search-preview-glb-status");
          if (rawPath) {
            invoke("load_glb_preview_data", {path: rawPath})
              .then((payload) => {
                const base64 = payload?.base64 || "";
                const mimeType = payload?.mime_type || "model/gltf-binary";
                if (!base64) throw new Error("Empty model payload.");
                const bytes = base64ToBytes(base64);
                const blob = new Blob([bytes], {type: mimeType});
                const url = URL.createObjectURL(blob);
                searchPreviewObjectUrls.push(url);
                glbViewer.src = url;
                const reveal = () => {
                  glbViewer.hidden = false;
                  if (status) status.textContent = "";
                };
                if (customElements.get("model-viewer")) {
                  reveal();
                } else {
                  customElements.whenDefined("model-viewer").then(reveal).catch(() => {
                    if (status) status.textContent = "3D viewer failed to initialize.";
                  });
                }
              })
              .catch((error) => {
                if (status) status.textContent = String(error || "Failed to load 3D preview.");
              });
          }
        }
        const videoPlayer = searchPreview.querySelector(".preview-video[data-video-path]");
        if (videoPlayer) {
          const rawPath = videoPlayer.getAttribute("data-video-path") || "";
          const status = searchPreview.querySelector("#search-preview-video-status");
          if (rawPath) {
            invoke("load_video_preview_data", {path: rawPath})
              .then((payload) => {
                const base64 = payload?.base64 || "";
                const mimeType = payload?.mime_type || "video/mp4";
                if (!base64) throw new Error("Empty video payload.");
                const bytes = base64ToBytes(base64);
                const blob = new Blob([bytes], {type: mimeType});
                const url = URL.createObjectURL(blob);
                searchPreviewObjectUrls.push(url);
                videoPlayer.src = url;
                videoPlayer.hidden = false;
                if (status) status.textContent = "";
              })
              .catch((error) => {
                if (status) status.textContent = String(error || "Failed to load video preview.");
              });
          }
        }
      };
      const requestSearchPreview = (path) => {
        if (!searchPreview || typeof invoke !== "function") return;
        if (!path) {
          searchPreviewPath = null;
          clearSearchPreviewUrls();
          searchPreview.innerHTML = '<div class="files-search-preview-empty">No preview</div>';
          return;
        }
        if (searchPreviewPath === path) return;
        searchPreviewPath = path;
        invoke("fuzzy_search_preview", {path})
          .then((html) => {
            if (!isSearchOpen() || !searchPreview || searchPreviewPath !== path) return;
            clearSearchPreviewUrls();
            searchPreview.innerHTML = String(html || '<div class="files-search-preview-empty">No preview</div>');
            initSearchPreviewMedia();
          })
          .catch(() => {
            if (!searchPreview || searchPreviewPath !== path) return;
            clearSearchPreviewUrls();
            searchPreview.innerHTML = '<div class="files-search-preview-empty">No preview</div>';
          });
      };
      const updateSearchInlineStatusFromResults = () => {
        if (!searchInlineStatus || !searchResults) return;
        const meta = searchResults.querySelector(".files-search-meta");
        if (!meta) {
          searchInlineStatus.textContent = "";
          return;
        }
        const running = (meta.getAttribute("data-running") || "false") === "true";
        const scanned = Number(meta.getAttribute("data-scanned") || 0);
        searchInlineStatus.textContent = running ? `Searching... ${scanned}` : "";
      };
      if (searchRoot) {
        searchRoot.hidden = true;
      }
      const getSearchItems = () =>
        searchResults ? Array.from(searchResults.querySelectorAll(".files-search-item[data-path]")) : [];
      const applySearchSelection = () => {
        const items = getSearchItems();
        if (items.length === 0) {
          searchSelectedIndex = 0;
          searchSelectedPath = null;
          searchUserPicked = false;
          requestSearchPreview(null);
          return;
        }
        if (!searchUserPicked) {
          searchSelectedPath = null;
          items.forEach((item) => item.classList.remove("is-active"));
          requestSearchPreview(null);
          return;
        }
        if (searchSelectedPath) {
          const byPathIndex = items.findIndex((item) => (item.dataset.path || "") === searchSelectedPath);
          if (byPathIndex >= 0) {
            searchSelectedIndex = byPathIndex;
          }
        }
        if (searchSelectedIndex < 0) searchSelectedIndex = 0;
        if (searchSelectedIndex >= items.length) searchSelectedIndex = items.length - 1;
        items.forEach((item, index) => {
          item.classList.toggle("is-active", index === searchSelectedIndex);
        });
        const active = items[searchSelectedIndex];
        if (active) {
          searchSelectedPath = active.dataset.path || null;
          requestSearchPreview(searchSelectedPath);
          active.scrollIntoView({block: "nearest"});
          const path = active.dataset.path || "";
          if (path) {
            const row = rows.find((candidate) => candidate.dataset.path === path) || null;
            if (row) {
              setFocusPath(path);
              setSingleSelection(row);
              setActiveColumn(Number(row.dataset.column || 0));
            }
          }
        }
      };
      const moveSearchSelection = (delta) => {
        const items = getSearchItems();
        if (items.length === 0) return;
        if (!searchUserPicked) {
          searchUserPicked = true;
          searchSelectedIndex = delta >= 0 ? 0 : items.length - 1;
          searchSelectedPath = null;
          applySearchSelection();
          return;
        }
        searchSelectedIndex += delta;
        searchSelectedPath = null;
        applySearchSelection();
      };
      const pollSearchResults = () => {
        if (!isSearchOpen() || !searchResults || typeof invoke !== "function") return;
        invoke("fuzzy_search_results")
          .then((html) => {
            if (!isSearchOpen() || !searchResults) return;
            const nextHtml = String(html || "");
            if (nextHtml !== lastSearchResultsHtml) {
              searchResults.innerHTML = nextHtml;
              lastSearchResultsHtml = nextHtml;
            }
            updateSearchInlineStatusFromResults();
            applySearchSelection();
          })
          .catch((error) => {
            setSearchStatus(`Search poll failed: ${String(error || "unknown error")}`);
            logNav("fuzzy_search_results failed", {error: String(error)});
          });
      };
      const startSearchPolling = () => {
        if (!searchResults) return;
        if (searchPollTimer) clearInterval(searchPollTimer);
        searchPollTimer = setInterval(() => {
          pollSearchResults();
        }, 220);
      };
      const stopSearchPolling = () => {
        if (searchPollTimer) {
          clearInterval(searchPollTimer);
          searchPollTimer = null;
        }
      };
      const requestSearch = (query) => {
        if (typeof invoke !== "function") return;
        invoke("fuzzy_search_start", {query}).then(() => {
          pollSearchResults();
        }).catch((error) => {
          setSearchStatus(`Search failed: ${String(error || "unknown error")}`);
          logNav("fuzzy_search_start failed", {error: String(error)});
        });
      };
      const closeSearchPalette = () => {
        if (!searchRoot) return;
        searchRoot.hidden = true;
        stopSearchPolling();
        if (searchDebounceTimer) {
          clearTimeout(searchDebounceTimer);
          searchDebounceTimer = null;
        }
        if (typeof invoke === "function") {
          invoke("fuzzy_search_cancel").catch(() => {});
        }
        lastSearchResultsHtml = "";
        searchSelectedPath = null;
        searchUserPicked = false;
        searchPreviewPath = null;
        clearSearchPreviewUrls();
        if (searchPreview) {
          searchPreview.innerHTML = '<div class="files-search-preview-empty">No preview</div>';
        }
        setSearchStatus("");
      };
      const getGoToSuggestionItems = () =>
        gotoSuggestions
          ? Array.from(gotoSuggestions.querySelectorAll(".goto-suggestion-item[data-value]"))
          : [];
      const applyGoToSuggestionSelection = () => {
        const items = getGoToSuggestionItems();
        if (items.length === 0) {
          gotoSuggestionIndex = -1;
          return;
        }
        for (let index = 0; index < items.length; index += 1) {
          items[index].classList.toggle("is-active", index === gotoSuggestionIndex);
        }
        if (gotoSuggestionIndex >= 0) {
          items[gotoSuggestionIndex]?.scrollIntoView({block: "nearest"});
        }
      };
      const clearGoToSuggestions = () => {
        if (gotoSuggestDebounceTimer) {
          clearTimeout(gotoSuggestDebounceTimer);
          gotoSuggestDebounceTimer = null;
        }
        gotoSuggestGeneration += 1;
        gotoSuggestionIndex = -1;
        if (gotoSuggestions) {
          gotoSuggestions.hidden = true;
          gotoSuggestions.innerHTML = "";
        }
      };
      const renderGoToSuggestions = (items) => {
        if (!gotoSuggestions) return;
        gotoSuggestions.innerHTML = "";
        const normalized = Array.isArray(items)
          ? items
              .map((item) => ({
                name: String(item?.name || ""),
                value: String(item?.value || ""),
              }))
              .filter((item) => item.name.length > 0 && item.value.length > 0)
          : [];
        if (normalized.length === 0) {
          gotoSuggestions.hidden = true;
          gotoSuggestionIndex = -1;
          return;
        }
        const fragment = document.createDocumentFragment();
        for (const item of normalized) {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "goto-suggestion-item";
          button.dataset.value = item.value;
          button.textContent = item.name;
          fragment.appendChild(button);
        }
        gotoSuggestions.appendChild(fragment);
        gotoSuggestions.hidden = false;
        gotoSuggestionIndex = -1;
        applyGoToSuggestionSelection();
      };
      const requestGoToSuggestions = ({immediate = false} = {}) => {
        if (!gotoInput || typeof invoke !== "function") return;
        if (gotoSuggestDebounceTimer) {
          clearTimeout(gotoSuggestDebounceTimer);
          gotoSuggestDebounceTimer = null;
        }
        const run = () => {
          if (!isGotoOpen()) return;
          const generation = ++gotoSuggestGeneration;
          invoke("goto_directory_suggestions", {path: String(gotoInput.value || "")})
            .then((items) => {
              if (generation !== gotoSuggestGeneration || !isGotoOpen()) return;
              renderGoToSuggestions(items);
            })
            .catch(() => {
              if (generation !== gotoSuggestGeneration || !isGotoOpen()) return;
              renderGoToSuggestions([]);
            });
        };
        if (immediate) {
          run();
          return;
        }
        gotoSuggestDebounceTimer = setTimeout(run, 65);
      };
      const moveGoToSuggestionSelection = (delta) => {
        const items = getGoToSuggestionItems();
        if (items.length === 0) return false;
        if (gotoSuggestionIndex < 0) {
          gotoSuggestionIndex = delta >= 0 ? 0 : items.length - 1;
        } else {
          gotoSuggestionIndex = Math.max(0, Math.min(gotoSuggestionIndex + delta, items.length - 1));
        }
        applyGoToSuggestionSelection();
        return true;
      };
      const completeGoToSuggestion = () => {
        if (!gotoInput) return false;
        const items = getGoToSuggestionItems();
        if (items.length === 0) return false;
        if (gotoSuggestionIndex < 0) return false;
        const active = items[gotoSuggestionIndex] || null;
        const value = String(active?.dataset?.value || "");
        if (!value) return false;
        gotoInput.value = value;
        if (gotoError) gotoError.textContent = "";
        gotoInput.focus({preventScroll: true});
        if (typeof gotoInput.setSelectionRange === "function") {
          gotoInput.setSelectionRange(value.length, value.length);
        }
        requestGoToSuggestions({immediate: true});
        return true;
      };
      const closeGoToModal = () => {
        if (!gotoModal) return;
        gotoModal.hidden = true;
        if (gotoError) gotoError.textContent = "";
        clearGoToSuggestions();
      };
      const openGoToModal = () => {
        if (!gotoModal || !gotoInput) return;
        gotoModal.hidden = false;
        if (gotoError) gotoError.textContent = "";
        gotoInput.value = getFocusPath() || "";
        requestGoToSuggestions({immediate: true});
        setTimeout(() => {
          gotoInput.focus();
          gotoInput.select();
        }, 0);
      };
      const formatThemeLightnessOffset = (offset) => {
        const normalized = normalizeThemeLightnessOffset(offset) ?? defaultThemeLightnessOffset;
        if (normalized > 0) return `+${normalized}`;
        return String(normalized);
      };
      const syncThemeSettingsInputs = (
        baseColor,
        highlightColor = currentThemeHighlightColor,
        lightnessOffset = currentThemeLightnessOffset,
      ) => {
        const normalizedBase = normalizeHexColor(baseColor) || currentThemeBaseColor || defaultThemeBaseColor;
        const normalizedHighlight =
          normalizeHexColor(highlightColor) || currentThemeHighlightColor || defaultThemeHighlightColor;
        const normalizedLightnessOffset =
          normalizeThemeLightnessOffset(lightnessOffset) ?? currentThemeLightnessOffset ?? defaultThemeLightnessOffset;
        if (themeSettingsColor) {
          themeSettingsColor.value = normalizedBase;
        }
        if (themeSettingsHex) {
          themeSettingsHex.value = normalizedBase;
        }
        if (themeSettingsHighlightColor) {
          themeSettingsHighlightColor.value = normalizedHighlight;
        }
        if (themeSettingsHighlightHex) {
          themeSettingsHighlightHex.value = normalizedHighlight;
        }
        if (themeSettingsDepthRange) {
          themeSettingsDepthRange.value = String(normalizedLightnessOffset);
        }
        if (themeSettingsDepthValue) {
          themeSettingsDepthValue.textContent = formatThemeLightnessOffset(normalizedLightnessOffset);
        }
        if (themeSettingsPreview) {
          themeSettingsPreview.textContent = `Background ${normalizedBase} | Highlight ${normalizedHighlight} | Lightness ${formatThemeLightnessOffset(normalizedLightnessOffset)}`;
        }
      };
      const readThemeSettingsBaseColor = (preferred = "hex") => {
        const fromHex = normalizeHexColor(themeSettingsHex?.value || "");
        const fromPicker = normalizeHexColor(themeSettingsColor?.value || "");
        if (preferred === "picker") {
          if (fromPicker) return fromPicker;
          if (fromHex) return fromHex;
        } else {
          if (fromHex) return fromHex;
          if (fromPicker) return fromPicker;
        }
        return normalizeHexColor(currentThemeBaseColor) || defaultThemeBaseColor;
      };
      const readThemeSettingsHighlightColor = (preferred = "hex") => {
        const fromHex = normalizeHexColor(themeSettingsHighlightHex?.value || "");
        const fromPicker = normalizeHexColor(themeSettingsHighlightColor?.value || "");
        if (preferred === "picker") {
          if (fromPicker) return fromPicker;
          if (fromHex) return fromHex;
        } else {
          if (fromHex) return fromHex;
          if (fromPicker) return fromPicker;
        }
        return normalizeHexColor(currentThemeHighlightColor) || defaultThemeHighlightColor;
      };
      const readThemeSettingsLightnessOffset = () => {
        const fromRange = normalizeThemeLightnessOffset(themeSettingsDepthRange?.value);
        if (fromRange !== null) return fromRange;
        return normalizeThemeLightnessOffset(currentThemeLightnessOffset) ?? defaultThemeLightnessOffset;
      };
      const previewThemeSettingsAppearance = ({basePreferred = "hex", highlightPreferred = "hex"} = {}) => {
        const normalizedBase = readThemeSettingsBaseColor(basePreferred);
        const normalizedHighlight = readThemeSettingsHighlightColor(highlightPreferred);
        const normalizedLightnessOffset = readThemeSettingsLightnessOffset();
        const appliedTheme = applyThemeAppearance(
          normalizedBase,
          normalizedHighlight,
          normalizedLightnessOffset,
        );
        currentThemeBaseColor = appliedTheme.baseColor;
        currentThemeHighlightColor = appliedTheme.highlightColor;
        currentThemeLightnessOffset = appliedTheme.lightnessOffset;
        syncThemeSettingsInputs(
          currentThemeBaseColor,
          currentThemeHighlightColor,
          currentThemeLightnessOffset,
        );
      };
      const closeThemeSettingsModal = ({persist = false} = {}) => {
        if (!themeSettingsModal) return;
        themeSettingsModal.hidden = true;
        if (!persist) {
          const appliedTheme = applyThemeAppearance(
            themeSettingsOriginalColor,
            themeSettingsOriginalHighlightColor,
            themeSettingsOriginalLightnessOffset,
          );
          currentThemeBaseColor = appliedTheme.baseColor;
          currentThemeHighlightColor = appliedTheme.highlightColor;
          currentThemeLightnessOffset = appliedTheme.lightnessOffset;
          syncThemeSettingsInputs(
            currentThemeBaseColor,
            currentThemeHighlightColor,
            currentThemeLightnessOffset,
          );
        }
      };
      const openThemeSettingsModal = () => {
        if (!themeSettingsModal) return;
        closeSearchPalette();
        closeGoToModal();
        if (isCommandOpen()) {
          closeCommandModal();
        }
        themeSettingsOriginalColor = currentThemeBaseColor;
        themeSettingsOriginalHighlightColor = currentThemeHighlightColor;
        themeSettingsOriginalLightnessOffset = currentThemeLightnessOffset;
        syncThemeSettingsInputs(
          currentThemeBaseColor,
          currentThemeHighlightColor,
          currentThemeLightnessOffset,
        );
        themeSettingsModal.hidden = false;
        setTimeout(() => {
          if (themeSettingsColor) {
            themeSettingsColor.focus();
          } else {
            themeSettingsHex?.focus();
          }
        }, 0);
      };
      const persistThemeAppearance = async (baseColor, highlightColor, lightnessOffset) => {
        const normalizedBase = normalizeHexColor(baseColor);
        const normalizedHighlight = normalizeHexColor(highlightColor);
        const normalizedLightnessOffset = normalizeThemeLightnessOffset(lightnessOffset);
        if (!normalizedBase) return false;
        if (!normalizedHighlight) return false;
        if (normalizedLightnessOffset === null) return false;
        if (typeof settingsInvoke === "function") {
          try {
            const [savedBaseColor, savedHighlightColor, savedLightness] = await Promise.all([
              settingsInvoke("set_theme_base_color", {color: normalizedBase}),
              settingsInvoke("set_theme_highlight_color", {color: normalizedHighlight}),
              settingsInvoke("set_theme_lightness_offset", {offset: normalizedLightnessOffset}),
            ]);
            const finalBase = normalizeHexColor(String(savedBaseColor || normalizedBase)) || normalizedBase;
            const finalHighlight =
              normalizeHexColor(String(savedHighlightColor || normalizedHighlight)) || normalizedHighlight;
            const finalLightness =
              normalizeThemeLightnessOffset(savedLightness) ?? normalizedLightnessOffset;
            const appliedTheme = applyThemeAppearance(finalBase, finalHighlight, finalLightness);
            currentThemeBaseColor = appliedTheme.baseColor;
            currentThemeHighlightColor = appliedTheme.highlightColor;
            currentThemeLightnessOffset = appliedTheme.lightnessOffset;
            syncThemeSettingsInputs(
              currentThemeBaseColor,
              currentThemeHighlightColor,
              currentThemeLightnessOffset,
            );
            return true;
          } catch (error) {
            await openFilesModal({
              title: "Appearance",
              message: String(error || "Failed to save appearance settings."),
              confirmLabel: "Close",
              kind: "confirm",
            });
            return false;
          }
        }
        const appliedTheme = applyThemeAppearance(
          normalizedBase,
          normalizedHighlight,
          normalizedLightnessOffset,
        );
        currentThemeBaseColor = appliedTheme.baseColor;
        currentThemeHighlightColor = appliedTheme.highlightColor;
        currentThemeLightnessOffset = appliedTheme.lightnessOffset;
        syncThemeSettingsInputs(
          currentThemeBaseColor,
          currentThemeHighlightColor,
          currentThemeLightnessOffset,
        );
        return true;
      };
      const submitGoToModal = () => {
        if (!gotoInput || typeof invoke !== "function") return;
        const value = String(gotoInput.value || "").trim();
        if (!value) {
          if (gotoError) gotoError.textContent = "Enter a path.";
          gotoInput.focus();
          return;
        }
        invoke("validate_location_path", {path: value})
          .then((normalizedPath) => {
            closeGoToModal();
            htmxCommandSwap("go_to_location", {path: normalizedPath});
          })
          .catch((error) => {
            if (gotoError) gotoError.textContent = String(error || "Invalid path.");
            gotoInput.focus();
            gotoInput.select();
          });
      };
      const openSearchPalette = (initialQuery = "") => {
        if (!searchRoot || !searchInput) return;
        const query = String(initialQuery || "");
        searchRoot.hidden = false;
        searchInput.value = query;
        searchSelectedIndex = 0;
        searchSelectedPath = null;
        searchUserPicked = false;
        searchPreviewPath = null;
        clearSearchPreviewUrls();
        if (searchPreview) {
          searchPreview.innerHTML = '<div class="files-search-preview-empty">No preview</div>';
        }
        lastSearchResultsHtml = "";
        setSearchStatus("");
        requestSearch(query);
        startSearchPolling();
        pollSearchResults();
        setTimeout(() => {
          searchInput.focus();
          if (query.length > 0 && typeof searchInput.setSelectionRange === "function") {
            const end = query.length;
            searchInput.setSelectionRange(end, end);
          } else {
            searchInput.select();
          }
        }, 0);
      };
      const openSearchSelection = () => {
        if (!searchUserPicked) return;
        const items = getSearchItems();
        if (items.length === 0) return;
        const selected = items[searchSelectedIndex] || items[0];
        const path = selected?.dataset?.path || "";
        if (!path) return;
        setFocusPath(path);
        closeSearchPalette();
        htmxCommandSwap("navigate", {path});
      };
      const closeCommandModal = () => {
        if (!commandModal) return;
        logNav("command modal close");
        commandModal.hidden = true;
        commandModalIgnoreBackdropUntil = 0;
        commandModalIgnoreInteractionsUntil = 0;
      };
      const defaultCommandCapabilities = (isDir) => ({
        is_dir: !!isDir,
        show_default_open: false,
        show_github_desktop: false,
        context_commands: [],
      });
      const normalizeContextCommands = (commands) =>
        (Array.isArray(commands) ? commands : [])
          .map((entry) => ({
            id: String(entry?.id || "").trim(),
            label: String(entry?.label || "").trim(),
            command: String(entry?.command || "").trim(),
          }))
          .filter((entry) => entry.id && entry.label && entry.command);
      const maybeLoadCommandCapabilities = (path, isDir) => {
        if (!path || typeof invoke !== "function") return;
        if (commandCapabilitiesByPath.has(path)) return;
        commandCapabilitiesByPath.set(path, defaultCommandCapabilities(isDir));
        invoke("path_context_capabilities", {path})
          .then((capabilities) => {
            commandCapabilitiesByPath.set(path, {
              is_dir: !!capabilities?.is_dir,
              show_default_open: !!capabilities?.show_default_open,
              show_github_desktop: !!capabilities?.show_github_desktop,
              context_commands: normalizeContextCommands(capabilities?.context_commands),
            });
            if (isCommandOpen()) {
              renderCommandItems();
            }
          })
          .catch((error) => {
            logNav("path_context_capabilities failed", {path, error: String(error)});
          });
      };
      const getCommandItems = () => {
        const current = focusedRow();
        const fileItems = [];
        const currentDirectoryItems = [];
        const selectedDirectoryItems = [];
        const tabItems = [];
        const currentPath = current?.dataset?.path || "";
        const isDir = (current?.dataset?.isDir || "") === "true";
        const currentColumnIndex = Number(current?.dataset?.column || 0);
        const selected = selectedPathsInColumn(currentColumnIndex);
        const actionPaths = currentPath && selected.includes(currentPath) ? selected : currentPath ? [currentPath] : [];
        const hasMultiSelection = actionPaths.length > 1;
        if (rootPath) {
          maybeLoadCommandCapabilities(rootPath, true);
        }
        if (currentPath) {
          maybeLoadCommandCapabilities(currentPath, isDir);
        }
        const rootCapabilities = rootPath
          ? commandCapabilitiesByPath.get(rootPath) || defaultCommandCapabilities(true)
          : defaultCommandCapabilities(true);
        const capabilities = currentPath
          ? commandCapabilitiesByPath.get(currentPath) || defaultCommandCapabilities(isDir)
          : defaultCommandCapabilities(false);
        const currentColumnPath =
          columns.find((column) => Number(column.dataset.column || 0) === currentColumnIndex)?.dataset.path || rootPath;
        const currentDirectoryPath = currentColumnPath || rootPath;
        const selectedDirectoryPath = isDir ? currentPath : "";
        if (currentDirectoryPath) {
          maybeLoadCommandCapabilities(currentDirectoryPath, true);
        }
        if (selectedDirectoryPath) {
          maybeLoadCommandCapabilities(selectedDirectoryPath, true);
        }
        const currentDirectoryCapabilities = currentDirectoryPath
          ? commandCapabilitiesByPath.get(currentDirectoryPath) || defaultCommandCapabilities(true)
          : defaultCommandCapabilities(true);
        const selectedDirectoryCapabilities = selectedDirectoryPath
          ? commandCapabilitiesByPath.get(selectedDirectoryPath) || defaultCommandCapabilities(true)
          : defaultCommandCapabilities(true);
        const pushDirectoryCommandSet = (targetItems, labelPrefix, directoryPath, directoryCapabilities) => {
          if (!directoryPath) return;
          targetItems.push({
            label: `${labelPrefix}: Create directory`,
            hint: "",
            run: () => {
              closeCommandModal();
              runContextAction("new_dir", directoryPath);
            },
          });
          targetItems.push({
            label: `${labelPrefix}: Create file`,
            hint: "",
            run: () => {
              closeCommandModal();
              runContextAction("new_file", directoryPath);
            },
          });
          targetItems.push({
            label: `${labelPrefix}: Set as current tab root`,
            hint: "",
            run: () => {
              closeCommandModal();
              runContextAction("set_tab_root", directoryPath);
            },
          });
          targetItems.push({
            label: `${labelPrefix}: Open in Zed`,
            hint: "",
            run: () => {
              closeCommandModal();
              runContextAction("open_zed", directoryPath);
            },
          });
          targetItems.push({
            label: `${labelPrefix}: Open in Finder`,
            hint: "",
            run: () => {
              closeCommandModal();
              runContextAction("open_finder", directoryPath);
            },
          });
          targetItems.push({
            label: `${labelPrefix}: Open in Warp`,
            hint: "",
            run: () => {
              closeCommandModal();
              runContextAction("open_warp", directoryPath);
            },
          });
          if (directoryCapabilities.show_github_desktop) {
            targetItems.push({
              label: `${labelPrefix}: Open in GitHub Desktop`,
              hint: "",
              run: () => {
                closeCommandModal();
                runContextAction("open_github_desktop", directoryPath);
              },
            });
          }
        };
        const pushContextCommandSet = (targetItems, labelPrefix, directoryPath, directoryCapabilities) => {
          if (!directoryPath) return;
          const contextCommands = Array.isArray(directoryCapabilities?.context_commands)
            ? directoryCapabilities.context_commands
            : [];
          for (const contextCommand of contextCommands) {
            const commandId = String(contextCommand?.id || "");
            const commandLabel = String(contextCommand?.label || "");
            const commandText = String(contextCommand?.command || "");
            if (!commandId || !commandLabel || !commandText) continue;
            targetItems.push({
              label: `${labelPrefix}: ${commandLabel}`,
              hint: commandText,
              run: () => {
                closeCommandModal();
                runContextTerminalCommand(directoryPath, commandId);
              },
            });
          }
        };

        tabItems.push({
          label: "Tab: Go to location",
          hint: "Cmd+G or /",
          run: () => {
            closeCommandModal();
            openGoToModal();
          },
        });
        tabItems.push({
          label: "Window: New window",
          hint: "Cmd+N",
          run: () => {
            closeCommandModal();
            openNewWindow();
          },
        });
        tabItems.push({
          label: "Window: Settings",
          hint: "Cmd+,",
          run: () => {
            closeCommandModal();
            openAppearanceWindow();
          },
        });
        tabItems.push({
          label: showHidden ? "Tab: Hide hidden files" : "Tab: Show hidden files",
          hint: "",
          run: () => {
            closeCommandModal();
            htmxCommandSwap("set_tab_show_hidden", {showHidden: !showHidden});
          },
        });
        if (rootPath) {
          tabItems.push({
            label: "Tab Root Directory: Open in Zed",
            hint: "",
            run: () => {
              closeCommandModal();
              runContextAction("open_zed", rootPath);
            },
          });
          tabItems.push({
            label: "Tab Root Directory: Open in Finder",
            hint: "",
            run: () => {
              closeCommandModal();
              runContextAction("open_finder", rootPath);
            },
          });
          tabItems.push({
            label: "Tab Root Directory: Open in Warp",
            hint: "",
            run: () => {
              closeCommandModal();
              runContextAction("open_warp", rootPath);
            },
          });
          if (rootCapabilities.show_github_desktop) {
            tabItems.push({
              label: "Tab Root Directory: Open in GitHub Desktop",
              hint: "",
              run: () => {
                closeCommandModal();
                runContextAction("open_github_desktop", rootPath);
              },
            });
          }
          pushContextCommandSet(tabItems, "Tab Root Directory", rootPath, rootCapabilities);
        }

        if (currentPath) {
          const selectionPrefix = hasMultiSelection
            ? `Selection (${actionPaths.length} items)`
            : isDir
              ? "Selected Directory"
              : "File";
          if (capabilities.show_default_open && !hasMultiSelection) {
            fileItems.push({
              label: `${selectionPrefix}: Open`,
              hint: "",
              run: () => {
                closeCommandModal();
                runContextAction("open_default", currentPath);
              },
            });
          }
          if (selectedDirectoryPath) {
            pushDirectoryCommandSet(
              selectedDirectoryItems,
              "Selected Directory",
              selectedDirectoryPath,
              selectedDirectoryCapabilities,
            );
            pushContextCommandSet(
              selectedDirectoryItems,
              "Selected Directory",
              selectedDirectoryPath,
              selectedDirectoryCapabilities,
            );
          }
          if (currentDirectoryPath) {
            pushDirectoryCommandSet(
              currentDirectoryItems,
              "Current Directory",
              currentDirectoryPath,
              currentDirectoryCapabilities,
            );
            pushContextCommandSet(
              currentDirectoryItems,
              "Current Directory",
              currentDirectoryPath,
              currentDirectoryCapabilities,
            );
          }
          if (!hasMultiSelection && !isDir) {
            fileItems.push({
              label: "File: Open in Zed",
              hint: "",
              run: () => {
                closeCommandModal();
                runContextAction("open_zed", actionPaths);
              },
            });
          }
          fileItems.push({
            label: `${selectionPrefix}: Copy absolute path`,
            hint: "",
            run: () => {
              closeCommandModal();
              runContextAction("copy_absolute_path", actionPaths);
            },
          });
          fileItems.push({
            label: `${selectionPrefix}: Copy relative path`,
            hint: "",
            run: () => {
              closeCommandModal();
              runContextAction("copy_relative_path", actionPaths);
            },
          });
          if (!hasMultiSelection) {
            fileItems.push({
              label: `${selectionPrefix}: Rename`,
              hint: "",
              run: () => {
                closeCommandModal();
                runContextAction("rename", actionPaths);
              },
            });
          }
          fileItems.push({
            label: `${selectionPrefix}: Trash`,
            hint: "",
            run: () => {
              closeCommandModal();
              runContextAction("trash", actionPaths);
            },
          });
          fileItems.push({
            label: `${selectionPrefix}: Delete`,
            hint: "",
            run: () => {
              closeCommandModal();
              runContextAction("delete", actionPaths);
            },
          });
        } else if (currentColumnPath) {
          pushDirectoryCommandSet(
            currentDirectoryItems,
            "Current Directory",
            currentColumnPath,
            currentDirectoryCapabilities,
          );
          pushContextCommandSet(
            currentDirectoryItems,
            "Current Directory",
            currentColumnPath,
            currentDirectoryCapabilities,
          );
        }

        return [...fileItems, ...currentDirectoryItems, ...selectedDirectoryItems, ...tabItems];
      };
      const filteredCommandItems = (query) => {
        const normalized = String(query || "").trim().toLowerCase();
        const source = getCommandItems();
        if (!normalized) return source;
        return source.filter((item) => item.label.toLowerCase().includes(normalized));
      };
      const renderCommandItems = () => {
        if (!commandList) return;
        const query = commandInput?.value || "";
        commandItems = filteredCommandItems(query);
        if (commandSelectionIndex < 0) commandSelectionIndex = 0;
        if (commandSelectionIndex >= commandItems.length) commandSelectionIndex = commandItems.length - 1;
        if (commandItems.length === 0) {
          commandSelectionIndex = 0;
          commandList.innerHTML = '<div class="command-modal-empty">No matching commands.</div>';
          return;
        }
        commandList.innerHTML = commandItems
          .map((item, index) => {
            const activeClass = index === commandSelectionIndex ? " is-active" : "";
            return `<button type="button" class="command-item${activeClass}" data-index="${index}">
              <span class="command-item-label">${item.label}</span>
              <span class="command-item-hint">${item.hint || ""}</span>
            </button>`;
          })
          .join("");
        const active = commandList.querySelector(`.command-item[data-index="${commandSelectionIndex}"]`);
        if (active) active.scrollIntoView({block: "nearest"});
      };
      const openCommandModal = (options = {}) => {
        if (!commandModal || !commandInput) return;
        closeSearchPalette();
        closeGoToModal();
        closeThemeSettingsModal({persist: false});
        const now = Date.now();
        commandModalIgnoreBackdropUntil = options.ignoreInitialBackdropClick ? now + 260 : 0;
        commandModalIgnoreInteractionsUntil = options.ignoreInitialBackdropClick ? now + 260 : 0;
        logNav("command modal open", {
          ignoreInitialBackdropClick: !!options.ignoreInitialBackdropClick,
          ignoreBackdropMs: Math.max(0, commandModalIgnoreBackdropUntil - now),
          ignoreInteractionsMs: Math.max(0, commandModalIgnoreInteractionsUntil - now),
        });
        commandModal.hidden = false;
        commandSelectionIndex = 0;
        commandInput.value = "";
        renderCommandItems();
        setTimeout(() => {
          commandInput.focus();
          commandInput.select();
        }, 0);
      };
      const executeSelectedCommand = () => {
        if (!commandItems.length) return;
        const selected = commandItems[commandSelectionIndex];
        if (!selected || typeof selected.run !== "function") return;
        selected.run();
      };
      if (searchInput) {
        searchInput.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            closeSearchPalette();
            return;
          }
          if (event.key === "ArrowDown") {
            event.preventDefault();
            event.stopPropagation();
            moveSearchSelection(1);
            return;
          }
          if (event.key === "ArrowUp") {
            event.preventDefault();
            event.stopPropagation();
            moveSearchSelection(-1);
            return;
          }
          if (event.key === "Enter") {
            event.preventDefault();
            event.stopPropagation();
            openSearchSelection();
          }
        });
        searchInput.addEventListener("input", () => {
          if (searchDebounceTimer) {
            clearTimeout(searchDebounceTimer);
          }
          searchDebounceTimer = setTimeout(() => {
            searchSelectedIndex = 0;
            searchSelectedPath = null;
            searchUserPicked = false;
            requestSearch(searchInput.value || "");
          }, 90);
        });
      }
      if (searchResults) {
        searchResults.addEventListener("click", (event) => {
          const item = event.target.closest(".files-search-item[data-path]");
          if (!item) return;
          const items = getSearchItems();
          const index = items.findIndex((candidate) => candidate === item);
          if (index >= 0) {
            searchUserPicked = true;
            searchSelectedIndex = index;
            searchSelectedPath = item.dataset.path || null;
          }
          openSearchSelection();
        });
      }
      if (searchRoot) {
        searchRoot.addEventListener("click", (event) => {
          if (event.target === searchRoot) {
            event.preventDefault();
            event.stopPropagation();
            closeSearchPalette();
          }
        });
      }
      if (gotoCancel) {
        gotoCancel.addEventListener("click", () => {
          closeGoToModal();
        });
      }
      if (gotoGo) {
        gotoGo.addEventListener("click", () => {
          submitGoToModal();
        });
      }
      if (gotoInput) {
        gotoInput.addEventListener("input", () => {
          if (gotoError) gotoError.textContent = "";
          requestGoToSuggestions();
        });
        gotoInput.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            closeGoToModal();
            return;
          }
          if (event.key === "ArrowDown") {
            if (!moveGoToSuggestionSelection(1)) return;
            event.preventDefault();
            event.stopPropagation();
            return;
          }
          if (event.key === "ArrowUp") {
            if (!moveGoToSuggestionSelection(-1)) return;
            event.preventDefault();
            event.stopPropagation();
            return;
          }
          if (
            event.key === "ArrowRight" &&
            !event.metaKey &&
            !event.ctrlKey &&
            !event.altKey
          ) {
            if (!completeGoToSuggestion()) return;
            event.preventDefault();
            event.stopPropagation();
            return;
          }
          if (event.key === "Enter") {
            event.preventDefault();
            event.stopPropagation();
            const items = getGoToSuggestionItems();
            const active = gotoSuggestionIndex >= 0 ? (items[gotoSuggestionIndex] || null) : null;
            const suggestedValue = String(active?.dataset?.value || "");
            if (suggestedValue) {
              gotoInput.value = suggestedValue;
            }
            submitGoToModal();
          }
        });
      }
      if (gotoSuggestions && gotoInput) {
        gotoSuggestions.addEventListener("mousedown", (event) => {
          event.preventDefault();
        });
        gotoSuggestions.addEventListener("mousemove", (event) => {
          const item = event.target.closest(".goto-suggestion-item[data-value]");
          if (!item) return;
          const items = getGoToSuggestionItems();
          const index = items.findIndex((candidate) => candidate === item);
          if (index < 0 || index === gotoSuggestionIndex) return;
          gotoSuggestionIndex = index;
          applyGoToSuggestionSelection();
        });
        gotoSuggestions.addEventListener("click", (event) => {
          const item = event.target.closest(".goto-suggestion-item[data-value]");
          if (!item) return;
          const value = String(item.dataset.value || "");
          if (!value) return;
          gotoInput.value = value;
          if (gotoError) gotoError.textContent = "";
          gotoInput.focus({preventScroll: true});
          if (typeof gotoInput.setSelectionRange === "function") {
            gotoInput.setSelectionRange(value.length, value.length);
          }
          requestGoToSuggestions({immediate: true});
        });
      }
      if (gotoModal) {
        gotoModal.addEventListener("click", (event) => {
          if (event.target === gotoModal) {
            closeGoToModal();
          }
        });
      }
      syncThemeSettingsInputs(
        currentThemeBaseColor,
        currentThemeHighlightColor,
        currentThemeLightnessOffset,
      );
      if (themeSettingsColor) {
        themeSettingsColor.addEventListener("input", () => {
          previewThemeSettingsAppearance({basePreferred: "picker"});
        });
        themeSettingsColor.addEventListener("change", () => {
          previewThemeSettingsAppearance({basePreferred: "picker"});
        });
      }
      if (themeSettingsHighlightColor) {
        themeSettingsHighlightColor.addEventListener("input", () => {
          previewThemeSettingsAppearance({highlightPreferred: "picker"});
        });
        themeSettingsHighlightColor.addEventListener("change", () => {
          previewThemeSettingsAppearance({highlightPreferred: "picker"});
        });
      }
      if (themeSettingsDepthRange) {
        themeSettingsDepthRange.addEventListener("input", () => {
          previewThemeSettingsAppearance();
        });
        themeSettingsDepthRange.addEventListener("change", () => {
          previewThemeSettingsAppearance();
        });
      }
      if (themeSettingsHex) {
        themeSettingsHex.addEventListener("input", () => {
          previewThemeSettingsAppearance({basePreferred: "hex"});
        });
        themeSettingsHex.addEventListener("change", () => {
          previewThemeSettingsAppearance({basePreferred: "hex"});
        });
        themeSettingsHex.addEventListener("keydown", async (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            closeThemeSettingsModal({persist: false});
            return;
          }
          if (event.key === "Enter") {
            event.preventDefault();
            event.stopPropagation();
            const saved = await persistThemeAppearance(
              readThemeSettingsBaseColor("hex"),
              readThemeSettingsHighlightColor("hex"),
              readThemeSettingsLightnessOffset(),
            );
            if (!saved) return;
            themeSettingsOriginalColor = currentThemeBaseColor;
            themeSettingsOriginalHighlightColor = currentThemeHighlightColor;
            themeSettingsOriginalLightnessOffset = currentThemeLightnessOffset;
            closeThemeSettingsModal({persist: true});
          }
        });
      }
      if (themeSettingsHighlightHex) {
        themeSettingsHighlightHex.addEventListener("input", () => {
          previewThemeSettingsAppearance({highlightPreferred: "hex"});
        });
        themeSettingsHighlightHex.addEventListener("change", () => {
          previewThemeSettingsAppearance({highlightPreferred: "hex"});
        });
        themeSettingsHighlightHex.addEventListener("keydown", async (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            closeThemeSettingsModal({persist: false});
            return;
          }
          if (event.key === "Enter") {
            event.preventDefault();
            event.stopPropagation();
            const saved = await persistThemeAppearance(
              readThemeSettingsBaseColor("hex"),
              readThemeSettingsHighlightColor("hex"),
              readThemeSettingsLightnessOffset(),
            );
            if (!saved) return;
            themeSettingsOriginalColor = currentThemeBaseColor;
            themeSettingsOriginalHighlightColor = currentThemeHighlightColor;
            themeSettingsOriginalLightnessOffset = currentThemeLightnessOffset;
            closeThemeSettingsModal({persist: true});
          }
        });
      }
      if (themeSettingsCancel) {
        themeSettingsCancel.addEventListener("click", () => {
          closeThemeSettingsModal({persist: false});
        });
      }
      if (themeSettingsReset) {
        themeSettingsReset.addEventListener("click", async () => {
          const saved = await persistThemeAppearance(
            defaultThemeBaseColor,
            defaultThemeHighlightColor,
            defaultThemeLightnessOffset,
          );
          if (!saved) return;
          themeSettingsOriginalColor = currentThemeBaseColor;
          themeSettingsOriginalHighlightColor = currentThemeHighlightColor;
          themeSettingsOriginalLightnessOffset = currentThemeLightnessOffset;
          closeThemeSettingsModal({persist: true});
        });
      }
      if (themeSettingsSave) {
        themeSettingsSave.addEventListener("click", async () => {
          const saved = await persistThemeAppearance(
            readThemeSettingsBaseColor("picker"),
            readThemeSettingsHighlightColor("picker"),
            readThemeSettingsLightnessOffset(),
          );
          if (!saved) return;
          themeSettingsOriginalColor = currentThemeBaseColor;
          themeSettingsOriginalHighlightColor = currentThemeHighlightColor;
          themeSettingsOriginalLightnessOffset = currentThemeLightnessOffset;
          closeThemeSettingsModal({persist: true});
        });
      }
      if (themeSettingsModal) {
        themeSettingsModal.addEventListener("click", (event) => {
          if (event.target === themeSettingsModal) {
            closeThemeSettingsModal({persist: false});
          }
        });
      }
      if (commandInput) {
        commandInput.addEventListener("input", () => {
          commandSelectionIndex = 0;
          renderCommandItems();
        });
        commandInput.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            closeCommandModal();
            return;
          }
          if (event.key === "ArrowDown") {
            event.preventDefault();
            event.stopPropagation();
            if (!commandItems.length) return;
            commandSelectionIndex = Math.min(commandSelectionIndex + 1, commandItems.length - 1);
            renderCommandItems();
            return;
          }
          if (event.key === "ArrowUp") {
            event.preventDefault();
            event.stopPropagation();
            if (!commandItems.length) return;
            commandSelectionIndex = Math.max(commandSelectionIndex - 1, 0);
            renderCommandItems();
            return;
          }
          if (event.key === "Enter") {
            event.preventDefault();
            event.stopPropagation();
            executeSelectedCommand();
          }
        });
      }
      if (commandList) {
        commandList.addEventListener("click", (event) => {
          if (Date.now() < commandModalIgnoreInteractionsUntil) {
            logNav("command list click ignored (initial interaction guard)");
            event.preventDefault();
            event.stopPropagation();
            return;
          }
          const target = event.target.closest(".command-item[data-index]");
          if (!target) return;
          const index = Number(target.dataset.index || -1);
          if (!Number.isFinite(index) || index < 0 || index >= commandItems.length) return;
          commandSelectionIndex = index;
          executeSelectedCommand();
        });
      }
      if (commandModal) {
        commandModal.addEventListener("click", (event) => {
          if (event.target === commandModal) {
            if (Date.now() < commandModalIgnoreBackdropUntil) {
              logNav("command modal backdrop click ignored (initial backdrop guard)");
              event.preventDefault();
              event.stopPropagation();
              return;
            }
            logNav("command modal backdrop click close");
            closeCommandModal();
          }
        });
      }
      const tabsBar = root.querySelector(".tabs-bar");
      const tabsList = root.querySelector(".tabs-list");
      let suppressTabClickUntil = 0;
      if (tabsBar) {
        tabsBar.addEventListener("mousedown", (event) => {
          if (event.button !== 0) return;
          if (event.target.closest(".tab-shell, .tab-plus, .tab-close")) return;
          const getCurrentWindow = window.__TAURI__?.window?.getCurrentWindow;
          if (typeof getCurrentWindow !== "function") return;
          const currentWindow = getCurrentWindow();
          if (!currentWindow || typeof currentWindow.startDragging !== "function") return;
          currentWindow.startDragging().catch((error) => {
            logNav("startDragging failed", {error: String(error)});
          });
        });
      }
      if (tabsList) {
        if (typeof window.Sortable === "function") {
          new window.Sortable(tabsList, {
            draggable: ".tab-shell[data-tab-id]",
            handle: ".tab-button",
            filter: ".tab-close",
            preventOnFilter: false,
            animation: 140,
            forceFallback: true,
            fallbackTolerance: 3,
            onStart: () => {
              suppressTabClickUntil = Date.now() + 500;
            },
            onEnd: (event) => {
              suppressTabClickUntil = Date.now() + 500;
              const moved = Number(event?.oldIndex) !== Number(event?.newIndex);
              if (!moved) return;
              const ordered = Array.from(tabsList.querySelectorAll(".tab-shell[data-tab-id]"))
                .map((tab) => tab.dataset.tabId || "")
                .filter((value) => value.length > 0);
              htmxCommandSwap("reorder_tabs", {tabIds: ordered.join(",")});
            },
          });
        }
      }
      root.addEventListener(
        "click",
        (event) => {
          if (Date.now() > suppressTabClickUntil) return;
          const tabShell = event.target.closest(".tab-shell[data-tab-id]");
          if (!tabShell) return;
          event.preventDefault();
          event.stopImmediatePropagation();
        },
        true,
      );
      const bindContextActionEvents = () => {
        const listen = window.__TAURI__?.event?.listen;
        if (typeof listen !== "function") return;
        const contextActionHandler = async (event) => {
          const action = event?.payload?.action || "";
          if (!action) return;
          const payloadPaths = Array.isArray(event?.payload?.paths)
            ? event.payload.paths.map((value) => String(value || "")).filter((value) => !!value)
            : [];
          const path = event?.payload?.path || "";
          const pendingPaths = consumePendingContextSelectionPaths();
          const targetPaths =
            payloadPaths.length > 0
              ? payloadPaths
              : pendingPaths.includes(path)
                ? pendingPaths
                : path
                  ? [path]
                  : [];
          if (targetPaths.length === 0) return;
          await runContextAction(action, targetPaths);
        };
        window.__filesContextActionHandler = contextActionHandler;
        if (!window.__filesContextActionBridgeReady) {
          window.__filesContextActionBridgeReady = Promise.resolve(
            listen("files-context-action", async (event) => {
              const handler = window.__filesContextActionHandler;
              if (typeof handler === "function") {
                await handler(event);
              }
            }),
          ).catch((error) => {
            logNav("context action listen failed", {error: String(error)});
            window.__filesContextActionBridgeReady = null;
            throw error;
          });
        }
      };
      bindContextActionEvents();
      const closeFilesModal = (result) => {
        if (!modalRoot || !modalResolve) return;
        modalRoot.hidden = true;
        modalConfirm.classList.remove("is-danger");
        const resolve = modalResolve;
        modalResolve = null;
        resolve(result);
      };
      const openFilesModal = ({
        title,
        message,
        confirmLabel,
        kind,
        initialValue = "",
        selectStemOnly = false,
      }) =>
        new Promise((resolve) => {
          if (!modalRoot) {
            resolve({confirmed: false, value: ""});
            return;
          }
          modalResolve = resolve;
          modalTitle.textContent = title || "";
          modalMessage.textContent = message || "";
          modalConfirm.textContent = confirmLabel || "OK";
          const wantsInput = kind === "prompt";
          modalInput.hidden = !wantsInput;
          modalInput.value = wantsInput ? initialValue : "";
          modalConfirm.classList.toggle("is-danger", kind === "danger");
          modalRoot.hidden = false;
          if (wantsInput) {
            setTimeout(() => {
              modalInput.focus();
              if (selectStemOnly) {
                const value = String(modalInput.value || "");
                const lastDot = value.lastIndexOf(".");
                if (lastDot > 0) {
                  modalInput.setSelectionRange(0, lastDot);
                } else {
                  modalInput.select();
                }
              } else {
                modalInput.select();
              }
            }, 0);
          } else {
            setTimeout(() => {
              modalConfirm.focus();
            }, 0);
          }
        });
      if (modalCancel) {
        modalCancel.addEventListener("click", () => {
          closeFilesModal({confirmed: false, value: ""});
        });
      }
      if (modalConfirm) {
        modalConfirm.addEventListener("click", () => {
          closeFilesModal({
            confirmed: true,
            value: modalInput.hidden ? "" : modalInput.value,
          });
        });
      }
      if (modalInput) {
        modalInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            closeFilesModal({confirmed: true, value: modalInput.value});
          } else if (event.key === "Escape") {
            event.preventDefault();
            closeFilesModal({confirmed: false, value: ""});
          }
        });
      }
      if (modalRoot) {
        modalRoot.addEventListener("mousedown", (event) => {
          if (event.target === modalRoot) {
            closeFilesModal({confirmed: false, value: ""});
          }
        });
      }

      const focusAndRevealRow = (row) => {
        if (!row) return;
        setFocusPath(row.dataset.path);
        row.focus({preventScroll: true});
        const columnIndex = Number(row.dataset.column || 0);
        setActiveColumn(columnIndex);
        ensureRowVisible(row);
        ensureColumnAndNextVisible(columnIndex);
      };
      root.addEventListener(
        "click",
        (event) => {
          const markdownLink = event.target.closest(".preview-markdown a[href]");
          if (markdownLink && root.contains(markdownLink)) {
            event.preventDefault();
            event.stopPropagation();
            openMarkdownLinkExternally(markdownLink).catch((error) => {
              logNav("markdown link open failed", {href: markdownLink.getAttribute("href"), error: String(error)});
            });
            return;
          }
          const row = mainRowFromEvent(event);
          if (!row) return;
          if (dragInProgress) return;
          const isToggle = !!(event.metaKey || event.ctrlKey);
          const isRange = !!event.shiftKey;
          const isDoublePrimaryClick = event.button === 0 && event.detail >= 2;
          if (!isRange && !isToggle && isDoublePrimaryClick && (row.dataset.isDir || "") !== "true") {
            logNav("row double-click capture", {path: row.dataset.path, column: row.dataset.column});
            focusAndRevealRow(row);
            setSingleSelection(row);
            event.preventDefault();
            event.stopImmediatePropagation();
            openCommandModal({ignoreInitialBackdropClick: true});
            return;
          }
          if (!isRange && !isToggle) return;
          focusAndRevealRow(row);
          if (isRange) {
            selectRangeToRow(row, isToggle);
          } else {
            toggleRowSelectedLocally(row);
          }
          event.preventDefault();
          event.stopImmediatePropagation();
        },
        true,
      );
      root.addEventListener("click", (event) => {
        const row = mainRowFromEvent(event);
        if (!row) return;
        if (dragInProgress) return;
        const isToggle = !!(event.metaKey || event.ctrlKey);
        const isRange = !!event.shiftKey;
        logNav("row click", {
          path: row.dataset.path,
          column: row.dataset.column,
          isDir: row.dataset.isDir,
          isToggle,
          isRange,
        });
        focusAndRevealRow(row);
        if (isRange || isToggle) {
          event.preventDefault();
          event.stopPropagation();
          if (isRange) {
            selectRangeToRow(row, isToggle);
          } else {
            toggleRowSelectedLocally(row);
          }
          return;
        }
        setSingleSelection(row);
      });
      root.addEventListener("click", (event) => {
        if (dragInProgress) return;
        if (event.defaultPrevented) return;
        if (event.button !== 0) return;
        if (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) return;
        if (mainRowFromEvent(event)) return;
        const body = event.target.closest(".column-body");
        if (!body) return;
        const column = body.closest(".finder-column");
        if (!isMainColumn(column)) return;
        const columnIndex = Number(column.dataset.column || 0);
        const columnPath = column.dataset.path || "";
        if (!columnPath) return;
        const columnRows = rowsByColumn.get(columnIndex) || [];
        const lastRow = columnRows[columnRows.length - 1] || null;
        if (lastRow) {
          const lastRowRect = lastRow.getBoundingClientRect();
          if (event.clientY < lastRowRect.bottom) return;
        }
        const directoryRow = rowByPath(columnPath);
        logNav("column empty-space click select directory", {
          column: column.dataset.column,
          path: columnPath,
          viaRow: !!directoryRow,
        });
        if (directoryRow) {
          focusAndRevealRow(directoryRow);
          setSingleSelection(directoryRow);
        } else {
          setFocusPath(columnPath);
          setActiveColumn(columnIndex);
          ensureColumnAndNextVisible(columnIndex);
        }
        htmxCommandSwap("navigate", {path: columnPath});
      });
      root.addEventListener("mousedown", (event) => {
        const row = mainRowFromEvent(event);
        if (!row) return;
        // Right-click is handled via context menu path; keep default for left button
        // so native dragging can start.
        if (event.button === 2) {
          event.preventDefault();
        }
      });

      root.addEventListener("contextmenu", (event) => {
        const row = mainRowFromEvent(event);
        if (row) {
          event.preventDefault();
          logNav("contextmenu", {path: row.dataset.path, column: row.dataset.column});
          const contextPaths = selectedPathsForContext(row.dataset.path || "");
          if (contextPaths.length === 1) {
            setSingleSelection(row);
          }
          focusAndRevealRow(row);
          setPendingContextSelectionPaths(contextPaths);
          showContextMenu({
            path: row.dataset.path,
            isDir: row.dataset.isDir === "true",
            selectionCount: contextPaths.length || 1,
            selectedPaths: contextPaths,
            x: event.clientX,
            y: event.clientY,
          });
          return;
        }

        const header = event.target.closest(".column-header");
        if (!header) return;
        event.preventDefault();
        const path = header.dataset.path || "";
        if (!path) return;
        logNav("contextmenu header", {path});
        setPendingContextSelectionPaths([]);
        showContextMenu({
          path,
          isDir: true,
          selectionCount: 1,
          x: event.clientX,
          y: event.clientY,
        });
        return;
      });

      root.addEventListener("contextmenu", (event) => {
        const row = mainRowFromEvent(event);
        const header = event.target.closest(".column-header");
        if (row || (header && isMainColumn(header.closest(".finder-column")))) return;
        const column = event.target.closest(".finder-column");
        if (!isMainColumn(column)) return;
        const path = column.dataset.path || "";
        if (!path) return;
        event.preventDefault();
        logNav("contextmenu column", {path, column: column.dataset.column});
        setPendingContextSelectionPaths([]);
        showContextMenu({
          path,
          isDir: true,
          selectionCount: 1,
          x: event.clientX,
          y: event.clientY,
        });
      });
      root.addEventListener("dragstart", (event) => {
        const foundRow = event.target.closest(".finder-row");
        const row = isMainRow(foundRow) ? foundRow : null;
        const preview = event.target.closest(".preview-pane");
        if (preview && preview.dataset.previewDraggable === "false") return;
        if (!row && !preview) return;
        if (!event.dataTransfer) return;
        dragInProgress = true;

        const isPreviewDrag = !!preview && !row;
        const source = row || preview;
        const path = source?.dataset?.path || source?.dataset?.previewPath || "";
        const name = source?.dataset?.name || source?.dataset?.previewName || "item";
        const isDir =
          source?.dataset?.isDir === "true" || source?.dataset?.previewIsDir === "true";
        if (!path) {
          dragInProgress = false;
          return;
        }
        let dragPaths = [path];
        const mime = guessMimeType(name, isDir);
        setFocusPath(path);
        const matchingRow = rows.find((candidate) => candidate.dataset.path === path) || null;
        if (matchingRow) {
          focusAndRevealRow(matchingRow);
          if (!matchingRow.classList.contains("is-selected")) {
            setSingleSelection(matchingRow);
          }
          dragPaths = selectedPathsForContext(path);
        } else if (isPreviewDrag) {
          setActiveColumn(columns.length - 1);
          ensureColumnAndNextVisible(columns.length - 1);
        }

        if (startPluginDrag(dragPaths, name, isDir, event)) {
          return;
        }

        const uris = dragPaths.map((value) => pathToFileUri(value)).filter((value) => !!value);
        const firstUri = uris[0] || "";
        event.dataTransfer.effectAllowed = "copyMove";
        event.dataTransfer.setData("text/plain", dragPaths.join("\n"));
        event.dataTransfer.setData("text/uri-list", `${uris.join("\r\n")}\r\n`);
        if (firstUri) {
          event.dataTransfer.setData("DownloadURL", `${mime}:${name}:${firstUri}`);
        }
        logNav("dragstart", {count: dragPaths.length, firstPath: dragPaths[0] || null, mime});
      });
      root.addEventListener("dragend", () => {
        setTimeout(() => {
          dragInProgress = false;
        }, 0);
      });
      document.addEventListener("keydown", (event) => {
        if (event.key !== "Alt") return;
        optionPressed = true;
        if (dropTargetColumn && externalDragPoint) {
          updateDropHint(externalDragPoint.x, externalDragPoint.y, getCurrentDropTargetDir());
        }
      });
      document.addEventListener("keyup", (event) => {
        if (event.key !== "Alt") return;
        optionPressed = false;
        if (dropTargetColumn && externalDragPoint) {
          updateDropHint(externalDragPoint.x, externalDragPoint.y, getCurrentDropTargetDir());
        }
      });

      root.addEventListener("focusin", (event) => {
        const row = mainRowFromEvent(event);
        if (!row) return;
        logScroll("focusin", {
          path: row.dataset.path,
          bodyTop: row.closest(".column-body")?.scrollTop ?? null,
        });
        setFocusPath(row.dataset.path);
        setActiveColumn(Number(row.dataset.column || 0));
      });

      for (const body of mainColumnBodies()) {
        body.addEventListener("scroll", () => {
          logScroll("column-body scroll", {top: body.scrollTop});
        });
      }

      const onKeyDown = (event) => {
        const lowered = String(event.key || "").toLowerCase();
        if (modalRoot && !modalRoot.hidden && event.key === "Escape") {
          event.preventDefault();
          event.stopPropagation();
          closeFilesModal({confirmed: false, value: ""});
          return;
        }
        if (modalRoot && !modalRoot.hidden) {
          return;
        }
        if (isThemeSettingsOpen() && event.key === "Escape") {
          event.preventDefault();
          event.stopPropagation();
          closeThemeSettingsModal({persist: false});
          return;
        }
        if (isThemeSettingsOpen()) {
          return;
        }
        if ((event.metaKey || event.ctrlKey) && event.altKey && (event.key === "ArrowLeft" || event.key === "ArrowRight")) {
          event.preventDefault();
          event.stopPropagation();
          const tabIds = Array.from(root.querySelectorAll(".tab-shell[data-tab-id]"))
            .map((tab) => tab.dataset.tabId || "")
            .filter((id) => id.length > 0);
          if (tabIds.length > 1) {
            const currentIndex = Math.max(0, tabIds.indexOf(activeTabId));
            const delta = event.key === "ArrowRight" ? 1 : -1;
            const nextIndex = (currentIndex + delta + tabIds.length) % tabIds.length;
            const targetId = tabIds[nextIndex];
            if (targetId && targetId !== activeTabId) {
              htmxCommandSwap("activate_tab", {tabId: targetId});
            }
          }
          return;
        }
        if ((event.metaKey || event.ctrlKey) && lowered === "n") {
          event.preventDefault();
          event.stopPropagation();
          openNewWindow();
          return;
        }
        if ((event.metaKey || event.ctrlKey) && lowered === "t") {
          event.preventDefault();
          event.stopPropagation();
          htmxCommandSwap("new_tab", {path: getFocusPath() || ""});
          return;
        }
        if ((event.metaKey || event.ctrlKey) && event.shiftKey && lowered === "p") {
          event.preventDefault();
          event.stopPropagation();
          openCommandModal();
          return;
        }
        if ((event.metaKey || event.ctrlKey) && lowered === "g") {
          event.preventDefault();
          event.stopPropagation();
          openGoToModal();
          return;
        }
        if ((event.metaKey || event.ctrlKey) && event.key === ",") {
          event.preventDefault();
          event.stopPropagation();
          openAppearanceWindow();
          return;
        }
        if (
          event.key === "/" &&
          !event.metaKey &&
          !event.ctrlKey &&
          !event.altKey &&
          !event.shiftKey &&
          !isCommandOpen() &&
          !isSearchOpen() &&
          !isGotoOpen() &&
          !isThemeSettingsOpen()
        ) {
          const activeTag = document.activeElement?.tagName || "";
          if (
            activeTag !== "INPUT" &&
            activeTag !== "TEXTAREA" &&
            activeTag !== "SELECT" &&
            !document.activeElement?.isContentEditable
          ) {
            event.preventDefault();
            event.stopPropagation();
            openGoToModal();
            return;
          }
        }
        if (isCommandOpen()) {
          if (commandInput && document.activeElement !== commandInput) {
            commandInput.focus({preventScroll: true});
          }
          if (event.key === "Escape") {
            event.preventDefault();
            closeCommandModal();
            return;
          }
          if (event.key === "ArrowDown") {
            event.preventDefault();
            if (!commandItems.length) return;
            commandSelectionIndex = Math.min(commandSelectionIndex + 1, commandItems.length - 1);
            renderCommandItems();
            return;
          }
          if (event.key === "ArrowUp") {
            event.preventDefault();
            if (!commandItems.length) return;
            commandSelectionIndex = Math.max(commandSelectionIndex - 1, 0);
            renderCommandItems();
            return;
          }
          if (event.key === "Enter") {
            event.preventDefault();
            executeSelectedCommand();
            return;
          }
          return;
        }
        if (isGotoOpen()) {
          if (event.key === "Escape") {
            event.preventDefault();
            closeGoToModal();
          }
          return;
        }
        const activeTag = document.activeElement?.tagName || "";
        const hasEditableFocus =
          activeTag === "INPUT" ||
          activeTag === "TEXTAREA" ||
          activeTag === "SELECT" ||
          !!document.activeElement?.isContentEditable;
        if (
          /^[a-z0-9]$/i.test(event.key || "") &&
          !event.metaKey &&
          !event.ctrlKey &&
          !event.altKey &&
          !isSearchOpen() &&
          !hasEditableFocus
        ) {
          event.preventDefault();
          event.stopPropagation();
          openSearchPalette(event.key);
          return;
        }
        if (
          event.key === "Enter" &&
          !event.metaKey &&
          !event.ctrlKey &&
          !event.altKey
        ) {
          if (!hasEditableFocus) {
            const currentRow = focusedRow();
            const commandDirectoryContext = selectedDirectoryPath() || currentDirectoryTitle() || rootPath;
            if (currentRow || commandDirectoryContext) {
              event.preventDefault();
              event.stopPropagation();
              openCommandModal();
              return;
            }
          }
        }
        if ((event.metaKey || event.ctrlKey) && lowered === "a") {
          if (hasEditableFocus) return;
          event.preventDefault();
          event.stopPropagation();
          const current = focusedRow();
          const activeColumnIndex = Number(
            current?.dataset?.column ??
              columns.find((column) => column.classList.contains("is-active"))?.dataset?.column ??
              0,
          );
          const columnRows = rowsByColumn.get(activeColumnIndex) || [];
          if (columnRows.length === 0) return;
          setSelectionByPaths(
            columnRows.map((row) => row.dataset.path || "").filter((value) => !!value),
            {
              anchorPath: current?.dataset?.path || columnRows[0].dataset.path || null,
              scopeColumn: activeColumnIndex,
            },
          );
          if (current) {
            focusAndRevealRow(current);
          } else {
            focusAndRevealRow(columnRows[0]);
          }
          return;
        }
        if ((event.metaKey || event.ctrlKey) && lowered === "w") {
          event.preventDefault();
          event.stopPropagation();
          closeTabOrWindow();
          return;
        }
        if ((event.metaKey || event.ctrlKey) && lowered === "p") {
          event.preventDefault();
          openSearchPalette();
          return;
        }
        if (isSearchOpen()) {
          if (searchInput && document.activeElement !== searchInput) {
            searchInput.focus({preventScroll: true});
          }
          if (event.key === "Escape") {
            event.preventDefault();
            closeSearchPalette();
            return;
          }
          if (event.key === "ArrowDown") {
            event.preventDefault();
            moveSearchSelection(1);
            return;
          }
          if (event.key === "ArrowUp") {
            event.preventDefault();
            moveSearchSelection(-1);
            return;
          }
          if (event.key === "Enter") {
            event.preventDefault();
            openSearchSelection();
            return;
          }
          return;
        }
        if (
          event.key === "." &&
          !event.metaKey &&
          !event.ctrlKey &&
          !event.altKey &&
          !event.shiftKey
        ) {
          if (!hasEditableFocus) {
            const directoryPath = selectedDirectoryPath() || currentDirectoryTitle();
            if (directoryPath) {
              event.preventDefault();
              event.stopPropagation();
              const rootIsUnderHome = rootPath === homePath || rootPath.startsWith(`${homePath}/`);
              const toggledRootPath = rootPath === "/" || rootIsUnderHome ? homePath : "/";
              htmxCommandSwap("set_tab_root", {path: directoryPath === rootPath ? toggledRootPath : directoryPath});
              return;
            }
          }
        }
        if (!["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) return;

        if (hasEditableFocus) return;
        event.preventDefault();

        const current =
          (root.contains(document.activeElement) &&
          document.activeElement.classList.contains("finder-row") &&
          isMainRow(document.activeElement)
            ? document.activeElement
            : null) ||
          rows.find((row) => row.dataset.path === getFocusPath()) ||
          rightmostSelected() ||
          null;
        logNav("keydown", {
          key: event.key,
          currentPath: current?.dataset?.path || null,
          currentColumn: current ? Number(current.dataset.column || 0) : null,
          currentIsDir: current?.dataset?.isDir || null,
        });
        if (zipHandleArrowKey(zipExplorerState, event, current)) {
          return;
        }
        if (!current) {
          if (event.key === "ArrowDown") {
            const firstColumnRow = (rowsByColumn.get(0) || [])[0] || null;
            if (!firstColumnRow) return;
            event.preventDefault();
            focusAndRevealRow(firstColumnRow);
            setSingleSelection(firstColumnRow);
            if (!event.shiftKey) {
              firstColumnRow.click();
            }
          }
          return;
        }

        const columnIndex = Number(current.dataset.column || 0);
        const columnRows = rowsByColumn.get(columnIndex) || [];
        const rowIndex = columnRows.findIndex((row) => row.dataset.path === current.dataset.path);
        let target = null;
        let shouldNavigate = false;

        if (event.key === "ArrowUp" && rowIndex > 0) {
          target = columnRows[rowIndex - 1];
          shouldNavigate = !event.shiftKey;
        } else if (event.key === "ArrowDown" && rowIndex >= 0 && rowIndex < columnRows.length - 1) {
          target = columnRows[rowIndex + 1];
          shouldNavigate = !event.shiftKey;
        } else if (event.key === "ArrowLeft" && columnIndex > 0) {
          target =
            selectedInColumn(columnIndex - 1) ||
            (rowsByColumn.get(columnIndex - 1) || [])[0] ||
            null;
          shouldNavigate = !event.shiftKey && !event.metaKey && !event.ctrlKey;
        } else if (event.key === "ArrowRight") {
          if (current.dataset.isDir === "true") {
            logNav("ArrowRight on dir", {
              path: current.dataset.path,
              column: current.dataset.column,
              action: "set pending right and click current",
            });
            window.__filesPendingRightFromPath = current.dataset.path;
            setFocusPath(current.dataset.path);
            current.click();
            return;
          } else {
            target =
              selectedInColumn(columnIndex + 1) ||
              (rowsByColumn.get(columnIndex + 1) || [])[0] ||
              null;
            shouldNavigate = !event.shiftKey && !event.metaKey && !event.ctrlKey;
          }
        }

        if (!target) return;

        focusAndRevealRow(target);
        if (event.key === "ArrowUp" || event.key === "ArrowDown") {
          if (event.shiftKey) {
            selectRangeToRow(target, false);
          } else {
            setSingleSelection(target);
          }
        } else if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
          setSingleSelection(target);
        }
        if (shouldNavigate) {
          target.click();
        } else {
          if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
            maybeCloseZipPreviewIfInactive();
          }
        }
      };

      const handleDomDragHover = (event) => {
        optionPressed = !!event.altKey;
        domDragPoint = {x: event.clientX, y: event.clientY};
        if (externalDragPaths.length > 0) {
          const dropTarget = setDropTargetByDragEvent(event) || setDropTargetByPoint(domDragPoint.x, domDragPoint.y);
          if (!dropTarget) {
            hideDropHint();
          } else {
            updateDropHint(domDragPoint.x, domDragPoint.y, dropTarget.targetDir || "");
          }
        } else if (dropTargetColumn && externalDragPoint) {
          updateDropHint(externalDragPoint.x, externalDragPoint.y, getCurrentDropTargetDir());
        }
      };
      window.addEventListener("dragover", handleDomDragHover);
      document.addEventListener("dragover", handleDomDragHover, true);
      root.addEventListener("dragover", handleDomDragHover, true);
      document.addEventListener("dragenter", handleDomDragHover, true);
      root.addEventListener("dragenter", handleDomDragHover, true);

      const bindExternalDrop = () => {
        const getCurrentWindow = window.__TAURI__?.window?.getCurrentWindow;
        if (typeof getCurrentWindow !== "function") return;
        const currentWindow = getCurrentWindow();
        if (!currentWindow || typeof currentWindow.onDragDropEvent !== "function") return;
        const invoke = window.__TAURI__?.core?.invoke;
        Promise.resolve(
          currentWindow.onDragDropEvent(async (event) => {
            const payload = event?.payload || {};
            const type = payload.type;
            if (type === "leave") {
              hideDropHint();
              clearDropTarget();
              externalDragPaths = [];
              domDragPoint = null;
              tauriPayloadYOffset = null;
              return;
            }
            if (type !== "over" && type !== "enter" && type !== "drop") {
              return;
            }

            if (typeof invoke === "function") {
              try {
                optionPressed = !!(await invoke("is_alt_pressed"));
              } catch (_error) {
                // Keep previous value if native modifier query fails.
              }
            }

            const sourcePaths = Array.isArray(payload.paths) ? payload.paths : [];
            if (sourcePaths.length > 0) {
              externalDragPaths = sourcePaths;
            }
            if (externalDragPaths.length === 0) return;
            const point = getBestDragPoint(payload.position);
            externalDragPoint = point;
            const dropTarget = setDropTargetByPoint(point.x, point.y);
            if (!dropTarget) {
              hideDropHint();
              return;
            }
            const targetDir = getCurrentDropTargetDir() || dropTarget.targetDir || "";
            updateDropHint(point.x, point.y, targetDir);
            if (type === "drop") {
              commitExternalDrop(targetDir, getDropOperation());
              domDragPoint = null;
              tauriPayloadYOffset = null;
            }
          }),
        )
          .then((unlisten) => {
            dragDropUnlisten = typeof unlisten === "function" ? unlisten : null;
          })
          .catch((error) => {
            logNav("onDragDropEvent bind failed", {error: String(error)});
          });
      };
      bindExternalDrop();
      startDirectoryPolling();

      document.addEventListener("keydown", onKeyDown);
      const themeAfterSettleHandler = (event) => {
        if (event?.target !== root) return;
        const nextTheme =
          normalizeHexColor(window.__filesThemeBaseColor || "") ||
          readStoredThemeBaseColor() ||
          normalizeHexColor(root.dataset.themeBaseColor || "") ||
          currentThemeBaseColor ||
          defaultThemeBaseColor;
        const nextHighlight =
          normalizeHexColor(window.__filesThemeHighlightColor || "") ||
          readStoredThemeHighlightColor() ||
          normalizeHexColor(root.dataset.themeHighlightColor || "") ||
          currentThemeHighlightColor ||
          defaultThemeHighlightColor;
        const nextLightnessOffset =
          normalizeThemeLightnessOffset(window.__filesThemeLightnessOffset) ??
          readStoredThemeLightnessOffset() ??
          normalizeThemeLightnessOffset(root.dataset.themeLightnessOffset || "") ??
          normalizeThemeLightnessOffset(currentThemeLightnessOffset) ??
          defaultThemeLightnessOffset;
        const appliedTheme = applyThemeAppearance(nextTheme, nextHighlight, nextLightnessOffset);
        currentThemeBaseColor = appliedTheme.baseColor;
        currentThemeHighlightColor = appliedTheme.highlightColor;
        currentThemeLightnessOffset = appliedTheme.lightnessOffset;
        syncThemeSettingsInputs(
          currentThemeBaseColor,
          currentThemeHighlightColor,
          currentThemeLightnessOffset,
        );
      };
      document.body.addEventListener("htmx:afterSettle", themeAfterSettleHandler);
      root.addEventListener("htmx:beforeRequest", () => {
        saveScrollState();
      });
      root.addEventListener(
        "htmx:beforeCleanupElement",
        (event) => {
          if (event.target !== root) {
            return;
          }
          if (previewPdfObjectUrl) {
            URL.revokeObjectURL(previewPdfObjectUrl);
            previewPdfObjectUrl = null;
          }
          if (previewGlbObjectUrl) {
            URL.revokeObjectURL(previewGlbObjectUrl);
            previewGlbObjectUrl = null;
          }
          if (previewVideoObjectUrl) {
            URL.revokeObjectURL(previewVideoObjectUrl);
            previewVideoObjectUrl = null;
          }
          clearSearchPreviewUrls();
          hideDropHint();
          clearDropTarget();
          if (typeof dragDropUnlisten === "function") {
            dragDropUnlisten();
            dragDropUnlisten = null;
          }
          if (typeof themeBaseChangedUnlisten === "function") {
            themeBaseChangedUnlisten();
            themeBaseChangedUnlisten = null;
          }
          if (typeof themeHighlightChangedUnlisten === "function") {
            themeHighlightChangedUnlisten();
            themeHighlightChangedUnlisten = null;
          }
          if (typeof themeLightnessChangedUnlisten === "function") {
            themeLightnessChangedUnlisten();
            themeLightnessChangedUnlisten = null;
          }
          if (window.__filesContextActionHandler) {
            window.__filesContextActionHandler = null;
          }
          // Keep native action handler alive across swaps; on_menu_event queues into window state.
          stopSearchPolling();
          stopDirectoryPolling();
          if (searchDebounceTimer) {
            clearTimeout(searchDebounceTimer);
            searchDebounceTimer = null;
          }
          if (typeof invoke === "function") {
            invoke("fuzzy_search_cancel").catch(() => {});
          }
          saveScrollState();
          document.removeEventListener("keydown", onKeyDown);
          document.body.removeEventListener("htmx:afterSettle", themeAfterSettleHandler);
          window.removeEventListener("dragover", handleDomDragHover);
          document.removeEventListener("dragover", handleDomDragHover, true);
          root.removeEventListener("dragover", handleDomDragHover, true);
          document.removeEventListener("dragenter", handleDomDragHover, true);
          root.removeEventListener("dragenter", handleDomDragHover, true);
        },
        {once: true},
      );

    })();
  </script>
</div>
