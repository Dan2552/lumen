<div id="main-root" class="files-root" data-active-tab-id="{{ active_tab_id }}">
  <script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
  <style>
    #main-root.files-root {
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      margin: 0;
      background: #2b313f;
      color: #c2c9d6;
      font-family: "SF Pro Text", "SF Pro Display", "Segoe UI", sans-serif;
      font-size: 13px;
      line-height: 1.4;
      letter-spacing: 0.01em;
    }

    .tabs-bar {
      display: flex;
      align-items: center;
      gap: 6px;
      min-height: 36px;
      padding: 4px 8px;
      background: rgba(26, 31, 41, 0.95);
      border-bottom: 1px solid #3a4151;
      overflow-x: auto;
      flex-shrink: 0;
    }

    .tab-button {
      height: 28px;
      min-width: 110px;
      max-width: 220px;
      padding: 0 10px;
      border: 1px solid #4b5364;
      border-radius: 7px;
      background: #3a4254;
      color: #c4cada;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      cursor: default;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      font-size: 12px;
      flex-shrink: 0;
    }

    .tab-shell {
      display: inline-flex;
      align-items: center;
      border: 1px solid #4b5364;
      border-radius: 7px;
      background: #3a4254;
      overflow: hidden;
      flex-shrink: 0;
      max-width: 260px;
    }

    .tab-shell.sortable-chosen {
      opacity: 0.72;
    }

    .tab-shell.sortable-ghost {
      box-shadow: inset 0 0 0 2px #74a9ff;
      opacity: 0.6;
    }

    .tab-shell.is-active {
      background: #596277;
      border-color: #6f7990;
    }

    .tab-shell .tab-button {
      border: none;
      background: transparent;
      max-width: 228px;
      border-radius: 0;
    }

    .tab-shell.is-active .tab-button {
      color: #f4f7ff;
    }

    .tab-close {
      width: 24px;
      min-width: 24px;
      height: 28px;
      border: none;
      border-left: 1px solid rgba(140, 150, 170, 0.35);
      background: transparent;
      color: #aeb6c7;
      font-size: 12px;
      cursor: default;
      padding: 0;
    }

    .tab-shell.is-active .tab-close {
      color: #dce5f7;
      border-left-color: rgba(170, 184, 209, 0.45);
    }

    .tab-plus {
      width: 28px;
      min-width: 28px;
      justify-content: center;
      font-size: 15px;
      padding: 0;
    }

    .finder-layout {
      display: flex;
      height: calc(100% - 36px);
      background: linear-gradient(180deg, #323949 0%, #2b313f 100%);
      border-right: 1px solid #404759;
      overflow-x: auto;
      overflow-y: hidden;
    }

    .finder-column {
      width: 280px;
      min-width: 240px;
      border-right: 1px solid #404759;
      background: rgba(38, 44, 58, 0.45);
      display: flex;
      flex-direction: column;
    }

    .finder-column.is-drop-target {
      background: rgba(48, 74, 120, 0.4);
      box-shadow: inset 0 0 0 1px rgba(118, 167, 255, 0.6);
    }

    .preview-pane {
      width: 720px;
      min-width: 560px;
      border-left: 1px solid #404759;
      background: rgba(30, 36, 48, 0.72);
      display: flex;
      flex-direction: column;
      cursor: default;
    }

    .preview-header {
      padding: 10px 12px;
      border-bottom: 1px solid #3b4354;
      background: rgba(28, 34, 46, 0.78);
    }

    .preview-title {
      color: #dce3f2;
      font-size: 13px;
      font-weight: 600;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .preview-subtitle {
      color: #97a1b6;
      font-size: 11px;
      margin-top: 2px;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .preview-body {
      flex: 1;
      overflow: auto;
      padding: 12px;
    }

    .preview-image {
      width: 100%;
      height: auto;
      object-fit: contain;
      border-radius: 8px;
      border: 1px solid #46506a;
      background: rgba(17, 22, 32, 0.8);
    }

    .preview-gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .preview-gallery-item {
      border: 1px solid #46506a;
      border-radius: 8px;
      overflow: hidden;
      background: rgba(17, 22, 32, 0.8);
      min-height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .preview-gallery-item img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    .preview-text {
      margin: 0;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
      color: #c8d0df;
      font-size: 12px;
      line-height: 1.5;
      background: rgba(17, 22, 32, 0.7);
      border: 1px solid #46506a;
      border-radius: 8px;
      padding: 10px;
      font-family: "SF Mono", "Menlo", "Consolas", monospace;
    }

    .preview-pdf {
      width: 100%;
      min-height: 520px;
      height: calc(100vh - 180px);
      border: 1px solid #46506a;
      border-radius: 8px;
      background: rgba(17, 22, 32, 0.8);
    }

    .preview-loading {
      color: #b8c5dc;
      font-size: 12px;
      margin-bottom: 8px;
    }

    .preview-model {
      width: 100%;
      min-height: 520px;
      height: calc(100vh - 180px);
      border: 1px solid #46506a;
      border-radius: 8px;
      background: radial-gradient(circle at 30% 20%, #3a445a 0%, #1a1f2d 100%);
    }

    .preview-video {
      width: 100%;
      min-height: 520px;
      height: calc(100vh - 180px);
      border: 1px solid #46506a;
      border-radius: 8px;
      background: rgba(17, 22, 32, 0.8);
    }

    .preview-note {
      margin-top: 10px;
      color: #95a1b8;
      font-size: 11px;
    }

    .column-header {
      padding: 8px 12px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9aa3b4;
      border-bottom: 1px solid #3b4354;
      background: rgba(34, 40, 52, 0.6);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .column-title {
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .column-sort-button {
      height: 20px;
      border-radius: 6px;
      border: 1px solid #4a556d;
      background: rgba(42, 49, 65, 0.95);
      color: #b5c0d8;
      font-size: 10px;
      letter-spacing: 0.03em;
      text-transform: none;
      padding: 0 7px;
      cursor: default;
      flex-shrink: 0;
    }

    .column-body {
      flex: 1;
      overflow-y: auto;
      padding: 6px 0;
      overflow-anchor: none;
    }

    .finder-row {
      width: 100%;
      appearance: none;
      background: transparent;
      border: 1px solid transparent;
      text-align: left;
      cursor: default;
      display: flex;
      align-items: center;
      gap: 10px;
      min-height: 30px;
      padding: 0 12px;
      white-space: nowrap;
    }

    .finder-row:focus-visible {
      outline: 1px solid #7fb3ff;
      outline-offset: -1px;
    }

    .finder-row.is-selected {
      background: #525a6c;
      border-color: #677189;
      border-left-width: 2px;
      color: #e9eef9;
    }

    .finder-column.is-active .finder-row.is-selected {
      background: #1f5fbf;
      border-color: #2f86e9;
      color: #f3f6ff;
    }

    .row-icon {
      width: 16px;
      font-size: 15px;
      color: #aab3c4;
      text-align: center;
      flex-shrink: 0;
    }

    .finder-row.is-selected .row-icon {
      color: #d3d9e5;
    }

    .finder-column.is-active .finder-row.is-selected .row-icon {
      color: #d9e6ff;
    }

    .row-name {
      flex: 1;
      min-width: 0;
      color: #d4dbe8;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    .row-name.is-file {
      color: #b8c0ce;
    }

    .row-disclosure {
      margin-left: auto;
      width: 14px;
      font-size: 13px;
      color: #8993a6;
      text-align: center;
      flex-shrink: 0;
    }

    .finder-row.is-selected .row-disclosure {
      color: #c9d0dd;
    }

    .finder-column.is-active .finder-row.is-selected .row-disclosure {
      color: #dce9ff;
    }

    .drop-hint {
      position: fixed;
      z-index: 1000;
      min-width: 220px;
      border: 1px solid #4a556f;
      border-radius: 8px;
      padding: 8px 10px;
      background: rgba(24, 30, 41, 0.98);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      color: #d9e2f4;
      font-size: 12px;
      pointer-events: none;
    }

    .drop-hint-title {
      color: #e4ecff;
      font-weight: 600;
    }

    .drop-hint-subtitle {
      margin-top: 2px;
      color: #9fb0cf;
      font-size: 11px;
    }

    .drop-hint[hidden] {
      display: none;
    }

    .files-modal[hidden] {
      display: none;
    }

    .files-modal {
      position: fixed;
      inset: 0;
      z-index: 1200;
      background: rgba(8, 11, 18, 0.55);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .files-modal-card {
      width: min(440px, 92vw);
      background: #2c3342;
      border: 1px solid #46516a;
      border-radius: 10px;
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.45);
      color: #d9e2f4;
      padding: 14px;
    }

    .files-modal-title {
      font-size: 13px;
      font-weight: 600;
      color: #f2f6ff;
    }

    .files-modal-message {
      margin-top: 8px;
      font-size: 12px;
      color: #b7c2d8;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .files-modal-input {
      margin-top: 10px;
      width: 100%;
      height: 30px;
      border-radius: 7px;
      border: 1px solid #4b5771;
      background: #1f2532;
      color: #eaf1ff;
      font: inherit;
      font-size: 12px;
      padding: 0 10px;
      box-sizing: border-box;
    }

    .files-modal-actions {
      margin-top: 12px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .files-modal-button {
      min-width: 84px;
      height: 28px;
      border-radius: 7px;
      border: 1px solid #53607b;
      background: #3c465c;
      color: #e4ecff;
      font: inherit;
      font-size: 12px;
      cursor: default;
    }

    .files-modal-button.is-danger {
      border-color: #85454b;
      background: #6f3037;
      color: #ffe4e7;
    }

    .goto-modal {
      position: fixed;
      inset: 0;
      background: rgba(9, 12, 18, 0.52);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 92px;
      z-index: 1500;
    }

    .goto-modal[hidden] {
      display: none !important;
    }

    .goto-modal-card {
      width: min(760px, calc(100vw - 40px));
      border-radius: 11px;
      border: 1px solid #4b5670;
      background: linear-gradient(180deg, #353d4e 0%, #2b3242 100%);
      box-shadow: 0 18px 48px rgba(0, 0, 0, 0.42);
      padding: 12px;
    }

    .goto-modal-title {
      color: #e9eefb;
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .goto-modal-input {
      width: 100%;
      height: 34px;
      border-radius: 7px;
      border: 1px solid #4f5a74;
      background: #1d2432;
      color: #e6edfd;
      font: inherit;
      font-size: 13px;
      padding: 0 10px;
      box-sizing: border-box;
      outline: none;
    }

    .goto-modal-error {
      min-height: 18px;
      margin-top: 6px;
      color: #ffb7bf;
      font-size: 12px;
    }

    .goto-modal-actions {
      margin-top: 8px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .goto-modal-button {
      min-width: 88px;
      height: 28px;
      border-radius: 7px;
      border: 1px solid #53607b;
      background: #3c465c;
      color: #e4ecff;
      font: inherit;
      font-size: 12px;
      cursor: default;
    }

    .files-search {
      position: fixed;
      inset: 0;
      z-index: 1400;
      background: rgba(10, 13, 20, 0.45);
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding-top: 56px;
    }

    .files-search[hidden] {
      display: none !important;
    }

    .files-search-panel {
      width: min(1220px, calc(100vw - 36px));
      max-height: calc(100vh - 110px);
      border: 1px solid #4a546b;
      border-radius: 11px;
      overflow: hidden;
      background: linear-gradient(180deg, #323a4a 0%, #2a3140 100%);
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
      display: flex;
      flex-direction: column;
    }

    .files-search-body {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    .files-search-input-row {
      height: 42px;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 0 10px;
      background: rgba(19, 23, 32, 0.9);
      border-bottom: 1px solid #3f485d;
    }

    .files-search-input {
      height: 42px;
      border: none;
      outline: none;
      padding: 0 2px;
      background: transparent;
      color: #e7ecf8;
      font: inherit;
      font-size: 14px;
      flex: 1;
      min-width: 0;
    }

    .files-search-inline-status {
      flex-shrink: 0;
      color: #95a1b8;
      font-size: 11px;
      min-width: 120px;
      text-align: right;
    }

    .files-search-results {
      overflow: auto;
      min-height: 72px;
      max-height: calc(100vh - 190px);
      padding: 6px;
      width: 52%;
      min-width: 340px;
      border-right: 1px solid #3f485d;
    }

    .files-search-status,
    .files-search-empty {
      color: #aab6cd;
      font-size: 12px;
      padding: 8px 10px;
    }

    .files-search-list {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .files-search-meta {
      display: none;
    }

    .files-search-preview {
      flex: 1;
      min-width: 320px;
      overflow: auto;
      background: rgba(28, 33, 45, 0.55);
    }

    .search-preview-pane {
      width: 100%;
      min-width: 0;
      border-left: none;
      height: 100%;
    }

    .files-search-preview-empty {
      color: #95a1b8;
      font-size: 12px;
      padding: 12px;
    }

    .files-search-item {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      min-height: 30px;
      border: 1px solid transparent;
      border-radius: 7px;
      background: transparent;
      color: #d4dbea;
      text-align: left;
      padding: 4px 8px;
      font: inherit;
      cursor: default;
    }

    .files-search-item.is-active {
      background: linear-gradient(180deg, #2f6fce 0%, #2060c4 100%);
      border-color: rgba(147, 192, 255, 0.85);
      color: #eaf2ff;
    }

    .files-search-item-name {
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .files-search-item-path {
      margin-left: auto;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: #8f9bb3;
      font-size: 11px;
      max-width: 56%;
    }

    .files-search-item.is-active .files-search-item-path {
      color: #cfe0ff;
    }
  </style>

  <div class="tabs-bar">
    {% for tab in tabs %}
    <div class="tab-shell {% if tab.is_active %}is-active{% endif %}" data-tab-id="{{ tab.id }}">
    <button
      class="tab-button"
      type="button"
      hx-get="command/activate_tab"
      hx-target="#main-root"
      hx-swap="outerHTML"
      hx-vals='{"tabId": {{ tab.id | json_encode }} }'
    >{{ tab.title }}</button>
    <button
      class="tab-close"
      type="button"
      hx-get="command/close_tab"
      hx-target="#main-root"
      hx-swap="outerHTML"
      hx-vals='{"tabId": {{ tab.id | json_encode }} }'
    >x</button>
    </div>
    {% endfor %}
    <button
      class="tab-button tab-plus"
      type="button"
      hx-get="command/new_tab"
      hx-target="#main-root"
      hx-swap="outerHTML"
      hx-vals='{"path": {{ active_path | json_encode }} }'
    >+</button>
  </div>

  <div class="finder-layout">
    {% for column in columns %}
      {% set column_index = loop.index0 %}
      {% include "files/_column.html" %}
    {% endfor %}

    {% if preview %}
    <aside
      class="preview-pane"
      draggable="{% if preview.kind == "glb" %}false{% else %}true{% endif %}"
      data-preview-path="{{ preview.path }}"
      data-preview-name="{{ preview.title }}"
      data-preview-icon="{{ preview.icon }}"
      data-preview-is-dir="false"
      data-preview-draggable="{% if preview.kind == "glb" %}false{% else %}true{% endif %}"
    >
      <div class="preview-header">
        <div class="preview-title">{{ preview.title }}</div>
        <div class="preview-subtitle">{{ preview.subtitle }}</div>
      </div>
      <div class="preview-body">
        {% if preview.kind == "image" and preview.image_data_url %}
          <img class="preview-image" src="{{ preview.image_data_url }}" alt="{{ preview.title }}">
        {% elif (preview.kind == "affinity" or preview.kind == "blend") and preview.affinity_image_data_urls %}
          {% if preview.affinity_image_data_urls | length == 1 and preview.image_data_url %}
            <img class="preview-image" src="{{ preview.image_data_url }}" alt="{{ preview.title }}">
          {% else %}
            <div class="preview-gallery">
              {% for image_data_url in preview.affinity_image_data_urls %}
                <div class="preview-gallery-item">
                  <img src="{{ image_data_url }}" alt="{{ preview.title }} thumbnail {{ loop.index }}">
                </div>
              {% endfor %}
            </div>
          {% endif %}
        {% elif preview.kind == "pdf" and preview.pdf_path %}
          <div class="preview-loading" id="preview-pdf-status">Loading PDF preview...</div>
          <iframe class="preview-pdf" data-pdf-path="{{ preview.pdf_path }}" title="{{ preview.title }}" hidden></iframe>
        {% elif preview.kind == "glb" and preview.glb_path %}
          <div class="preview-loading" id="preview-glb-status">Loading 3D preview...</div>
          <model-viewer
            class="preview-model"
            data-glb-path="{{ preview.glb_path }}"
            camera-controls
            touch-action="pan-y"
            interaction-prompt="none"
            shadow-intensity="1"
            exposure="1"
            hidden
          ></model-viewer>
        {% elif preview.kind == "video" and preview.video_path %}
          <div class="preview-loading" id="preview-video-status">Loading video preview...</div>
          <video class="preview-video" data-video-path="{{ preview.video_path }}" controls preload="metadata" hidden></video>
        {% elif preview.kind == "text" and preview.text_head %}
          <pre class="preview-text">{{ preview.text_head }}</pre>
        {% endif %}
        {% if preview.note %}
          <div class="preview-note">{{ preview.note }}</div>
        {% endif %}
      </div>
    </aside>
    {% endif %}
  </div>
  <div id="drop-hint" class="drop-hint" hidden>
    <div class="drop-hint-title" id="drop-hint-title"></div>
    <div class="drop-hint-subtitle" id="drop-hint-subtitle"></div>
  </div>
  <div id="files-modal" class="files-modal" hidden>
    <div class="files-modal-card" role="dialog" aria-modal="true" aria-labelledby="files-modal-title">
      <div class="files-modal-title" id="files-modal-title"></div>
      <div class="files-modal-message" id="files-modal-message"></div>
      <input
        id="files-modal-input"
        class="files-modal-input"
        type="text"
        spellcheck="false"
        autocorrect="off"
        autocapitalize="off"
        autocomplete="off"
        hidden
      />
      <div class="files-modal-actions">
        <button id="files-modal-cancel" class="files-modal-button" type="button">Cancel</button>
        <button id="files-modal-confirm" class="files-modal-button" type="button">OK</button>
      </div>
    </div>
  </div>
  <div id="files-search" class="files-search" hidden>
    <div class="files-search-panel">
      <div class="files-search-input-row">
        <input
          id="files-search-input"
          class="files-search-input"
          type="text"
          placeholder="Search files..."
          spellcheck="false"
          autocorrect="off"
          autocapitalize="off"
          autocomplete="off"
        />
        <div id="files-search-inline-status" class="files-search-inline-status"></div>
      </div>
      <div class="files-search-body">
        <div id="files-search-results" class="files-search-results"></div>
        <div id="files-search-preview" class="files-search-preview">
          <div class="files-search-preview-empty">No preview</div>
        </div>
      </div>
    </div>
  </div>
  <div id="goto-modal" class="goto-modal" hidden>
    <div class="goto-modal-card" role="dialog" aria-modal="true" aria-labelledby="goto-modal-title">
      <div class="goto-modal-title" id="goto-modal-title">Go to location</div>
      <input
        id="goto-modal-input"
        class="goto-modal-input"
        type="text"
        placeholder="/absolute/path"
        spellcheck="false"
        autocorrect="off"
        autocapitalize="off"
        autocomplete="off"
      />
      <div id="goto-modal-error" class="goto-modal-error"></div>
      <div class="goto-modal-actions">
        <button id="goto-modal-cancel" class="goto-modal-button" type="button">Cancel</button>
        <button id="goto-modal-go" class="goto-modal-button" type="button">Go</button>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const root = document.getElementById("main-root");
      if (!root) return;
      let previewPdfObjectUrl = null;
      let previewGlbObjectUrl = null;
      let previewVideoObjectUrl = null;
      const base64ToBytes = (base64) => {
        const raw = atob(base64);
        const bytes = new Uint8Array(raw.length);
        for (let i = 0; i < raw.length; i += 1) {
          bytes[i] = raw.charCodeAt(i);
        }
        return bytes;
      };
      const pdfIframe = root.querySelector(".preview-pdf[data-pdf-path]");
      if (pdfIframe) {
        const rawPath = pdfIframe.getAttribute("data-pdf-path") || "";
        const status = root.querySelector("#preview-pdf-status");
        const invoke = window.__TAURI__?.core?.invoke;
        if (rawPath && typeof invoke === "function") {
          invoke("load_pdf_preview_data", {path: rawPath})
            .then((base64) => {
              if (previewPdfObjectUrl) {
                URL.revokeObjectURL(previewPdfObjectUrl);
                previewPdfObjectUrl = null;
              }
              const bytes = base64ToBytes(base64);
              const blob = new Blob([bytes], {type: "application/pdf"});
              previewPdfObjectUrl = URL.createObjectURL(blob);
              pdfIframe.src = previewPdfObjectUrl;
              pdfIframe.hidden = false;
              if (status) status.textContent = "";
            })
            .catch((error) => {
              if (status) status.textContent = String(error || "Failed to load PDF preview.");
              pdfIframe.hidden = true;
            });
        } else if (status) {
          status.textContent = "Failed to load PDF preview.";
        }
      }
      const glbViewer = root.querySelector(".preview-model[data-glb-path]");
      if (glbViewer) {
        const rawPath = glbViewer.getAttribute("data-glb-path") || "";
        const status = root.querySelector("#preview-glb-status");
        const invoke = window.__TAURI__?.core?.invoke;
        const revealViewer = () => {
          glbViewer.hidden = false;
          if (status) status.textContent = "";
        };
        if (rawPath && typeof invoke === "function") {
          invoke("load_glb_preview_data", {path: rawPath})
            .then((payload) => {
              if (previewGlbObjectUrl) {
                URL.revokeObjectURL(previewGlbObjectUrl);
                previewGlbObjectUrl = null;
              }
              const base64 = payload?.base64 || "";
              const mimeType = payload?.mime_type || "model/gltf-binary";
              if (!base64) {
                throw new Error("Empty model preview payload.");
              }
              const bytes = base64ToBytes(base64);
              const blob = new Blob([bytes], {type: mimeType});
              previewGlbObjectUrl = URL.createObjectURL(blob);
              glbViewer.src = previewGlbObjectUrl;
              if (customElements.get("model-viewer")) {
                revealViewer();
              } else {
                customElements.whenDefined("model-viewer").then(revealViewer).catch(() => {
                  if (status) status.textContent = "3D viewer failed to initialize.";
                });
              }
            })
            .catch((error) => {
              if (status) status.textContent = String(error || "Failed to load 3D preview.");
              glbViewer.hidden = true;
            });
        } else if (status) {
          status.textContent = "Failed to load 3D preview.";
        }
      }
      const videoPlayer = root.querySelector(".preview-video[data-video-path]");
      if (videoPlayer) {
        const rawPath = videoPlayer.getAttribute("data-video-path") || "";
        const status = root.querySelector("#preview-video-status");
        const invoke = window.__TAURI__?.core?.invoke;
        if (rawPath && typeof invoke === "function") {
          invoke("load_video_preview_data", {path: rawPath})
            .then((payload) => {
              if (previewVideoObjectUrl) {
                URL.revokeObjectURL(previewVideoObjectUrl);
                previewVideoObjectUrl = null;
              }
              const base64 = payload?.base64 || "";
              const mimeType = payload?.mime_type || "video/mp4";
              if (!base64) {
                throw new Error("Empty video preview payload.");
              }
              const bytes = base64ToBytes(base64);
              const blob = new Blob([bytes], {type: mimeType});
              previewVideoObjectUrl = URL.createObjectURL(blob);
              videoPlayer.src = previewVideoObjectUrl;
              videoPlayer.hidden = false;
              if (status) status.textContent = "";
            })
            .catch((error) => {
              if (status) status.textContent = String(error || "Failed to load video preview.");
              videoPlayer.hidden = true;
            });
        } else if (status) {
          status.textContent = "Failed to load video preview.";
        }
      }
      const activeTabId = root.dataset.activeTabId || "default";
      const DEBUG_NAV = true;
      const DEBUG_SCROLL = true;
      const logNav = (...args) => {
        if (!DEBUG_NAV) return;
        console.debug("[files-nav]", ...args);
      };
      const logScroll = (...args) => {
        if (!DEBUG_SCROLL) return;
        console.debug("[files-scroll]", ...args);
      };
      window.__filesFocusPathByTab = window.__filesFocusPathByTab || {};
      const getFocusPath = () => window.__filesFocusPathByTab[activeTabId] || null;
      const setFocusPath = (path) => {
        logNav("setFocusPath", {activeTabId, path});
        window.__filesFocusPathByTab[activeTabId] = path;
      };

      const rows = Array.from(root.querySelectorAll(".finder-row"));
      if (rows.length === 0) return;
      let dragInProgress = false;
      const columns = Array.from(root.querySelectorAll(".finder-column"));
      const layout = root.querySelector(".finder-layout");
      const previewPane = layout?.querySelector(".preview-pane") || null;
      const dropHint = root.querySelector("#drop-hint");
      const dropHintTitle = root.querySelector("#drop-hint-title");
      const dropHintSubtitle = root.querySelector("#drop-hint-subtitle");
      const modalRoot = root.querySelector("#files-modal");
      const modalTitle = root.querySelector("#files-modal-title");
      const modalMessage = root.querySelector("#files-modal-message");
      const modalInput = root.querySelector("#files-modal-input");
      const modalCancel = root.querySelector("#files-modal-cancel");
      const modalConfirm = root.querySelector("#files-modal-confirm");
      const searchRoot = root.querySelector("#files-search");
      const searchInput = root.querySelector("#files-search-input");
      const searchResults = root.querySelector("#files-search-results");
      const searchPreview = root.querySelector("#files-search-preview");
      const searchInlineStatus = root.querySelector("#files-search-inline-status");
      const gotoModal = root.querySelector("#goto-modal");
      const gotoInput = root.querySelector("#goto-modal-input");
      const gotoError = root.querySelector("#goto-modal-error");
      const gotoCancel = root.querySelector("#goto-modal-cancel");
      const gotoGo = root.querySelector("#goto-modal-go");
      let dropTargetColumn = null;
      let externalDragPaths = [];
      let externalDragPoint = null;
      let dragDropUnlisten = null;
      let contextActionUnlisten = null;
      let optionPressed = false;
      let modalResolve = null;
      let searchPollTimer = null;
      let searchDebounceTimer = null;
      let searchSelectedIndex = 0;
      let searchSelectedPath = null;
      let searchUserPicked = false;
      let searchPreviewPath = null;
      const searchPreviewObjectUrls = [];
      let lastSearchResultsHtml = "";
      window.__filesScrollStateByTab = window.__filesScrollStateByTab || {};
      const getScrollState = () => window.__filesScrollStateByTab[activeTabId] || null;
      const saveScrollState = () => {
        const state = {
          layoutLeft: layout?.scrollLeft || 0,
          columnTops: {},
        };
        for (const body of root.querySelectorAll(".column-body")) {
          const column = body.closest(".finder-column");
          const columnIndex = Number(column?.dataset?.column || 0);
          state.columnTops[columnIndex] = body.scrollTop;
        }
        window.__filesScrollStateByTab[activeTabId] = state;
        logScroll("saveScrollState", state);
      };
      const restoreScrollState = () => {
        const state = getScrollState();
        if (!state) return;
        if (layout && Number.isFinite(state.layoutLeft)) {
          layout.scrollLeft = state.layoutLeft;
        }
        for (const body of root.querySelectorAll(".column-body")) {
          const column = body.closest(".finder-column");
          const columnIndex = Number(column?.dataset?.column || 0);
          const top = state.columnTops?.[columnIndex];
          if (Number.isFinite(top)) {
            body.scrollTop = top;
          }
        }
        logScroll("restoreScrollState", state);
      };
      logNav("init", {
        activeTabId,
        rows: rows.length,
        columns: columns.length,
        rememberedFocus: getFocusPath(),
        pendingRightFromPath: window.__filesPendingRightFromPath || null,
      });

      const selectedRows = rows.filter((row) => row.classList.contains("is-selected"));
      const rowsByColumn = new Map();

      for (const row of rows) {
        const column = Number(row.dataset.column || 0);
        if (!rowsByColumn.has(column)) rowsByColumn.set(column, []);
        rowsByColumn.get(column).push(row);
      }

      const rightmostSelected = () =>
        [...selectedRows].sort((a, b) => Number(a.dataset.column) - Number(b.dataset.column)).at(-1);
      const selectedInColumn = (columnIndex) =>
        selectedRows.find((row) => Number(row.dataset.column) === columnIndex) || null;

      const setActiveColumn = (columnIndex) => {
        for (const column of columns) {
          column.classList.toggle("is-active", Number(column.dataset.column) === columnIndex);
        }
      };
      const ensureColumnAndNextVisible = (columnIndex) => {
        if (!layout) return;
        const currentColumn = columns.find((column) => Number(column.dataset.column || 0) === columnIndex);
        if (!currentColumn) return;
        const nextColumn = columns.find((column) => Number(column.dataset.column || 0) === columnIndex + 1);
        const targetColumn = nextColumn || previewPane || currentColumn;
        const currentLeft = currentColumn.offsetLeft;
        const targetRight = targetColumn.offsetLeft + targetColumn.offsetWidth;
        const viewportLeft = layout.scrollLeft;
        const viewportRight = viewportLeft + layout.clientWidth;
        const margin = 8;
        let desiredLeft = viewportLeft;

        if (currentLeft < viewportLeft + margin) {
          desiredLeft = currentLeft - margin;
        }
        if (targetRight > desiredLeft + layout.clientWidth - margin) {
          desiredLeft = targetRight - layout.clientWidth + margin;
        }

        const maxLeft = Math.max(0, layout.scrollWidth - layout.clientWidth);
        desiredLeft = Math.max(0, Math.min(maxLeft, desiredLeft));
        if (desiredLeft !== layout.scrollLeft) {
          layout.scrollLeft = desiredLeft;
        }
      };
      const ensureRowVisible = (row) => {
        if (!row) return;
        const body = row.closest(".column-body");
        if (!body) return;
        const viewTop = body.scrollTop;
        const viewBottom = viewTop + body.clientHeight;
        const rowTop = row.offsetTop;
        const rowBottom = rowTop + row.offsetHeight;
        const bodyRect = body.getBoundingClientRect();
        const rowRect = row.getBoundingClientRect();
        const topInset = 2;
        const bottomInset = 2;
        const isVisibleByRect =
          rowRect.top >= bodyRect.top + topInset && rowRect.bottom <= bodyRect.bottom - bottomInset;

        // If the row is already fully visible, never touch scroll.
        if (isVisibleByRect) {
          logScroll("ensureRowVisible noop-visible", {
            path: row.dataset.path,
            rowTop,
            rowBottom,
            viewTop,
            viewBottom,
            rowRectTop: rowRect.top,
            rowRectBottom: rowRect.bottom,
            bodyRectTop: bodyRect.top,
            bodyRectBottom: bodyRect.bottom,
          });
          return;
        }

        if (rowRect.top < bodyRect.top + topInset) {
          const delta = rowRect.top - (bodyRect.top + topInset);
          const next = Math.max(0, body.scrollTop + delta);
          logScroll("ensureRowVisible up", {
            path: row.dataset.path,
            from: body.scrollTop,
            to: next,
          });
          body.scrollTop = next;
        } else if (rowRect.bottom > bodyRect.bottom - bottomInset) {
          const delta = rowRect.bottom - (bodyRect.bottom - bottomInset);
          const next = Math.max(0, body.scrollTop + delta);
          logScroll("ensureRowVisible down", {
            path: row.dataset.path,
            from: body.scrollTop,
            to: next,
          });
          body.scrollTop = next;
        }
      };
      const setRowSelectedLocally = (row) => {
        const columnIndex = Number(row.dataset.column || 0);
        const columnRows = rowsByColumn.get(columnIndex) || [];
        for (const candidate of columnRows) {
          candidate.classList.remove("is-selected");
        }
        row.classList.add("is-selected");
      };
      const clearDropTarget = () => {
        if (!dropTargetColumn) return;
        dropTargetColumn.classList.remove("is-drop-target");
        dropTargetColumn = null;
      };
      const getDropOperation = () => (optionPressed ? "move" : "copy");
      const hideDropHint = () => {
        externalDragPoint = null;
        if (dropHint) {
          dropHint.hidden = true;
        }
      };
      const getClientPointFromDrop = (position) => {
        return {
          x: Number(position?.x || 0),
          y: Number(position?.y || 0),
        };
      };
      const findColumnAtPoint = (clientX, clientY) => {
        for (const column of columns) {
          const rect = column.getBoundingClientRect();
          if (
            clientX >= rect.left &&
            clientX <= rect.right &&
            clientY >= rect.top &&
            clientY <= rect.bottom
          ) {
            return column;
          }
        }
        return null;
      };
      const setDropTargetByPoint = (clientX, clientY) => {
        const column = findColumnAtPoint(clientX, clientY);
        if (!column || !column.dataset.path) {
          clearDropTarget();
          return null;
        }
        if (dropTargetColumn !== column) {
          clearDropTarget();
          dropTargetColumn = column;
          dropTargetColumn.classList.add("is-drop-target");
        }
        return column;
      };
      const updateDropHint = (clientX, clientY, targetDir) => {
        if (!dropHint || !dropHintTitle || !dropHintSubtitle) return;
        dropHint.hidden = false;
        const margin = 10;
        const hintWidth = dropHint.offsetWidth || 260;
        const hintHeight = dropHint.offsetHeight || 56;
        const maxX = window.innerWidth - hintWidth - margin;
        const maxY = window.innerHeight - hintHeight - margin;
        const left = Math.max(margin, Math.min(maxX, clientX + 8));
        const top = Math.max(margin, Math.min(maxY, clientY + 8));
        dropHint.style.left = `${left}px`;
        dropHint.style.top = `${top}px`;

        const operation = getDropOperation();
        const count = externalDragPaths.length;
        const destination = targetDir.split("/").filter(Boolean).at(-1) || targetDir;
        const verb = operation === "move" ? "Move" : "Copy";
        const noun = count === 1 ? "item" : "items";
        dropHintTitle.textContent = `Drop here to ${verb.toLowerCase()} ${count} ${noun} to ${destination}`;
        dropHintSubtitle.textContent =
          operation === "copy" ? "Hold Option to move instead" : "Release Option to copy instead";
      };
      const refreshAfterDrop = (targetDir) => {
        if (window.htmx?.ajax) {
          window.htmx.ajax("GET", "command/navigate", {
            target: "#main-root",
            swap: "outerHTML",
            values: {path: targetDir},
          });
        }
      };
      const commitExternalDrop = async (targetDir, operation) => {
        if (!targetDir || externalDragPaths.length === 0) return;
        const invoke = window.__TAURI__?.core?.invoke;
        if (typeof invoke !== "function") return;
        hideDropHint();
        clearDropTarget();
        try {
          await invoke("drop_files_into_directory", {
            targetDir,
            sourcePaths: externalDragPaths,
            operation,
          });
          logNav("drop_files_into_directory success", {
            targetDir,
            operation,
            count: externalDragPaths.length,
          });
          refreshAfterDrop(targetDir);
        } catch (error) {
          logNav("drop_files_into_directory failed", {
            targetDir,
            operation,
            error: String(error),
          });
        }
      };
      const dragIconCache = new Map();
      const pathToFileUri = (path) => {
        if (!path) return "";
        if (path.startsWith("file://")) return path;
        const normalized = path.replace(/\\/g, "/");
        const encoded = normalized
          .split("/")
          .map((segment, index) => (index === 0 ? segment : encodeURIComponent(segment)))
          .join("/");
        if (encoded.startsWith("/")) return `file://${encoded}`;
        return `file:///${encoded}`;
      };
      const guessMimeType = (name, isDir) => {
        if (isDir) return "inode/directory";
        const ext = (name.split(".").pop() || "").toLowerCase();
        if (["png"].includes(ext)) return "image/png";
        if (["jpg", "jpeg"].includes(ext)) return "image/jpeg";
        if (["gif"].includes(ext)) return "image/gif";
        if (["webp"].includes(ext)) return "image/webp";
        if (["svg"].includes(ext)) return "image/svg+xml";
        if (["txt", "md", "json", "toml", "rs", "js", "ts", "html", "css"].includes(ext)) return "text/plain";
        if (["pdf"].includes(ext)) return "application/pdf";
        return "application/octet-stream";
      };
      const clampName = (name) => {
        const limit = 34;
        if (!name || name.length <= limit) return name || "item";
        return `${name.slice(0, limit - 1)}\u2026`;
      };
      const pngDataUrlToBytes = (dataUrl) => {
        const encoded = dataUrl.split(",")[1] || "";
        const raw = atob(encoded);
        const bytes = new Array(raw.length);
        for (let i = 0; i < raw.length; i += 1) {
          bytes[i] = raw.charCodeAt(i);
        }
        return bytes;
      };
      const makeRowDragIcon = (name, isDir) => {
        const key = `${isDir ? "d" : "f"}:${name}`;
        if (dragIconCache.has(key)) {
          return dragIconCache.get(key);
        }
        const width = 260;
        const height = 32;
        const radius = 6;
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return null;
        }
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = "#1f5fbf";
        ctx.strokeStyle = "#2f86e9";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(radius, 0);
        ctx.lineTo(width - radius, 0);
        ctx.quadraticCurveTo(width, 0, width, radius);
        ctx.lineTo(width, height - radius);
        ctx.quadraticCurveTo(width, height, width - radius, height);
        ctx.lineTo(radius, height);
        ctx.quadraticCurveTo(0, height, 0, height - radius);
        ctx.lineTo(0, radius);
        ctx.quadraticCurveTo(0, 0, radius, 0);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Draw a small folder/file glyph so the drag image matches row semantics.
        ctx.strokeStyle = isDir ? "#9cc8ff" : "#c7dafc";
        ctx.fillStyle = "transparent";
        ctx.lineWidth = 1.5;
        if (isDir) {
          ctx.beginPath();
          ctx.moveTo(11, 11);
          ctx.lineTo(16, 11);
          ctx.lineTo(18, 9);
          ctx.lineTo(24, 9);
          ctx.quadraticCurveTo(25.5, 9, 25.5, 10.5);
          ctx.lineTo(25.5, 20);
          ctx.quadraticCurveTo(25.5, 21.5, 24, 21.5);
          ctx.lineTo(11, 21.5);
          ctx.quadraticCurveTo(9.5, 21.5, 9.5, 20);
          ctx.lineTo(9.5, 12.5);
          ctx.quadraticCurveTo(9.5, 11, 11, 11);
          ctx.closePath();
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.moveTo(11.5, 9.5);
          ctx.lineTo(20, 9.5);
          ctx.lineTo(24.5, 14);
          ctx.lineTo(24.5, 22.5);
          ctx.lineTo(11.5, 22.5);
          ctx.closePath();
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(20, 9.5);
          ctx.lineTo(20, 14);
          ctx.lineTo(24.5, 14);
          ctx.stroke();
        }

        ctx.fillStyle = "#f3f6ff";
        ctx.font = '600 13px "SF Pro Text", "Segoe UI", sans-serif';
        ctx.textBaseline = "middle";
        ctx.fillText(clampName(name), 30, Math.round(height / 2) + 0.5);

        const bytes = pngDataUrlToBytes(canvas.toDataURL("image/png"));
        dragIconCache.set(key, bytes);
        return bytes;
      };
      const startPluginDrag = (path, name, isDir, event) => {
        const startDrag = window.__TAURI__?.drag?.startDrag;
        if (typeof startDrag !== "function") return false;
        event.preventDefault();
        optionPressed = !!event.altKey;
        const icon = makeRowDragIcon(name || "item", isDir) || [];
        startDrag({
          item: [path],
          icon,
        })
          .then(() => {
            logNav("plugin dragstart", {path});
          })
          .catch((error) => {
            logNav("plugin dragstart failed", {path, error: String(error)});
          })
          .finally(() => {
            dragInProgress = false;
          });
        return true;
      };

      let initialFromRight = null;
      let shouldCommitInitialFromRight = false;
      if (window.__filesPendingRightFromPath) {
        const anchor = rows.find(
          (row) =>
            row.dataset.path === window.__filesPendingRightFromPath && row.classList.contains("is-selected"),
        );
        logNav("pendingRight anchor", {
          pending: window.__filesPendingRightFromPath,
          found: !!anchor,
          anchorColumn: anchor ? Number(anchor.dataset.column || 0) : null,
        });
        if (anchor) {
          const nextColumn = Number(anchor.dataset.column || 0) + 1;
          initialFromRight = selectedInColumn(nextColumn) || (rowsByColumn.get(nextColumn) || [])[0] || null;
          if (initialFromRight && !initialFromRight.classList.contains("is-selected")) {
            shouldCommitInitialFromRight = true;
          }
          logNav("pendingRight resolved", {
            nextColumn,
            initialFromRightPath: initialFromRight?.dataset?.path || null,
            shouldCommitInitialFromRight,
          });
        }
        window.__filesPendingRightFromPath = null;
      }

      const focusedRow =
        root.contains(document.activeElement) && document.activeElement.classList.contains("finder-row")
          ? document.activeElement
          : null;
      const rememberedRow = rows.find((row) => row.dataset.path === getFocusPath());
      const initialRow = initialFromRight || focusedRow || rightmostSelected() || rememberedRow || null;
      restoreScrollState();

      if (initialRow) {
        logNav("initialRow", {
          path: initialRow.dataset.path,
          column: Number(initialRow.dataset.column || 0),
          shouldCommitInitialFromRight,
        });
        setFocusPath(initialRow.dataset.path);
        initialRow.focus({preventScroll: true});
        const initialColumnIndex = Number(initialRow.dataset.column || 0);
        setActiveColumn(initialColumnIndex);
        ensureRowVisible(initialRow);
        ensureColumnAndNextVisible(initialColumnIndex);
        if (shouldCommitInitialFromRight) {
          setRowSelectedLocally(initialRow);
          setTimeout(() => {
            if (document.body.contains(initialRow)) {
              const path = initialRow.dataset.path;
              logNav("auto-commit navigate", {path, column: initialRow.dataset.column});
              if (window.htmx?.ajax) {
                window.htmx.ajax("GET", "command/navigate", {
                  target: "#main-root",
                  swap: "outerHTML",
                  values: {path},
                });
              } else {
                initialRow.click();
              }
            }
          }, 0);
        }
      }

      const pendingContextMenu = window.__filesPendingContextMenu;
      if (pendingContextMenu) {
        window.__filesPendingContextMenu = null;
        const invoke = window.__TAURI__?.core?.invoke;
        if (typeof invoke === "function") {
          invoke("show_file_context_menu", {
            path: pendingContextMenu.path,
            isDir: !!pendingContextMenu.isDir,
            x: pendingContextMenu.x,
            y: pendingContextMenu.y,
          }).catch(() => {});
        }
      }

      const showContextMenu = (payload) => {
        const invoke = window.__TAURI__?.core?.invoke;
        if (typeof invoke !== "function") return;
        invoke("show_file_context_menu", {
          path: payload.path,
          isDir: !!payload.isDir,
          x: payload.x,
          y: payload.y,
        }).catch(() => {});
      };
      const htmxCommandSwap = (command, values) =>
        window.htmx?.ajax?.("GET", `command/${command}`, {
          target: "#main-root",
          swap: "outerHTML",
          values,
        });
      const invoke = window.__TAURI__?.core?.invoke;
      const isSearchOpen = () => !!searchRoot && !searchRoot.hidden;
      const isGotoOpen = () => !!gotoModal && !gotoModal.hidden;
      const setSearchStatus = (message) => {
        if (searchInlineStatus) {
          searchInlineStatus.textContent = String(message || "");
        }
      };
      const clearSearchPreviewUrls = () => {
        while (searchPreviewObjectUrls.length > 0) {
          const url = searchPreviewObjectUrls.pop();
          if (url) URL.revokeObjectURL(url);
        }
      };
      const initSearchPreviewMedia = () => {
        if (!searchPreview || typeof invoke !== "function") return;
        const pdfIframe = searchPreview.querySelector(".preview-pdf[data-pdf-path]");
        if (pdfIframe) {
          const rawPath = pdfIframe.getAttribute("data-pdf-path") || "";
          const status = searchPreview.querySelector("#search-preview-pdf-status");
          if (rawPath) {
            invoke("load_pdf_preview_data", {path: rawPath})
              .then((base64) => {
                const bytes = base64ToBytes(base64);
                const blob = new Blob([bytes], {type: "application/pdf"});
                const url = URL.createObjectURL(blob);
                searchPreviewObjectUrls.push(url);
                pdfIframe.src = url;
                pdfIframe.hidden = false;
                if (status) status.textContent = "";
              })
              .catch((error) => {
                if (status) status.textContent = String(error || "Failed to load PDF preview.");
              });
          }
        }
        const glbViewer = searchPreview.querySelector(".preview-model[data-glb-path]");
        if (glbViewer) {
          const rawPath = glbViewer.getAttribute("data-glb-path") || "";
          const status = searchPreview.querySelector("#search-preview-glb-status");
          if (rawPath) {
            invoke("load_glb_preview_data", {path: rawPath})
              .then((payload) => {
                const base64 = payload?.base64 || "";
                const mimeType = payload?.mime_type || "model/gltf-binary";
                if (!base64) throw new Error("Empty model payload.");
                const bytes = base64ToBytes(base64);
                const blob = new Blob([bytes], {type: mimeType});
                const url = URL.createObjectURL(blob);
                searchPreviewObjectUrls.push(url);
                glbViewer.src = url;
                const reveal = () => {
                  glbViewer.hidden = false;
                  if (status) status.textContent = "";
                };
                if (customElements.get("model-viewer")) {
                  reveal();
                } else {
                  customElements.whenDefined("model-viewer").then(reveal).catch(() => {
                    if (status) status.textContent = "3D viewer failed to initialize.";
                  });
                }
              })
              .catch((error) => {
                if (status) status.textContent = String(error || "Failed to load 3D preview.");
              });
          }
        }
        const videoPlayer = searchPreview.querySelector(".preview-video[data-video-path]");
        if (videoPlayer) {
          const rawPath = videoPlayer.getAttribute("data-video-path") || "";
          const status = searchPreview.querySelector("#search-preview-video-status");
          if (rawPath) {
            invoke("load_video_preview_data", {path: rawPath})
              .then((payload) => {
                const base64 = payload?.base64 || "";
                const mimeType = payload?.mime_type || "video/mp4";
                if (!base64) throw new Error("Empty video payload.");
                const bytes = base64ToBytes(base64);
                const blob = new Blob([bytes], {type: mimeType});
                const url = URL.createObjectURL(blob);
                searchPreviewObjectUrls.push(url);
                videoPlayer.src = url;
                videoPlayer.hidden = false;
                if (status) status.textContent = "";
              })
              .catch((error) => {
                if (status) status.textContent = String(error || "Failed to load video preview.");
              });
          }
        }
      };
      const requestSearchPreview = (path) => {
        if (!searchPreview || typeof invoke !== "function") return;
        if (!path) {
          searchPreviewPath = null;
          clearSearchPreviewUrls();
          searchPreview.innerHTML = '<div class="files-search-preview-empty">No preview</div>';
          return;
        }
        if (searchPreviewPath === path) return;
        searchPreviewPath = path;
        invoke("fuzzy_search_preview", {path})
          .then((html) => {
            if (!isSearchOpen() || !searchPreview || searchPreviewPath !== path) return;
            clearSearchPreviewUrls();
            searchPreview.innerHTML = String(html || '<div class="files-search-preview-empty">No preview</div>');
            initSearchPreviewMedia();
          })
          .catch(() => {
            if (!searchPreview || searchPreviewPath !== path) return;
            clearSearchPreviewUrls();
            searchPreview.innerHTML = '<div class="files-search-preview-empty">No preview</div>';
          });
      };
      const updateSearchInlineStatusFromResults = () => {
        if (!searchInlineStatus || !searchResults) return;
        const meta = searchResults.querySelector(".files-search-meta");
        if (!meta) {
          searchInlineStatus.textContent = "";
          return;
        }
        const running = (meta.getAttribute("data-running") || "false") === "true";
        const scanned = Number(meta.getAttribute("data-scanned") || 0);
        searchInlineStatus.textContent = running ? `Searching... ${scanned}` : "";
      };
      if (searchRoot) {
        searchRoot.hidden = true;
      }
      const getSearchItems = () =>
        searchResults ? Array.from(searchResults.querySelectorAll(".files-search-item[data-path]")) : [];
      const applySearchSelection = () => {
        const items = getSearchItems();
        if (items.length === 0) {
          searchSelectedIndex = 0;
          searchSelectedPath = null;
          searchUserPicked = false;
          requestSearchPreview(null);
          return;
        }
        if (!searchUserPicked) {
          searchSelectedPath = null;
          items.forEach((item) => item.classList.remove("is-active"));
          requestSearchPreview(null);
          return;
        }
        if (searchSelectedPath) {
          const byPathIndex = items.findIndex((item) => (item.dataset.path || "") === searchSelectedPath);
          if (byPathIndex >= 0) {
            searchSelectedIndex = byPathIndex;
          }
        }
        if (searchSelectedIndex < 0) searchSelectedIndex = 0;
        if (searchSelectedIndex >= items.length) searchSelectedIndex = items.length - 1;
        items.forEach((item, index) => {
          item.classList.toggle("is-active", index === searchSelectedIndex);
        });
        const active = items[searchSelectedIndex];
        if (active) {
          searchSelectedPath = active.dataset.path || null;
          requestSearchPreview(searchSelectedPath);
          active.scrollIntoView({block: "nearest"});
          const path = active.dataset.path || "";
          if (path) {
            const row = rows.find((candidate) => candidate.dataset.path === path) || null;
            if (row) {
              setFocusPath(path);
              setRowSelectedLocally(row);
              setActiveColumn(Number(row.dataset.column || 0));
            }
          }
        }
      };
      const moveSearchSelection = (delta) => {
        const items = getSearchItems();
        if (items.length === 0) return;
        if (!searchUserPicked) {
          searchUserPicked = true;
          searchSelectedIndex = delta >= 0 ? 0 : items.length - 1;
          searchSelectedPath = null;
          applySearchSelection();
          return;
        }
        searchSelectedIndex += delta;
        searchSelectedPath = null;
        applySearchSelection();
      };
      const pollSearchResults = () => {
        if (!isSearchOpen() || !searchResults || typeof invoke !== "function") return;
        invoke("fuzzy_search_results")
          .then((html) => {
            if (!isSearchOpen() || !searchResults) return;
            const nextHtml = String(html || "");
            if (nextHtml !== lastSearchResultsHtml) {
              searchResults.innerHTML = nextHtml;
              lastSearchResultsHtml = nextHtml;
            }
            updateSearchInlineStatusFromResults();
            applySearchSelection();
          })
          .catch((error) => {
            setSearchStatus(`Search poll failed: ${String(error || "unknown error")}`);
            logNav("fuzzy_search_results failed", {error: String(error)});
          });
      };
      const startSearchPolling = () => {
        if (!searchResults) return;
        if (searchPollTimer) clearInterval(searchPollTimer);
        searchPollTimer = setInterval(() => {
          pollSearchResults();
        }, 220);
      };
      const stopSearchPolling = () => {
        if (searchPollTimer) {
          clearInterval(searchPollTimer);
          searchPollTimer = null;
        }
      };
      const requestSearch = (query) => {
        if (typeof invoke !== "function") return;
        invoke("fuzzy_search_start", {query}).then(() => {
          pollSearchResults();
        }).catch((error) => {
          setSearchStatus(`Search failed: ${String(error || "unknown error")}`);
          logNav("fuzzy_search_start failed", {error: String(error)});
        });
      };
      const closeSearchPalette = () => {
        if (!searchRoot) return;
        searchRoot.hidden = true;
        stopSearchPolling();
        if (searchDebounceTimer) {
          clearTimeout(searchDebounceTimer);
          searchDebounceTimer = null;
        }
        if (typeof invoke === "function") {
          invoke("fuzzy_search_cancel").catch(() => {});
        }
        lastSearchResultsHtml = "";
        searchSelectedPath = null;
        searchUserPicked = false;
        searchPreviewPath = null;
        clearSearchPreviewUrls();
        if (searchPreview) {
          searchPreview.innerHTML = '<div class="files-search-preview-empty">No preview</div>';
        }
        setSearchStatus("");
      };
      const closeGoToModal = () => {
        if (!gotoModal) return;
        gotoModal.hidden = true;
        if (gotoError) gotoError.textContent = "";
      };
      const openGoToModal = () => {
        if (!gotoModal || !gotoInput) return;
        gotoModal.hidden = false;
        if (gotoError) gotoError.textContent = "";
        gotoInput.value = getFocusPath() || "";
        setTimeout(() => {
          gotoInput.focus();
          gotoInput.select();
        }, 0);
      };
      const submitGoToModal = () => {
        if (!gotoInput || typeof invoke !== "function") return;
        const value = String(gotoInput.value || "").trim();
        if (!value) {
          if (gotoError) gotoError.textContent = "Enter an absolute path.";
          gotoInput.focus();
          return;
        }
        invoke("validate_location_path", {path: value})
          .then((normalizedPath) => {
            closeGoToModal();
            htmxCommandSwap("go_to_location", {path: normalizedPath});
          })
          .catch((error) => {
            if (gotoError) gotoError.textContent = String(error || "Invalid path.");
            gotoInput.focus();
            gotoInput.select();
          });
      };
      const openSearchPalette = () => {
        if (!searchRoot || !searchInput) return;
        searchRoot.hidden = false;
        searchInput.value = "";
        searchSelectedIndex = 0;
        searchSelectedPath = null;
        searchUserPicked = false;
        searchPreviewPath = null;
        clearSearchPreviewUrls();
        if (searchPreview) {
          searchPreview.innerHTML = '<div class="files-search-preview-empty">No preview</div>';
        }
        lastSearchResultsHtml = "";
        setSearchStatus("");
        requestSearch("");
        startSearchPolling();
        pollSearchResults();
        setTimeout(() => {
          searchInput.focus();
          searchInput.select();
        }, 0);
      };
      const openSearchSelection = () => {
        if (!searchUserPicked) return;
        const items = getSearchItems();
        if (items.length === 0) return;
        const selected = items[searchSelectedIndex] || items[0];
        const path = selected?.dataset?.path || "";
        if (!path) return;
        setFocusPath(path);
        closeSearchPalette();
        htmxCommandSwap("navigate", {path});
      };
      if (searchInput) {
        searchInput.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            closeSearchPalette();
            return;
          }
          if (event.key === "ArrowDown") {
            event.preventDefault();
            event.stopPropagation();
            moveSearchSelection(1);
            return;
          }
          if (event.key === "ArrowUp") {
            event.preventDefault();
            event.stopPropagation();
            moveSearchSelection(-1);
            return;
          }
          if (event.key === "Enter") {
            event.preventDefault();
            event.stopPropagation();
            openSearchSelection();
          }
        });
        searchInput.addEventListener("input", () => {
          if (searchDebounceTimer) {
            clearTimeout(searchDebounceTimer);
          }
          searchDebounceTimer = setTimeout(() => {
            searchSelectedIndex = 0;
            searchSelectedPath = null;
            searchUserPicked = false;
            requestSearch(searchInput.value || "");
          }, 90);
        });
      }
      if (searchResults) {
        searchResults.addEventListener("click", (event) => {
          const item = event.target.closest(".files-search-item[data-path]");
          if (!item) return;
          const items = getSearchItems();
          const index = items.findIndex((candidate) => candidate === item);
          if (index >= 0) {
            searchUserPicked = true;
            searchSelectedIndex = index;
            searchSelectedPath = item.dataset.path || null;
          }
          openSearchSelection();
        });
      }
      if (searchRoot) {
        searchRoot.addEventListener("click", (event) => {
          if (event.target === searchRoot) {
            event.preventDefault();
            event.stopPropagation();
            closeSearchPalette();
          }
        });
      }
      if (gotoCancel) {
        gotoCancel.addEventListener("click", () => {
          closeGoToModal();
        });
      }
      if (gotoGo) {
        gotoGo.addEventListener("click", () => {
          submitGoToModal();
        });
      }
      if (gotoInput) {
        gotoInput.addEventListener("input", () => {
          if (gotoError) gotoError.textContent = "";
        });
        gotoInput.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
            closeGoToModal();
            return;
          }
          if (event.key === "Enter") {
            event.preventDefault();
            event.stopPropagation();
            submitGoToModal();
          }
        });
      }
      if (gotoModal) {
        gotoModal.addEventListener("click", (event) => {
          if (event.target === gotoModal) {
            closeGoToModal();
          }
        });
      }
      const tabsBar = root.querySelector(".tabs-bar");
      let suppressTabClickUntil = 0;
      if (tabsBar) {
        if (typeof window.Sortable === "function") {
          new window.Sortable(tabsBar, {
            draggable: ".tab-shell[data-tab-id]",
            handle: ".tab-button",
            filter: ".tab-close",
            preventOnFilter: false,
            animation: 140,
            forceFallback: true,
            fallbackTolerance: 3,
            onStart: () => {
              suppressTabClickUntil = Date.now() + 500;
            },
            onEnd: (event) => {
              suppressTabClickUntil = Date.now() + 500;
              const moved = Number(event?.oldIndex) !== Number(event?.newIndex);
              if (!moved) return;
              const ordered = Array.from(tabsBar.querySelectorAll(".tab-shell[data-tab-id]"))
                .map((tab) => tab.dataset.tabId || "")
                .filter((value) => value.length > 0);
              htmxCommandSwap("reorder_tabs", {tabIds: ordered.join(",")});
            },
          });
        }
      }
      root.addEventListener(
        "click",
        (event) => {
          if (Date.now() > suppressTabClickUntil) return;
          const tabShell = event.target.closest(".tab-shell[data-tab-id]");
          if (!tabShell) return;
          event.preventDefault();
          event.stopImmediatePropagation();
        },
        true,
      );
      const bindContextActionEvents = () => {
        const listen = window.__TAURI__?.event?.listen;
        if (typeof listen !== "function") return;
        Promise.resolve(
          listen("files-context-action", async (event) => {
            const action = event?.payload?.action || "";
            const path = event?.payload?.path || "";
            if (!action || !path) return;
            logNav("context action", {action, path});
            const name = path.split("/").filter(Boolean).at(-1) || path;

            const normalized = String(action).toLowerCase();
            if (normalized.includes("open_default")) {
              logNav("context open default", {path});
              const invoke = window.__TAURI__?.core?.invoke;
              if (typeof invoke === "function") {
                invoke("open_in_default", {path}).catch((error) => {
                  logNav("open_in_default failed", {path, error: String(error)});
                });
              }
              return;
            }
            if (normalized.includes("open_zed")) {
              logNav("context open zed", {path});
              const invoke = window.__TAURI__?.core?.invoke;
              if (typeof invoke === "function") {
                invoke("open_in_zed", {path}).catch((error) => {
                  logNav("open_in_zed failed", {path, error: String(error)});
                });
              }
              return;
            }
            if (normalized.includes("open_warp")) {
              logNav("context open warp", {path});
              const invoke = window.__TAURI__?.core?.invoke;
              if (typeof invoke === "function") {
                invoke("open_in_warp", {path}).catch((error) => {
                  logNav("open_in_warp failed", {path, error: String(error)});
                });
              }
              return;
            }
            if (normalized.includes("open_github_desktop")) {
              logNav("context open github desktop", {path});
              const invoke = window.__TAURI__?.core?.invoke;
              if (typeof invoke === "function") {
                invoke("open_in_github_desktop", {path}).catch((error) => {
                  logNav("open_in_github_desktop failed", {path, error: String(error)});
                });
              }
              return;
            }
            if (normalized.includes("set_tab_root")) {
              logNav("context set tab root", {path});
              htmxCommandSwap("set_tab_root", {path});
              return;
            }
            if (normalized.includes("rename")) {
              const result = await openFilesModal({
                title: "Rename",
                message: "Enter a new name:",
                confirmLabel: "Rename",
                kind: "prompt",
                initialValue: name,
              });
              if (!result.confirmed) return;
              const trimmed = String(result.value || "").trim();
              if (!trimmed || trimmed === name) return;
              logNav("context rename submit", {path, newName: trimmed});
              htmxCommandSwap("rename_path", {path, newName: trimmed});
              return;
            }
            if (normalized.includes("new_dir")) {
              const result = await openFilesModal({
                title: "Create Directory",
                message: "Directory name:",
                confirmLabel: "Create",
                kind: "prompt",
                initialValue: "New Folder",
              });
              if (!result.confirmed) return;
              const trimmed = String(result.value || "").trim();
              if (!trimmed) return;
              logNav("context create dir", {path, name: trimmed});
              htmxCommandSwap("create_directory", {parentPath: path, name: trimmed});
              return;
            }
            if (normalized.includes("new_file")) {
              const result = await openFilesModal({
                title: "Create File",
                message: "File name (empty text file):",
                confirmLabel: "Create",
                kind: "prompt",
                initialValue: "untitled.txt",
              });
              if (!result.confirmed) return;
              const trimmed = String(result.value || "").trim();
              if (!trimmed) return;
              logNav("context create file", {path, name: trimmed});
              htmxCommandSwap("create_file", {parentPath: path, name: trimmed});
              return;
            }

            if (normalized.includes("trash")) {
              const result = await openFilesModal({
                title: "Move to Trash",
                message: `Move "${name}" to Trash?`,
                confirmLabel: "Trash",
                kind: "confirm",
              });
              if (!result.confirmed) return;
              logNav("context trash confirm", {path});
              htmxCommandSwap("trash_path", {path});
              return;
            }

            if (normalized.includes("delete")) {
              const result = await openFilesModal({
                title: "Delete Permanently",
                message: `Delete "${name}" permanently?\nThis cannot be undone.`,
                confirmLabel: "Delete",
                kind: "danger",
              });
              if (!result.confirmed) return;
              logNav("context delete confirm", {path});
              htmxCommandSwap("delete_path", {path});
            }
          }),
        )
          .then((unlisten) => {
            contextActionUnlisten = typeof unlisten === "function" ? unlisten : null;
          })
          .catch((error) => {
            logNav("context action listen failed", {error: String(error)});
          });
      };
      bindContextActionEvents();
      const closeFilesModal = (result) => {
        if (!modalRoot || !modalResolve) return;
        modalRoot.hidden = true;
        modalConfirm.classList.remove("is-danger");
        const resolve = modalResolve;
        modalResolve = null;
        resolve(result);
      };
      const openFilesModal = ({title, message, confirmLabel, kind, initialValue = ""}) =>
        new Promise((resolve) => {
          if (!modalRoot) {
            resolve({confirmed: false, value: ""});
            return;
          }
          modalResolve = resolve;
          modalTitle.textContent = title || "";
          modalMessage.textContent = message || "";
          modalConfirm.textContent = confirmLabel || "OK";
          const wantsInput = kind === "prompt";
          modalInput.hidden = !wantsInput;
          modalInput.value = wantsInput ? initialValue : "";
          modalConfirm.classList.toggle("is-danger", kind === "danger");
          modalRoot.hidden = false;
          if (wantsInput) {
            setTimeout(() => {
              modalInput.focus();
              modalInput.select();
            }, 0);
          } else {
            setTimeout(() => {
              modalConfirm.focus();
            }, 0);
          }
        });
      if (modalCancel) {
        modalCancel.addEventListener("click", () => {
          closeFilesModal({confirmed: false, value: ""});
        });
      }
      if (modalConfirm) {
        modalConfirm.addEventListener("click", () => {
          closeFilesModal({
            confirmed: true,
            value: modalInput.hidden ? "" : modalInput.value,
          });
        });
      }
      if (modalInput) {
        modalInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            closeFilesModal({confirmed: true, value: modalInput.value});
          } else if (event.key === "Escape") {
            event.preventDefault();
            closeFilesModal({confirmed: false, value: ""});
          }
        });
      }
      if (modalRoot) {
        modalRoot.addEventListener("mousedown", (event) => {
          if (event.target === modalRoot) {
            closeFilesModal({confirmed: false, value: ""});
          }
        });
      }

      root.addEventListener("click", (event) => {
        const row = event.target.closest(".finder-row");
        if (!row) return;
        if (dragInProgress) return;
        logNav("row click", {path: row.dataset.path, column: row.dataset.column, isDir: row.dataset.isDir});
        setFocusPath(row.dataset.path);
        row.focus({preventScroll: true});
        const columnIndex = Number(row.dataset.column || 0);
        setActiveColumn(columnIndex);
        ensureRowVisible(row);
        ensureColumnAndNextVisible(columnIndex);
      });

      root.addEventListener("mousedown", (event) => {
        const row = event.target.closest(".finder-row");
        if (!row) return;
        // Right-click is handled via context menu path; keep default for left button
        // so native dragging can start.
        if (event.button === 2) {
          event.preventDefault();
        }
      });

      root.addEventListener("contextmenu", (event) => {
        const row = event.target.closest(".finder-row");
        if (row) {
          event.preventDefault();
          logNav("contextmenu", {path: row.dataset.path, column: row.dataset.column});
          window.__filesPendingContextMenu = {
            path: row.dataset.path,
            isDir: row.dataset.isDir === "true",
            x: event.clientX,
            y: event.clientY,
          };
          row.click();
          return;
        }

        const header = event.target.closest(".column-header");
        if (!header) return;
        event.preventDefault();
        const path = header.dataset.path || "";
        if (!path) return;
        logNav("contextmenu header", {path});
        showContextMenu({
          path,
          isDir: true,
          x: event.clientX,
          y: event.clientY,
        });
        return;
      });

      root.addEventListener("contextmenu", (event) => {
        const row = event.target.closest(".finder-row");
        const header = event.target.closest(".column-header");
        if (row || header) return;
        const column = event.target.closest(".finder-column");
        if (!column) return;
        const path = column.dataset.path || "";
        if (!path) return;
        event.preventDefault();
        logNav("contextmenu column", {path, column: column.dataset.column});
        showContextMenu({
          path,
          isDir: true,
          x: event.clientX,
          y: event.clientY,
        });
      });
      root.addEventListener("dragstart", (event) => {
        const row = event.target.closest(".finder-row");
        const preview = event.target.closest(".preview-pane");
        if (preview && preview.dataset.previewDraggable === "false") return;
        if (!row && !preview) return;
        if (!event.dataTransfer) return;
        dragInProgress = true;

        const isPreviewDrag = !!preview && !row;
        const source = row || preview;
        const path = source?.dataset?.path || source?.dataset?.previewPath || "";
        const name = source?.dataset?.name || source?.dataset?.previewName || "item";
        const isDir =
          source?.dataset?.isDir === "true" || source?.dataset?.previewIsDir === "true";
        if (!path) {
          dragInProgress = false;
          return;
        }
        const fileUri = pathToFileUri(path);
        const mime = guessMimeType(name, isDir);
        setFocusPath(path);
        const matchingRow = rows.find((candidate) => candidate.dataset.path === path) || null;
        if (matchingRow) {
          matchingRow.focus({preventScroll: true});
          setActiveColumn(Number(matchingRow.dataset.column || 0));
          setRowSelectedLocally(matchingRow);
          ensureRowVisible(matchingRow);
          ensureColumnAndNextVisible(Number(matchingRow.dataset.column || 0));
        } else if (isPreviewDrag) {
          setActiveColumn(columns.length - 1);
          ensureColumnAndNextVisible(columns.length - 1);
        }

        if (startPluginDrag(path, name, isDir, event)) {
          return;
        }

        event.dataTransfer.effectAllowed = "copy";
        event.dataTransfer.setData("text/plain", path);
        event.dataTransfer.setData("text/uri-list", `${fileUri}\r\n`);
        event.dataTransfer.setData("DownloadURL", `${mime}:${name}:${fileUri}`);
        logNav("dragstart", {path, fileUri, mime});
      });
      root.addEventListener("dragend", () => {
        setTimeout(() => {
          dragInProgress = false;
        }, 0);
      });
      document.addEventListener("keydown", (event) => {
        if (event.key !== "Alt") return;
        optionPressed = true;
        if (dropTargetColumn && externalDragPoint) {
          updateDropHint(externalDragPoint.x, externalDragPoint.y, dropTargetColumn.dataset.path || "");
        }
      });
      document.addEventListener("keyup", (event) => {
        if (event.key !== "Alt") return;
        optionPressed = false;
        if (dropTargetColumn && externalDragPoint) {
          updateDropHint(externalDragPoint.x, externalDragPoint.y, dropTargetColumn.dataset.path || "");
        }
      });

      root.addEventListener("focusin", (event) => {
        const row = event.target.closest(".finder-row");
        if (!row) return;
        logScroll("focusin", {
          path: row.dataset.path,
          bodyTop: row.closest(".column-body")?.scrollTop ?? null,
        });
        setFocusPath(row.dataset.path);
        setActiveColumn(Number(row.dataset.column || 0));
      });

      for (const body of root.querySelectorAll(".column-body")) {
        body.addEventListener("scroll", () => {
          logScroll("column-body scroll", {top: body.scrollTop});
        });
      }

      const onKeyDown = (event) => {
        const lowered = String(event.key || "").toLowerCase();
        if ((event.metaKey || event.ctrlKey) && event.altKey && (event.key === "ArrowLeft" || event.key === "ArrowRight")) {
          event.preventDefault();
          event.stopPropagation();
          const tabIds = Array.from(root.querySelectorAll(".tab-shell[data-tab-id]"))
            .map((tab) => tab.dataset.tabId || "")
            .filter((id) => id.length > 0);
          if (tabIds.length > 1) {
            const currentIndex = Math.max(0, tabIds.indexOf(activeTabId));
            const delta = event.key === "ArrowRight" ? 1 : -1;
            const nextIndex = (currentIndex + delta + tabIds.length) % tabIds.length;
            const targetId = tabIds[nextIndex];
            if (targetId && targetId !== activeTabId) {
              htmxCommandSwap("activate_tab", {tabId: targetId});
            }
          }
          return;
        }
        if ((event.metaKey || event.ctrlKey) && lowered === "n") {
          event.preventDefault();
          event.stopPropagation();
          htmxCommandSwap("new_tab", {path: getFocusPath() || ""});
          return;
        }
        if ((event.metaKey || event.ctrlKey) && lowered === "g") {
          event.preventDefault();
          openGoToModal();
          return;
        }
        if (isGotoOpen()) {
          if (event.key === "Escape") {
            event.preventDefault();
            closeGoToModal();
          }
          return;
        }
        if (event.metaKey && lowered === "w") {
          event.preventDefault();
          event.stopPropagation();
          if (activeTabId && activeTabId !== "default") {
            htmxCommandSwap("close_tab", {tabId: activeTabId});
          }
          return;
        }
        if ((event.metaKey || event.ctrlKey) && (lowered === "p" || lowered === "t")) {
          event.preventDefault();
          openSearchPalette();
          return;
        }
        if (isSearchOpen()) {
          if (searchInput && document.activeElement !== searchInput) {
            searchInput.focus({preventScroll: true});
          }
          if (event.key === "Escape") {
            event.preventDefault();
            closeSearchPalette();
            return;
          }
          if (event.key === "ArrowDown") {
            event.preventDefault();
            moveSearchSelection(1);
            return;
          }
          if (event.key === "ArrowUp") {
            event.preventDefault();
            moveSearchSelection(-1);
            return;
          }
          if (event.key === "Enter") {
            event.preventDefault();
            openSearchSelection();
            return;
          }
          return;
        }
        if (!["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) return;

        const activeTag = document.activeElement?.tagName || "";
        if (activeTag === "INPUT" || activeTag === "TEXTAREA" || activeTag === "SELECT") return;
        if (document.activeElement?.isContentEditable) return;
        event.preventDefault();

        const current =
          (root.contains(document.activeElement) && document.activeElement.classList.contains("finder-row")
            ? document.activeElement
            : null) ||
          rows.find((row) => row.dataset.path === getFocusPath()) ||
          rightmostSelected() ||
          null;
        logNav("keydown", {
          key: event.key,
          currentPath: current?.dataset?.path || null,
          currentColumn: current ? Number(current.dataset.column || 0) : null,
          currentIsDir: current?.dataset?.isDir || null,
        });
        if (!current) {
          if (event.key === "ArrowDown") {
            const firstColumnRow = (rowsByColumn.get(0) || [])[0] || null;
            if (!firstColumnRow) return;
            event.preventDefault();
            setFocusPath(firstColumnRow.dataset.path);
            firstColumnRow.focus({preventScroll: true});
            setActiveColumn(0);
            ensureRowVisible(firstColumnRow);
            ensureColumnAndNextVisible(0);
            firstColumnRow.click();
          }
          return;
        }

        const columnIndex = Number(current.dataset.column || 0);
        const columnRows = rowsByColumn.get(columnIndex) || [];
        const rowIndex = columnRows.findIndex((row) => row.dataset.path === current.dataset.path);
        let target = null;
        let shouldNavigate = false;

        if (event.key === "ArrowUp" && rowIndex > 0) {
          target = columnRows[rowIndex - 1];
          shouldNavigate = true;
        } else if (event.key === "ArrowDown" && rowIndex >= 0 && rowIndex < columnRows.length - 1) {
          target = columnRows[rowIndex + 1];
          shouldNavigate = true;
        } else if (event.key === "ArrowLeft" && columnIndex > 0) {
          target =
            selectedInColumn(columnIndex - 1) ||
            (rowsByColumn.get(columnIndex - 1) || [])[0] ||
            null;
        } else if (event.key === "ArrowRight") {
          if (current.dataset.isDir === "true") {
            logNav("ArrowRight on dir", {
              path: current.dataset.path,
              column: current.dataset.column,
              action: "set pending right and click current",
            });
            window.__filesPendingRightFromPath = current.dataset.path;
            setFocusPath(current.dataset.path);
            current.click();
            return;
          } else {
            target =
              selectedInColumn(columnIndex + 1) ||
              (rowsByColumn.get(columnIndex + 1) || [])[0] ||
              null;
          }
        }

        if (!target) return;

        setFocusPath(target.dataset.path);
        target.focus({preventScroll: true});
        const targetColumnIndex = Number(target.dataset.column || 0);
        setActiveColumn(targetColumnIndex);
        ensureRowVisible(target);
        ensureColumnAndNextVisible(targetColumnIndex);
        if (shouldNavigate) {
          target.click();
        }
      };

      window.addEventListener("dragover", (event) => {
        optionPressed = !!event.altKey;
        if (dropTargetColumn && externalDragPoint) {
          updateDropHint(externalDragPoint.x, externalDragPoint.y, dropTargetColumn.dataset.path || "");
        }
      });

      const bindExternalDrop = () => {
        const getCurrentWindow = window.__TAURI__?.window?.getCurrentWindow;
        if (typeof getCurrentWindow !== "function") return;
        const currentWindow = getCurrentWindow();
        if (!currentWindow || typeof currentWindow.onDragDropEvent !== "function") return;
        const invoke = window.__TAURI__?.core?.invoke;
        Promise.resolve(
          currentWindow.onDragDropEvent(async (event) => {
            const payload = event?.payload || {};
            const type = payload.type;
            if (type === "leave") {
              hideDropHint();
              clearDropTarget();
              externalDragPaths = [];
              return;
            }
            if (type !== "over" && type !== "enter" && type !== "drop") {
              return;
            }

            if (typeof invoke === "function") {
              try {
                optionPressed = !!(await invoke("is_alt_pressed"));
              } catch (_error) {
                // Keep previous value if native modifier query fails.
              }
            }

            const sourcePaths = Array.isArray(payload.paths) ? payload.paths : [];
            if (sourcePaths.length > 0) {
              externalDragPaths = sourcePaths;
            }
            if (externalDragPaths.length === 0) return;
            const point = getClientPointFromDrop(payload.position);
            externalDragPoint = point;
            const targetColumn = setDropTargetByPoint(point.x, point.y);
            if (!targetColumn) {
              hideDropHint();
              return;
            }
            const targetDir = targetColumn.dataset.path || "";
            updateDropHint(point.x, point.y, targetDir);
            if (type === "drop") {
              commitExternalDrop(targetDir, getDropOperation());
            }
          }),
        )
          .then((unlisten) => {
            dragDropUnlisten = typeof unlisten === "function" ? unlisten : null;
          })
          .catch((error) => {
            logNav("onDragDropEvent bind failed", {error: String(error)});
          });
      };
      bindExternalDrop();

      document.addEventListener("keydown", onKeyDown);
      root.addEventListener("htmx:beforeRequest", () => {
        saveScrollState();
      });
      root.addEventListener(
        "htmx:beforeCleanupElement",
        (event) => {
          if (event.target !== root) {
            return;
          }
          if (previewPdfObjectUrl) {
            URL.revokeObjectURL(previewPdfObjectUrl);
            previewPdfObjectUrl = null;
          }
          if (previewGlbObjectUrl) {
            URL.revokeObjectURL(previewGlbObjectUrl);
            previewGlbObjectUrl = null;
          }
          if (previewVideoObjectUrl) {
            URL.revokeObjectURL(previewVideoObjectUrl);
            previewVideoObjectUrl = null;
          }
          clearSearchPreviewUrls();
          hideDropHint();
          clearDropTarget();
          if (typeof dragDropUnlisten === "function") {
            dragDropUnlisten();
            dragDropUnlisten = null;
          }
          if (typeof contextActionUnlisten === "function") {
            contextActionUnlisten();
            contextActionUnlisten = null;
          }
          stopSearchPolling();
          if (searchDebounceTimer) {
            clearTimeout(searchDebounceTimer);
            searchDebounceTimer = null;
          }
          if (typeof invoke === "function") {
            invoke("fuzzy_search_cancel").catch(() => {});
          }
          saveScrollState();
          document.removeEventListener("keydown", onKeyDown);
        },
        {once: true},
      );

    })();
  </script>
</div>
